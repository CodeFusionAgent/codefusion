"""
ReAct Supervisor Agent for Multi-Agent Code Exploration Framework

This supervisor agent orchestrates ReAct-based specialized agents to perform comprehensive
codebase analysis using proper reasoning, action, and observation loops.
"""

import time
import logging
from typing import Dict, List, Any, Optional
from dataclasses import dataclass

from ..aci.repo import CodeRepo
from ..config import CfConfig
from ..core.react_agent import ReActAgent, ReActAction, ReActObservation, ActionType
from .react_documentation_agent import ReActDocumentationAgent
from .react_codebase_agent import ReActCodebaseAgent
from .react_architecture_agent import ReActArchitectureAgent


@dataclass
class SupervisorInsight:
    """Insights generated by the supervisor from agent results."""
    insight_type: str
    content: str
    confidence: float
    contributing_agents: List[str]
    evidence: List[str]


class ReActSupervisorAgent(ReActAgent):
    """
    Supervisor agent that uses ReAct pattern to orchestrate other ReAct agents.
    
    ReAct Loop:
    1. Reason: Determine which agents to activate and what questions to ask
    2. Act: Delegate tasks to specialized agents and gather their insights
    3. Observe: Synthesize results and determine if goal is achieved
    """
    
    def __init__(self, repo: CodeRepo, config: CfConfig):
        super().__init__(repo, config, "SupervisorAgent")
        
        # Initialize specialized ReAct agents
        self.agents = {
            'documentation': ReActDocumentationAgent(repo, config),
            'codebase': ReActCodebaseAgent(repo, config),
            'architecture': ReActArchitectureAgent(repo, config)
        }
        
        # Agent coordination state
        self.agent_results = {}
        self.cross_agent_insights = []
        self.synthesis_results = {}
        self.focus_areas = []
        
        # Agent priorities based on goal
        self.agent_priorities = {
            'documentation': ['doc', 'readme', 'guide', 'manual', 'help'],
            'codebase': ['code', 'function', 'class', 'implementation', 'logic'],
            'architecture': ['architecture', 'design', 'pattern', 'component', 'system']
        }
        
    def explore_repository(self, goal: str = "comprehensive analysis", focus: str = "all") -> Dict[str, Any]:
        """
        Main entry point for repository exploration using ReAct pattern.
        
        Args:
            goal: Primary exploration goal
            focus: Focus area ('all', 'docs', 'code', 'arch')
            
        Returns:
            Comprehensive analysis results from orchestrated agents
        """
        exploration_goal = f"Orchestrate agents to {goal} with focus on {focus}"
        return self.execute_react_loop(exploration_goal, max_iterations=12)
    
    def reason(self) -> str:
        """
        Reasoning phase: Determine which agents to activate and what to ask them.
        
        Returns:
            Reasoning about next coordination action
        """
        current_context = self.state.current_context
        iteration = self.state.iteration
        goal = self.state.goal
        
        # Parse focus from goal
        focus = self._extract_focus_from_goal(goal)
        
        # First iteration: Plan agent activation strategy
        if iteration == 1:
            return f"I need to coordinate multiple agents to achieve the goal: {goal}. I should determine which agents to activate based on the focus and start with the most relevant ones."
        
        # Early iterations: Activate agents based on focus
        if iteration <= 3:
            active_agents = list(self.agent_results.keys())
            
            if focus == "all":
                if not active_agents:
                    return "I should start by activating all three agents (documentation, codebase, architecture) to get comprehensive coverage."
                elif len(active_agents) < 3:
                    missing_agents = set(self.agents.keys()) - set(active_agents)
                    return f"I have activated {len(active_agents)} agents. I should now activate the remaining agents: {', '.join(missing_agents)}"
            
            elif focus == "docs":
                if 'documentation' not in active_agents:
                    return "The focus is on documentation. I should primarily activate the documentation agent."
                elif 'architecture' not in active_agents:
                    return "Documentation analysis is running. I should also activate the architecture agent to understand system design from docs."
            
            elif focus == "code":
                if 'codebase' not in active_agents:
                    return "The focus is on code. I should primarily activate the codebase agent."
                elif 'architecture' not in active_agents:
                    return "Codebase analysis is running. I should also activate the architecture agent to understand code structure."
            
            elif focus == "arch":
                if 'architecture' not in active_agents:
                    return "The focus is on architecture. I should primarily activate the architecture agent."
                elif 'documentation' not in active_agents:
                    return "Architecture analysis is running. I should also activate the documentation agent to find design docs."
        
        # Middle iterations: Monitor agents and guide their analysis
        if iteration <= 6:
            # Check if we need to provide more specific guidance to agents
            if self.agent_results:
                incomplete_agents = []
                for agent_name, result in self.agent_results.items():
                    if not result.get('goal_achieved', False):
                        incomplete_agents.append(agent_name)
                
                if incomplete_agents:
                    return f"Agents {', '.join(incomplete_agents)} haven't achieved their goals yet. I should provide more specific guidance or wait for them to complete."
            
            return "I should continue monitoring agent progress and start preparing for result synthesis."
        
        # Later iterations: Synthesis and cross-agent insights
        if iteration <= 9:
            if len(self.agent_results) >= 2:
                return "I have results from multiple agents. I should synthesize their findings to generate cross-agent insights and comprehensive understanding."
            else:
                return "I need more agent results before I can perform meaningful synthesis."
        
        # Final iterations: Generate comprehensive results
        if iteration <= 12:
            return "I should generate the final comprehensive analysis by combining all agent results and insights."
        
        # Default reasoning
        return "I should continue coordinating agents and synthesizing their results to achieve the exploration goal."
    
    def plan_action(self, reasoning: str) -> ReActAction:
        """
        Plan the next action based on reasoning.
        
        Args:
            reasoning: The reasoning output
            
        Returns:
            Action to take
        """
        iteration = self.state.iteration
        goal = self.state.goal
        focus = self._extract_focus_from_goal(goal)
        
        # Early iterations: Agent activation
        if iteration <= 3:
            # Determine which agent to activate
            active_agents = list(self.agent_results.keys())
            
            if focus == "all":
                if 'documentation' not in active_agents:
                    return ReActAction(
                        action_type=ActionType.LLM_REASONING,
                        description="Activate documentation agent for comprehensive doc analysis",
                        parameters={
                            'context': f"Goal: {goal}, Focus: {focus}",
                            'question': "What specific documentation aspects should be analyzed?",
                            'agent_to_activate': 'documentation'
                        },
                        expected_outcome="Get documentation analysis results"
                    )
                elif 'codebase' not in active_agents:
                    return ReActAction(
                        action_type=ActionType.LLM_REASONING,
                        description="Activate codebase agent for code analysis",
                        parameters={
                            'context': f"Goal: {goal}, Focus: {focus}",
                            'question': "What specific code aspects should be analyzed?",
                            'agent_to_activate': 'codebase'
                        },
                        expected_outcome="Get codebase analysis results"
                    )
                elif 'architecture' not in active_agents:
                    return ReActAction(
                        action_type=ActionType.LLM_REASONING,
                        description="Activate architecture agent for architectural analysis",
                        parameters={
                            'context': f"Goal: {goal}, Focus: {focus}",
                            'question': "What specific architectural aspects should be analyzed?",
                            'agent_to_activate': 'architecture'
                        },
                        expected_outcome="Get architecture analysis results"
                    )
            
            elif focus == "docs":
                if 'documentation' not in active_agents:
                    return ReActAction(
                        action_type=ActionType.LLM_REASONING,
                        description="Activate documentation agent for focused doc analysis",
                        parameters={
                            'context': f"Goal: {goal}, Focus: {focus}",
                            'question': "What documentation should be analyzed for this goal?",
                            'agent_to_activate': 'documentation'
                        },
                        expected_outcome="Get focused documentation analysis"
                    )
                elif 'architecture' not in active_agents:
                    return ReActAction(
                        action_type=ActionType.LLM_REASONING,
                        description="Activate architecture agent to understand system design",
                        parameters={
                            'context': f"Goal: {goal}, Focus: {focus}",
                            'question': "What architectural aspects can be understood from documentation?",
                            'agent_to_activate': 'architecture'
                        },
                        expected_outcome="Get architecture insights from documentation"
                    )
            
            elif focus == "code":
                if 'codebase' not in active_agents:
                    return ReActAction(
                        action_type=ActionType.LLM_REASONING,
                        description="Activate codebase agent for focused code analysis",
                        parameters={
                            'context': f"Goal: {goal}, Focus: {focus}",
                            'question': "What code aspects should be analyzed for this goal?",
                            'agent_to_activate': 'codebase'
                        },
                        expected_outcome="Get focused codebase analysis"
                    )
                elif 'architecture' not in active_agents:
                    return ReActAction(
                        action_type=ActionType.LLM_REASONING,
                        description="Activate architecture agent to understand code structure",
                        parameters={
                            'context': f"Goal: {goal}, Focus: {focus}",
                            'question': "What architectural patterns can be found in the code?",
                            'agent_to_activate': 'architecture'
                        },
                        expected_outcome="Get architecture insights from code"
                    )
            
            elif focus == "arch":
                if 'architecture' not in active_agents:
                    return ReActAction(
                        action_type=ActionType.LLM_REASONING,
                        description="Activate architecture agent for focused architectural analysis",
                        parameters={
                            'context': f"Goal: {goal}, Focus: {focus}",
                            'question': "What architectural aspects should be analyzed for this goal?",
                            'agent_to_activate': 'architecture'
                        },
                        expected_outcome="Get focused architecture analysis"
                    )
                elif 'documentation' not in active_agents:
                    return ReActAction(
                        action_type=ActionType.LLM_REASONING,
                        description="Activate documentation agent to find design docs",
                        parameters={
                            'context': f"Goal: {goal}, Focus: {focus}",
                            'question': "What documentation supports architectural understanding?",
                            'agent_to_activate': 'documentation'
                        },
                        expected_outcome="Get documentation supporting architecture"
                    )
        
        # Middle iterations: Synthesis and cross-agent insights
        if iteration <= 9 and len(self.agent_results) >= 2:
            return ReActAction(
                action_type=ActionType.LLM_SUMMARY,
                description="Synthesize results from multiple agents",
                parameters={
                    'content': str(self.agent_results),
                    'summary_type': 'cross_agent_synthesis',
                    'focus': focus
                },
                expected_outcome="Generate cross-agent insights and comprehensive understanding"
            )
        
        # Final iterations: Generate comprehensive results
        return ReActAction(
            action_type=ActionType.LLM_SUMMARY,
            description="Generate final comprehensive analysis",
            parameters={
                'content': str(self.agent_results),
                'summary_type': 'final_comprehensive',
                'focus': focus
            },
            expected_outcome="Generate final comprehensive analysis results"
        )
    
    def act(self, action: ReActAction) -> ReActObservation:
        """
        Execute coordination actions including activating agents.
        
        Args:
            action: Action to execute
            
        Returns:
            Observation from the action
        """
        # Check if this is an agent activation action
        if action.parameters.get('agent_to_activate'):
            agent_name = action.parameters['agent_to_activate']
            result = self._activate_agent(agent_name, action.parameters)
            
            # Convert result to ReActObservation
            success = result.get('goal_achieved', False) if isinstance(result, dict) else False
            return ReActObservation(
                action_taken=action.description,
                result=result,
                success=success,
                insight=f"Activated {agent_name} agent: {'Success' if success else 'Partial completion'}",
                confidence=0.8 if success else 0.5,
                goal_progress=0.3 if success else 0.1
            )
        
        # Otherwise, use the parent act method
        return super().act(action)
    
    def _activate_agent(self, agent_name: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """
        Activate a specific agent with given parameters.
        
        Args:
            agent_name: Name of the agent to activate
            parameters: Parameters for the agent
            
        Returns:
            Agent execution results
        """
        if agent_name not in self.agents:
            return {'error': f'Agent {agent_name} not found'}
        
        agent = self.agents[agent_name]
        context = parameters.get('context', '')
        question = parameters.get('question', '')
        
        self.logger.info(f"🎯 Activating {agent_name} agent with question: {question}")
        
        try:
            # Execute the agent's main method
            if agent_name == 'documentation':
                result = agent.scan_documentation(question)
            elif agent_name == 'codebase':
                result = agent.analyze_codebase(question)
            elif agent_name == 'architecture':
                result = agent.map_architecture(question)
            else:
                result = {'error': f'Unknown agent method for {agent_name}'}
            
            # Store the result
            self.agent_results[agent_name] = result
            
            self.logger.info(f"✅ {agent_name} agent completed analysis")
            return result
            
        except Exception as e:
            error_result = {'error': str(e), 'agent': agent_name}
            self.agent_results[agent_name] = error_result
            self.logger.error(f"❌ {agent_name} agent failed: {e}")
            return error_result
    
    def observe(self, observation):
        """
        Enhanced observation phase for supervisor coordination.
        
        Args:
            observation: Observation from the action
        """
        super().observe(observation)
        
        # Process coordination-specific observations
        if observation.success and observation.result:
            result = observation.result
            
            # If this was an agent activation
            if isinstance(result, dict) and result.get('summary'):
                # Extract insights from agent results
                self._extract_cross_agent_insights()
            
            # If this was a synthesis action
            elif isinstance(result, dict) and result.get('summary'):
                self.synthesis_results['latest_synthesis'] = result
    
    def _extract_cross_agent_insights(self):
        """Extract insights that span multiple agents."""
        if len(self.agent_results) < 2:
            return
        
        # Compare documentation and code findings
        if 'documentation' in self.agent_results and 'codebase' in self.agent_results:
            doc_results = self.agent_results['documentation']
            code_results = self.agent_results['codebase']
            
            # Look for consistency between documentation and code
            if doc_results.get('summary') and code_results.get('summary'):
                insight = SupervisorInsight(
                    insight_type='documentation_code_consistency',
                    content='Analyzed consistency between documentation and code implementation',
                    confidence=0.7,
                    contributing_agents=['documentation', 'codebase'],
                    evidence=[doc_results.get('summary', ''), code_results.get('summary', '')]
                )
                self.cross_agent_insights.append(insight)
        
        # Compare architecture and code findings
        if 'architecture' in self.agent_results and 'codebase' in self.agent_results:
            arch_results = self.agent_results['architecture']
            code_results = self.agent_results['codebase']
            
            if arch_results.get('summary') and code_results.get('summary'):
                insight = SupervisorInsight(
                    insight_type='architecture_code_alignment',
                    content='Analyzed alignment between architectural design and code structure',
                    confidence=0.8,
                    contributing_agents=['architecture', 'codebase'],
                    evidence=[arch_results.get('summary', ''), code_results.get('summary', '')]
                )
                self.cross_agent_insights.append(insight)
    
    def _extract_focus_from_goal(self, goal: str) -> str:
        """Extract focus area from goal."""
        goal_lower = goal.lower()
        
        if 'docs' in goal_lower or 'documentation' in goal_lower:
            return 'docs'
        elif 'code' in goal_lower or 'implementation' in goal_lower:
            return 'code'
        elif 'arch' in goal_lower or 'architecture' in goal_lower:
            return 'arch'
        else:
            return 'all'
    
    def _generate_summary(self) -> str:
        """Generate a comprehensive summary of supervisor coordination."""
        summary = f"Supervisor Coordination Summary:\\n"
        summary += f"• Coordinated {len(self.agent_results)} agents\\n"
        summary += f"• Generated {len(self.cross_agent_insights)} cross-agent insights\\n"
        
        # Agent results summary
        for agent_name, result in self.agent_results.items():
            if result.get('goal_achieved'):
                summary += f"• {agent_name.title()} agent: Successfully completed analysis\\n"
            elif result.get('error'):
                summary += f"• {agent_name.title()} agent: Failed with error\\n"
            else:
                summary += f"• {agent_name.title()} agent: Partially completed\\n"
        
        # Cross-agent insights
        if self.cross_agent_insights:
            insight_types = [insight.insight_type for insight in self.cross_agent_insights]
            summary += f"• Cross-agent insights: {', '.join(set(insight_types))}\\n"
        
        # Cache performance
        total_cache_hits = sum(
            result.get('cache_hits', 0) for result in self.agent_results.values()
            if isinstance(result, dict)
        )
        if total_cache_hits > 0:
            summary += f"• Total cache hits: {total_cache_hits}\\n"
        
        # Error summary
        total_errors = sum(
            result.get('error_count', 0) for result in self.agent_results.values()
            if isinstance(result, dict)
        )
        if total_errors > 0:
            summary += f"• Total errors: {total_errors}\\n"
        
        return summary
    
    def get_agent_results(self) -> Dict[str, Any]:
        """Get results from all activated agents."""
        return self.agent_results
    
    def get_cross_agent_insights(self) -> List[SupervisorInsight]:
        """Get insights that span multiple agents."""
        return self.cross_agent_insights
    
    def get_synthesis_results(self) -> Dict[str, Any]:
        """Get synthesis results."""
        return self.synthesis_results
    
    def generate_comprehensive_report(self) -> Dict[str, Any]:
        """Generate a comprehensive report from all agents."""
        report = {
            'goal': self.state.goal,
            'execution_time': 0,  # Will be updated by caller
            'agent_results': self.agent_results,
            'cross_agent_insights': [insight.__dict__ for insight in self.cross_agent_insights],
            'synthesis_results': self.synthesis_results,
            'summary': self._generate_summary()
        }
        
        # Add agent-specific insights
        for agent_name, result in self.agent_results.items():
            if isinstance(result, dict) and result.get('summary'):
                report[f'{agent_name}_summary'] = result['summary']
        
        return report