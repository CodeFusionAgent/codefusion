{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CodeFusion ReAct Framework Documentation","text":"<p>CodeFusion is a comprehensive ReAct (Reasoning + Acting) agent framework for intelligent code exploration and analysis. It enables multi-agent, LLM-powered systematic investigation of codebases through sophisticated reasoning, tool usage, and observation cycles.</p>"},{"location":"#react-philosophy","title":"\ud83c\udfaf ReAct Philosophy","text":"<p>CodeFusion implements the ReAct pattern for systematic code analysis:</p> <ul> <li>\ud83e\udde0 REASON: AI-powered analysis of current state and goal progress</li> <li>\ud83c\udfaf ACT: Execute specialized tools based on reasoning</li> <li>\ud83d\udc41\ufe0f OBSERVE: Process results and update understanding</li> <li>\ud83d\udd04 REPEAT: Continue until goals are achieved</li> </ul> <p>This creates intelligent, adaptive exploration that learns from observations and adjusts strategy dynamically.</p>"},{"location":"#key-features","title":"\ud83d\ude80 Key Features","text":"<ul> <li>Multi-Agent Architecture: Specialized agents for documentation, code, and architecture analysis</li> <li>AI-Powered Reasoning: LLM-driven decision making and goal tracking</li> <li>Rich Tool Ecosystem: 8 specialized tools for comprehensive code exploration</li> <li>Persistent Caching: Cross-session memory with TTL and LRU eviction</li> <li>Execution Tracing: Performance monitoring and comprehensive logging</li> <li>Error Recovery: Circuit breakers, retry logic, and fallback strategies</li> <li>LLM Integration: Support for OpenAI, Anthropic, and LLaMA via LiteLLM</li> </ul>"},{"location":"#react-process-flow","title":"\ud83d\udd04 ReAct Process Flow","text":"<p>CodeFusion follows the systematic Reason \u2192 Act \u2192 Observe cycle:</p> <ol> <li>\ud83e\udde0 REASONING: AI analyzes current state, goal progress, and available context</li> <li>\ud83c\udfaf ACTING: Execute planned actions using specialized tools</li> <li>\ud83d\udc41\ufe0f OBSERVING: Process results, extract insights, and update understanding</li> <li>\ud83d\udd04 ITERATING: Adapt exploration strategy based on findings</li> </ol>"},{"location":"#multi-agent-react-example","title":"Multi-Agent ReAct Example","text":"<pre><code>Goal: \"Comprehensive analysis of authentication system\"\n\n\ud83e\udd16 Supervisor Agent: Activates specialized agents based on focus\n\u251c\u2500\u2500 \ud83d\udcda Documentation Agent: Reason \u2192 Search auth docs \u2192 Observe API patterns\n\u251c\u2500\u2500 \ud83d\udcbb Codebase Agent: Reason \u2192 Scan auth/ directory \u2192 Observe JWT implementation\n\u2514\u2500\u2500 \ud83c\udfd7\ufe0f Architecture Agent: Reason \u2192 Map auth flow \u2192 Observe security patterns\n\n\ud83d\udd17 Cross-Agent Synthesis: Combine insights for comprehensive understanding\n</code></pre>"},{"location":"#quick-start","title":"\ud83c\udfaf Quick Start","text":"<p>Get started with CodeFusion ReAct framework:</p> <pre><code># Install CodeFusion\npip install -e .\n\n# Install LLM support (optional but recommended)\npip install litellm\n\n# Multi-agent comprehensive analysis\npython -m cf.run.simple_run analyze /path/to/repo --focus=all\n\n# Documentation-focused analysis\npython -m cf.run.simple_run analyze /path/to/repo --focus=docs\n\n# Question-based exploration\npython -m cf.run.simple_run explore /path/to/repo \"How does authentication work?\"\n\n# Demo the framework\npython demo_cf_framework.py /path/to/repo\n</code></pre>"},{"location":"#documentation-structure","title":"\ud83d\udcda Documentation Structure","text":"<p>This documentation is organized into several sections:</p> <ul> <li>Installation: Get CodeFusion up and running</li> <li>Usage: Learn how to use the ReAct framework</li> <li>Configuration: Configure LLM integration and performance</li> <li>ReAct Framework: Comprehensive framework documentation</li> <li>API Reference: Complete API documentation</li> <li>Development: Architecture and contribution guide</li> </ul>"},{"location":"#react-framework-architecture","title":"\ud83c\udfd7\ufe0f ReAct Framework Architecture","text":"<p>CodeFusion implements a sophisticated multi-agent ReAct architecture:</p> <pre><code>cf/\n\u251c\u2500\u2500 core/                       # ReAct Foundation\n\u2502   \u251c\u2500\u2500 react_agent.py         # Base ReAct agent with R\u2192A\u2192O loops\n\u2502   \u251c\u2500\u2500 react_config.py        # Performance and LLM configuration\n\u2502   \u2514\u2500\u2500 react_tracing.py       # Execution monitoring and metrics\n\u251c\u2500\u2500 agents/                     # Specialized ReAct Agents\n\u2502   \u251c\u2500\u2500 react_supervisor_agent.py      # Multi-agent orchestration\n\u2502   \u251c\u2500\u2500 react_documentation_agent.py   # Documentation analysis\n\u2502   \u251c\u2500\u2500 react_codebase_agent.py       # Source code analysis\n\u2502   \u2514\u2500\u2500 react_architecture_agent.py   # System design analysis\n\u251c\u2500\u2500 llm/                        # LLM Integration\n\u2502   \u251c\u2500\u2500 real_llm.py            # LiteLLM provider integration\n\u2502   \u2514\u2500\u2500 simple_llm.py          # Fallback reasoning\n\u251c\u2500\u2500 tools/                      # Tool Ecosystem\n\u2502   \u2514\u2500\u2500 advanced_tools.py      # 8 specialized exploration tools\n\u2514\u2500\u2500 run/\n    \u2514\u2500\u2500 simple_run.py           # Multi-agent CLI interface\n</code></pre>"},{"location":"#react-vs-traditional-approaches","title":"\ud83c\udd9a ReAct vs Traditional Approaches","text":""},{"location":"#traditional-static-analysis","title":"\u274c Traditional Static Analysis","text":"<ul> <li>One-time parsing of entire codebase</li> <li>Static analysis without context</li> <li>Limited reasoning about findings</li> <li>No adaptive exploration</li> <li>Fast but shallow, misses context</li> </ul>"},{"location":"#react-framework-approach","title":"\u2705 ReAct Framework Approach","text":"<ul> <li>AI-powered reasoning and decision making</li> <li>Multi-agent collaborative analysis</li> <li>Adaptive exploration that learns from observations</li> <li>Goal-oriented loops with progress tracking</li> <li>Persistent caching across sessions</li> <li>Comprehensive error recovery</li> </ul>"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>We welcome contributions to the CodeFusion ReAct framework! Contributions should enhance the ReAct pattern implementation:</p> <ol> <li>Maintain ReAct Principles: Preserve the Reason \u2192 Act \u2192 Observe pattern</li> <li>Add Specialized Agents: Create domain-specific analysis agents</li> <li>Extend Tool Ecosystem: Add new tools for enhanced capabilities</li> <li>Improve LLM Integration: Support additional providers and models</li> <li>Enhance Error Recovery: Strengthen resilience and fault tolerance</li> </ol> <p>See Contributing Guide for detailed information.</p>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>CodeFusion is released under the Apache License 2.0. See LICENSE for details.</p>"},{"location":"#support-resources","title":"\ud83c\udd98 Support &amp; Resources","text":"<ul> <li>\ud83d\udcd6 Complete Documentation</li> <li>\ud83e\udde0 ReAct Framework Guide</li> <li>\ud83d\udd27 API Reference</li> <li>\ud83d\udcac GitHub Issues</li> <li>\ud83d\udc1b Bug Reports</li> <li>\ud83d\udca1 Feature Requests</li> </ul> <p>Built on the ReAct pattern for systematic, intelligent code exploration through reasoning, acting, and observing.</p>"},{"location":"react-framework/","title":"CodeFusion ReAct Framework Documentation","text":""},{"location":"react-framework/#overview","title":"Overview","text":"<p>The CodeFusion ReAct Framework is a sophisticated agent-based system that uses the ReAct (Reasoning + Acting) pattern to systematically explore and analyze codebases. This framework provides intelligent, LLM-powered agents that work together to understand code structure, documentation, and architecture.</p>"},{"location":"react-framework/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Quick Start</li> <li>Core Concepts</li> <li>Agent Types</li> <li>Configuration</li> <li>Tool Ecosystem</li> <li>LLM Integration</li> <li>Caching &amp; Performance</li> <li>Tracing &amp; Monitoring</li> <li>Error Handling</li> <li>Advanced Usage</li> <li>API Reference</li> <li>Troubleshooting</li> </ol>"},{"location":"react-framework/#quick-start","title":"Quick Start","text":""},{"location":"react-framework/#installation","title":"Installation","text":"<pre><code># Install CodeFusion with ReAct framework\npip install -e .\n\n# Optional: Install LiteLLM for advanced LLM support\npip install litellm\n</code></pre>"},{"location":"react-framework/#basic-usage","title":"Basic Usage","text":"<pre><code># Multi-agent repository analysis\ncf analyze /path/to/repo --focus=all\n\n# Documentation-focused analysis\ncf analyze /path/to/repo --focus=docs\n\n# Architecture-focused analysis  \ncf analyze /path/to/repo --focus=arch\n\n# Code-focused analysis\ncf analyze /path/to/repo --focus=code\n</code></pre>"},{"location":"react-framework/#configuration","title":"Configuration","text":"<pre><code># Set up OpenAI integration\nexport CF_LLM_MODEL=gpt-4\nexport CF_LLM_API_KEY=your-openai-api-key\n\n# Set up Anthropic integration\nexport CF_LLM_MODEL=claude-3-sonnet-20240229\nexport CF_LLM_API_KEY=your-anthropic-api-key\n\n# Set up LLaMA integration\nexport CF_LLM_MODEL=together_ai/meta-llama/Llama-2-7b-chat-hf\nexport CF_LLM_API_KEY=your-together-ai-api-key\n</code></pre>"},{"location":"react-framework/#core-concepts","title":"Core Concepts","text":""},{"location":"react-framework/#react-pattern","title":"ReAct Pattern","text":"<p>The ReAct pattern follows a systematic three-phase cycle:</p> <ol> <li>Reason: Analyze current state and determine the next best action</li> <li>Act: Execute the determined action using available tools</li> <li>Observe: Process the results and update understanding</li> </ol> <pre><code># Example ReAct cycle\ndef execute_react_loop(self, goal: str) -&gt; Dict[str, Any]:\n    while not goal_achieved and iteration &lt; max_iterations:\n        # REASON: What should I do next?\n        reasoning = self.reason()\n\n        # ACT: Take the reasoned action\n        action = self.plan_action(reasoning)\n        observation = self.act(action)\n\n        # OBSERVE: Reflect on what happened\n        self.observe(observation)\n</code></pre>"},{"location":"react-framework/#multi-agent-architecture","title":"Multi-Agent Architecture","text":"<p>The framework uses specialized agents that work together:</p> <ul> <li>Supervisor Agent: Orchestrates other agents and synthesizes insights</li> <li>Documentation Agent: Analyzes README files, docs, and guides</li> <li>Codebase Agent: Examines source code, functions, and patterns</li> <li>Architecture Agent: Studies system design and architectural patterns</li> </ul>"},{"location":"react-framework/#tool-rich-environment","title":"Tool-Rich Environment","text":"<p>Each agent has access to 8 core tools:</p> <ul> <li>Directory Scanning: Explore repository structure</li> <li>File Listing: Find files matching patterns</li> <li>File Reading: Examine file contents</li> <li>Pattern Searching: Search across multiple files</li> <li>Code Analysis: Extract code entities and patterns</li> <li>LLM Reasoning: AI-powered decision making</li> <li>LLM Summarization: AI-powered content summarization</li> <li>Caching: Store and retrieve previous results</li> </ul>"},{"location":"react-framework/#agent-types","title":"Agent Types","text":""},{"location":"react-framework/#1-react-supervisor-agent","title":"1. ReAct Supervisor Agent","text":"<p>Purpose: Coordinates multiple specialized agents and synthesizes cross-agent insights.</p> <pre><code>from cf.agents.react_supervisor_agent import ReActSupervisorAgent\nfrom cf.aci.repo import LocalCodeRepo\nfrom cf.config import CfConfig\n\n# Create supervisor agent\nrepo = LocalCodeRepo(\"/path/to/repo\")\nconfig = CfConfig()\nsupervisor = ReActSupervisorAgent(repo, config)\n\n# Run comprehensive analysis\nresults = supervisor.explore_repository(focus=\"all\")\n</code></pre> <p>Key Features: - Multi-agent coordination - Cross-agent insight synthesis - Focus-based analysis (docs, code, arch, all) - Intelligent agent activation based on findings</p>"},{"location":"react-framework/#2-react-documentation-agent","title":"2. ReAct Documentation Agent","text":"<p>Purpose: Specializes in analyzing documentation, README files, and guides.</p> <pre><code>from cf.agents.react_documentation_agent import ReActDocumentationAgent\n\n# Create documentation agent\ndoc_agent = ReActDocumentationAgent(repo, config)\n\n# Analyze documentation\nresults = doc_agent.execute_react_loop(\"Analyze project documentation structure\")\n</code></pre> <p>Specializations: - Markdown file analysis - Documentation structure mapping - Guide and tutorial identification - API documentation discovery</p>"},{"location":"react-framework/#3-react-codebase-agent","title":"3. ReAct Codebase Agent","text":"<p>Purpose: Focuses on source code analysis, function extraction, and pattern detection.</p> <pre><code>from cf.agents.react_codebase_agent import ReActCodebaseAgent\n\n# Create codebase agent\ncode_agent = ReActCodebaseAgent(repo, config)\n\n# Analyze codebase\nresults = code_agent.execute_react_loop(\"Identify main classes and functions\")\n</code></pre> <p>Specializations: - Code entity extraction (classes, functions, variables) - Language-specific analysis - Complexity assessment - Dependency mapping - Pattern recognition</p>"},{"location":"react-framework/#4-react-architecture-agent","title":"4. ReAct Architecture Agent","text":"<p>Purpose: Understands system design, components, and architectural patterns.</p> <pre><code>from cf.agents.react_architecture_agent import ReActArchitectureAgent\n\n# Create architecture agent\narch_agent = ReActArchitectureAgent(repo, config)\n\n# Analyze architecture\nresults = arch_agent.execute_react_loop(\"Understand system architecture\")\n</code></pre> <p>Specializations: - Component identification - Design pattern detection - System boundary analysis - Architectural insight generation</p>"},{"location":"react-framework/#configuration_1","title":"Configuration","text":""},{"location":"react-framework/#environment-variables","title":"Environment Variables","text":"<pre><code># ReAct Loop Configuration\nCF_REACT_MAX_ITERATIONS=20          # Maximum iterations per agent\nCF_REACT_ITERATION_TIMEOUT=30.0     # Timeout per iteration (seconds)\nCF_REACT_TOTAL_TIMEOUT=600.0        # Total timeout (seconds)\n\n# Error Handling\nCF_REACT_MAX_ERRORS=10               # Maximum errors before stopping\nCF_REACT_MAX_CONSECUTIVE_ERRORS=3    # Maximum consecutive errors\nCF_REACT_ERROR_RECOVERY=true         # Enable error recovery\n\n# Caching Configuration\nCF_REACT_CACHE_ENABLED=true          # Enable caching\nCF_REACT_CACHE_MAX_SIZE=1000         # Maximum cache entries\nCF_REACT_CACHE_TTL=3600              # Cache TTL (seconds)\n\n# Tracing Configuration\nCF_REACT_TRACING_ENABLED=true        # Enable tracing\nCF_REACT_TRACE_DIR=./traces          # Trace output directory\nCF_REACT_LOG_LEVEL=INFO              # Logging level\n\n# LLM Configuration\nCF_LLM_MODEL=gpt-4                   # LLM model to use\nCF_LLM_API_KEY=your-api-key          # API key\nCF_LLM_MAX_TOKENS=1000               # Max tokens per request\nCF_LLM_TEMPERATURE=0.7               # LLM temperature\n</code></pre>"},{"location":"react-framework/#performance-profiles","title":"Performance Profiles","text":"<pre><code>from cf.core.react_config import ReActConfig\n\n# Fast profile - quick analysis\nconfig = ReActConfig()\nconfig.apply_performance_profile(\"fast\")\n# max_iterations=10, timeouts=15s, cache=500\n\n# Balanced profile - default\nconfig.apply_performance_profile(\"balanced\")\n# max_iterations=20, timeouts=30s, cache=1000\n\n# Thorough profile - comprehensive analysis\nconfig.apply_performance_profile(\"thorough\")\n# max_iterations=50, timeouts=60s, cache=2000\n</code></pre>"},{"location":"react-framework/#custom-configuration","title":"Custom Configuration","text":"<pre><code>from cf.core.react_config import ReActConfig\n\n# Create custom configuration\nconfig = ReActConfig(\n    max_iterations=30,\n    iteration_timeout=45.0,\n    cache_enabled=True,\n    cache_max_size=2000,\n    tracing_enabled=True,\n    trace_directory=\"./custom_traces\"\n)\n\n# Validate configuration\nconfig.validate()\n\n# Use with agent\nagent = ReActCodebaseAgent(repo, cf_config, react_config=config)\n</code></pre>"},{"location":"react-framework/#tool-ecosystem","title":"Tool Ecosystem","text":""},{"location":"react-framework/#available-tools","title":"Available Tools","text":"<p>Each ReAct agent has access to these tools through the <code>ActionType</code> enum:</p>"},{"location":"react-framework/#1-scan_directory","title":"1. SCAN_DIRECTORY","text":"<pre><code># Recursively scan directory structure\naction = ReActAction(\n    action_type=ActionType.SCAN_DIRECTORY,\n    description=\"Scan project root directory\",\n    parameters={\n        'directory': '.',\n        'max_depth': 3\n    }\n)\n</code></pre>"},{"location":"react-framework/#2-list_files","title":"2. LIST_FILES","text":"<pre><code># List files matching patterns\naction = ReActAction(\n    action_type=ActionType.LIST_FILES,\n    description=\"Find Python files\",\n    parameters={\n        'pattern': '*.py',\n        'directory': './src'\n    }\n)\n</code></pre>"},{"location":"react-framework/#3-read_file","title":"3. READ_FILE","text":"<pre><code># Read file contents\naction = ReActAction(\n    action_type=ActionType.READ_FILE,\n    description=\"Read main module\",\n    parameters={\n        'file_path': 'src/main.py',\n        'max_lines': 100\n    }\n)\n</code></pre>"},{"location":"react-framework/#4-search_files","title":"4. SEARCH_FILES","text":"<pre><code># Search for patterns across files\naction = ReActAction(\n    action_type=ActionType.SEARCH_FILES,\n    description=\"Find API endpoints\",\n    parameters={\n        'pattern': 'def api_',\n        'file_types': ['.py'],\n        'max_results': 20\n    }\n)\n</code></pre>"},{"location":"react-framework/#5-analyze_code","title":"5. ANALYZE_CODE","text":"<pre><code># Analyze code structure\naction = ReActAction(\n    action_type=ActionType.ANALYZE_CODE,\n    description=\"Analyze module complexity\",\n    parameters={\n        'file_path': 'src/complex_module.py',\n        'analysis_type': 'basic'\n    }\n)\n</code></pre>"},{"location":"react-framework/#6-llm_reasoning","title":"6. LLM_REASONING","text":"<pre><code># Use LLM for reasoning\naction = ReActAction(\n    action_type=ActionType.LLM_REASONING,\n    description=\"Reason about next action\",\n    parameters={\n        'context': 'Current findings...',\n        'question': 'What should I investigate next?',\n        'agent_type': 'codebase'\n    }\n)\n</code></pre>"},{"location":"react-framework/#7-llm_summary","title":"7. LLM_SUMMARY","text":"<pre><code># Generate AI summaries\naction = ReActAction(\n    action_type=ActionType.LLM_SUMMARY,\n    description=\"Summarize findings\",\n    parameters={\n        'content': 'Analysis results...',\n        'summary_type': 'technical',\n        'focus': 'architecture'\n    }\n)\n</code></pre>"},{"location":"react-framework/#8-cache_lookup-cache_store","title":"8. CACHE_LOOKUP / CACHE_STORE","text":"<pre><code># Cache operations\nlookup_action = ReActAction(\n    action_type=ActionType.CACHE_LOOKUP,\n    description=\"Check cached analysis\",\n    parameters={'key': 'module_analysis_main.py'}\n)\n\nstore_action = ReActAction(\n    action_type=ActionType.CACHE_STORE,\n    description=\"Store analysis results\",\n    parameters={\n        'key': 'module_analysis_main.py',\n        'value': analysis_results\n    }\n)\n</code></pre>"},{"location":"react-framework/#tool-validation","title":"Tool Validation","text":"<p>The framework includes comprehensive tool validation:</p> <pre><code># Parameter validation\ndef _validate_action_parameters(self, action: ReActAction) -&gt; Optional[str]:\n    if action.action_type == ActionType.READ_FILE:\n        if 'file_path' not in action.parameters:\n            return \"file_path parameter required for READ_FILE\"\n    return None\n\n# Result validation\ndef _validate_tool_result(self, action: ReActAction, result: Any) -&gt; Dict[str, Any]:\n    if isinstance(result, dict) and 'error' in result:\n        return {'valid': False, 'error': f\"Tool returned error: {result['error']}\"}\n    return {'valid': True, 'error': None}\n</code></pre>"},{"location":"react-framework/#llm-integration","title":"LLM Integration","text":""},{"location":"react-framework/#supported-providers","title":"Supported Providers","text":"<p>The framework supports multiple LLM providers through LiteLLM:</p>"},{"location":"react-framework/#openai","title":"OpenAI","text":"<pre><code>export CF_LLM_MODEL=gpt-4\nexport CF_LLM_API_KEY=your-openai-api-key\n</code></pre> <p>Supported models: - <code>gpt-4</code> - <code>gpt-4-turbo</code> - <code>gpt-3.5-turbo</code> - <code>gpt-3.5-turbo-16k</code></p>"},{"location":"react-framework/#anthropic","title":"Anthropic","text":"<pre><code>export CF_LLM_MODEL=claude-3-sonnet-20240229\nexport CF_LLM_API_KEY=your-anthropic-api-key\n</code></pre> <p>Supported models: - <code>claude-3-opus-20240229</code> - <code>claude-3-sonnet-20240229</code> - <code>claude-3-haiku-20240307</code></p>"},{"location":"react-framework/#llama-via-together-ai","title":"LLaMA via Together AI","text":"<pre><code>export CF_LLM_MODEL=together_ai/meta-llama/Llama-2-7b-chat-hf\nexport CF_LLM_API_KEY=your-together-ai-api-key\n</code></pre> <p>Supported models: - <code>together_ai/meta-llama/Llama-2-7b-chat-hf</code> - <code>together_ai/meta-llama/Llama-2-13b-chat-hf</code> - <code>together_ai/meta-llama/Llama-2-70b-chat-hf</code> - <code>together_ai/meta-llama/Code-Llama-7b-Python-hf</code></p>"},{"location":"react-framework/#llama-via-replicate","title":"LLaMA via Replicate","text":"<pre><code>export CF_LLM_MODEL=replicate/meta/llama-2-7b-chat\nexport CF_LLM_API_KEY=your-replicate-token\n</code></pre>"},{"location":"react-framework/#llama-via-ollama-local","title":"LLaMA via Ollama (Local)","text":"<pre><code>export CF_LLM_MODEL=ollama/llama2\n# No API key needed for local Ollama\n</code></pre>"},{"location":"react-framework/#llm-usage-in-agents","title":"LLM Usage in Agents","text":"<pre><code># Reasoning with LLM\ndef reason(self) -&gt; str:\n    reasoning_result = self._tool_llm_reasoning({\n        'context': self._build_context(),\n        'question': self.state.goal,\n        'agent_type': self.agent_name.lower()\n    })\n    return reasoning_result.get('reasoning', 'Continue exploration')\n\n# Summarization with LLM\ndef _generate_summary(self) -&gt; str:\n    summary_result = self._tool_llm_summary({\n        'content': self._compile_findings(),\n        'summary_type': 'technical',\n        'focus': 'key_insights'\n    })\n    return summary_result.get('summary', 'Analysis completed')\n</code></pre>"},{"location":"react-framework/#fallback-mechanism","title":"Fallback Mechanism","text":"<p>If LLM calls fail, the framework gracefully falls back to simple implementations:</p> <pre><code>try:\n    from ..llm.real_llm import real_llm\n    result = real_llm.reasoning(context, question, agent_type)\n    return result\nexcept Exception as e:\n    self.logger.warning(f\"Real LLM failed, using fallback: {e}\")\n    from ..llm.simple_llm import llm\n    result = llm.reasoning(context, question, agent_type)\n    result['fallback'] = True\n    return result\n</code></pre>"},{"location":"react-framework/#caching-performance","title":"Caching &amp; Performance","text":""},{"location":"react-framework/#persistent-caching","title":"Persistent Caching","text":"<p>The framework includes sophisticated caching with persistence across sessions:</p> <pre><code>class ReActCache:\n    def __init__(self, max_size: int = 1000, cache_dir: Optional[str] = None, ttl: int = 3600):\n        # In-memory cache with optional disk persistence\n        # TTL-based expiration\n        # LRU eviction policy\n</code></pre> <p>Features: - Persistent Storage: JSON files for cross-session continuity - TTL Expiration: Automatic cleanup of stale entries - LRU Eviction: Memory-efficient cache management - Error Resilience: Graceful handling of corrupt cache files</p>"},{"location":"react-framework/#cache-configuration","title":"Cache Configuration","text":"<pre><code># Enable persistent caching\nCF_REACT_CACHE_ENABLED=true\nCF_REACT_CACHE_MAX_SIZE=1000\nCF_REACT_CACHE_TTL=3600\nCF_REACT_TRACE_DIR=./traces  # Cache stored in ./traces/cache/\n</code></pre>"},{"location":"react-framework/#performance-optimization","title":"Performance Optimization","text":"<pre><code># Performance profiles optimize different aspects\nconfig = ReActConfig()\n\n# Fast: Prioritizes speed\nconfig.apply_performance_profile(\"fast\")\n# - max_iterations: 10\n# - iteration_timeout: 15s\n# - cache_max_size: 500\n\n# Balanced: Optimal balance\nconfig.apply_performance_profile(\"balanced\")\n# - max_iterations: 20  \n# - iteration_timeout: 30s\n# - cache_max_size: 1000\n\n# Thorough: Maximizes completeness\nconfig.apply_performance_profile(\"thorough\")\n# - max_iterations: 50\n# - iteration_timeout: 60s\n# - cache_max_size: 2000\n</code></pre>"},{"location":"react-framework/#tracing-monitoring","title":"Tracing &amp; Monitoring","text":""},{"location":"react-framework/#comprehensive-tracing","title":"Comprehensive Tracing","text":"<p>The framework includes detailed execution tracing:</p> <pre><code>@dataclass\nclass ReActTrace:\n    trace_id: str\n    agent_name: str\n    iteration: int\n    phase: str  # 'reason', 'act', 'observe'\n    timestamp: float\n    duration: float\n    content: Dict[str, Any]\n    success: bool\n    error: Optional[str]\n</code></pre>"},{"location":"react-framework/#session-management","title":"Session Management","text":"<pre><code># Tracing lifecycle\ntracer = ReActTracer()\n\n# Start session\nsession_id = tracer.start_session(\"codebase_agent\", \"Analyze main module\")\n\n# Trace phases\ntracer.trace_phase(session_id, \"reason\", iteration=1, \n                  content={'reasoning': 'Should read main.py first'}, \n                  duration=0.5)\n\ntracer.trace_phase(session_id, \"act\", iteration=1,\n                  content={'action': 'READ_FILE', 'file': 'main.py'},\n                  duration=1.2, success=True)\n\n# End session\ncompleted_session = tracer.end_session(session_id, final_results)\n</code></pre>"},{"location":"react-framework/#performance-metrics","title":"Performance Metrics","text":"<pre><code># Get global metrics\nmetrics = tracer.get_global_metrics()\n\n# Example metrics:\n{\n    'total_sessions': 15,\n    'total_iterations': 180,\n    'total_errors': 2,\n    'avg_session_duration': 45.2,\n    'avg_reason_duration': 1.1,\n    'avg_act_duration': 2.3,\n    'avg_observe_duration': 0.8,\n    'agent_usage': {\n        'codebase_agent': 8,\n        'doc_agent': 4,\n        'arch_agent': 3\n    }\n}\n</code></pre>"},{"location":"react-framework/#trace-export","title":"Trace Export","text":"<pre><code># Export traces to file\ntracer.export_metrics('./metrics.json')\n\n# Get human-readable summary\nsummary = tracer.get_trace_summary(session_id)\nprint(summary)\n</code></pre>"},{"location":"react-framework/#error-handling","title":"Error Handling","text":""},{"location":"react-framework/#multi-level-error-handling","title":"Multi-Level Error Handling","text":"<p>The framework implements comprehensive error handling at multiple levels:</p>"},{"location":"react-framework/#1-circuit-breakers","title":"1. Circuit Breakers","text":"<pre><code># Prevent cascading failures\nif self.consecutive_errors &gt;= self.react_config.max_consecutive_errors:\n    self.logger.error(f\"Too many consecutive errors ({self.consecutive_errors})\")\n    break\n</code></pre>"},{"location":"react-framework/#2-retry-logic","title":"2. Retry Logic","text":"<pre><code># Retry failed operations\nfor attempt in range(self.react_config.max_tool_retries + 1):\n    try:\n        result = self._execute_tool_with_timeout(tool_func, action.parameters)\n        break\n    except Exception as e:\n        if attempt &lt; self.react_config.max_tool_retries:\n            recovery_action = self._attempt_tool_recovery(action, str(e))\n            continue\n</code></pre>"},{"location":"react-framework/#3-recovery-strategies","title":"3. Recovery Strategies","text":"<pre><code>def _attempt_tool_recovery(self, action: ReActAction, error: str) -&gt; Optional[str]:\n    error_lower = error.lower()\n\n    if 'file not found' in error_lower:\n        return 'file_not_found'  # Switch to directory scan\n    elif 'permission denied' in error_lower:\n        return 'permission_denied'  # Try different approach\n    elif 'timeout' in error_lower:\n        return 'timeout'  # Use cached results\n</code></pre>"},{"location":"react-framework/#4-graceful-degradation","title":"4. Graceful Degradation","text":"<pre><code># LLM fallback\ntry:\n    result = real_llm.reasoning(context, question)\nexcept Exception:\n    result = simple_llm.reasoning(context, question)\n    result['fallback'] = True\n</code></pre>"},{"location":"react-framework/#error-configuration","title":"Error Configuration","text":"<pre><code># Error handling configuration\nCF_REACT_MAX_ERRORS=10               # Maximum total errors\nCF_REACT_MAX_CONSECUTIVE_ERRORS=3    # Maximum consecutive errors\nCF_REACT_ERROR_RECOVERY=true         # Enable error recovery\nCF_REACT_CIRCUIT_BREAKER_THRESHOLD=5 # Circuit breaker threshold\n</code></pre>"},{"location":"react-framework/#advanced-usage","title":"Advanced Usage","text":""},{"location":"react-framework/#custom-agent-development","title":"Custom Agent Development","text":"<p>Create specialized agents by extending <code>ReActAgent</code>:</p> <pre><code>from cf.core.react_agent import ReActAgent, ReActAction, ActionType\n\nclass CustomAnalysisAgent(ReActAgent):\n    def __init__(self, repo: CodeRepo, config: CfConfig):\n        super().__init__(repo, config, \"custom_agent\")\n        self.domain_knowledge = {}\n\n    def reason(self) -&gt; str:\n        \"\"\"Custom reasoning logic\"\"\"\n        if not self.state.observations:\n            return \"Start by scanning the repository structure\"\n        elif len(self.state.observations) &lt; 5:\n            return \"Search for domain-specific patterns\"\n        else:\n            return \"Analyze findings and generate insights\"\n\n    def plan_action(self, reasoning: str) -&gt; ReActAction:\n        \"\"\"Custom action planning\"\"\"\n        if \"scan\" in reasoning.lower():\n            return ReActAction(\n                action_type=ActionType.SCAN_DIRECTORY,\n                description=\"Scan repository for structure\",\n                parameters={'directory': '.', 'max_depth': 2}\n            )\n        # ... additional action planning\n\n    def _generate_summary(self) -&gt; str:\n        \"\"\"Custom summary generation\"\"\"\n        return f\"Custom analysis completed with {len(self.state.observations)} observations\"\n</code></pre>"},{"location":"react-framework/#multi-agent-coordination","title":"Multi-Agent Coordination","text":"<p>Implement custom coordination logic:</p> <pre><code>class CustomSupervisor(ReActAgent):\n    def __init__(self, repo: CodeRepo, config: CfConfig):\n        super().__init__(repo, config, \"custom_supervisor\")\n        self.specialized_agents = {\n            'security': SecurityAnalysisAgent(repo, config),\n            'performance': PerformanceAnalysisAgent(repo, config),\n            'testing': TestAnalysisAgent(repo, config)\n        }\n\n    def coordinate_agents(self, focus: str) -&gt; Dict[str, Any]:\n        results = {}\n\n        for agent_name, agent in self.specialized_agents.items():\n            if focus == 'all' or focus == agent_name:\n                agent_result = agent.execute_react_loop(f\"Analyze {agent_name} aspects\")\n                results[agent_name] = agent_result\n\n        return self._synthesize_results(results)\n</code></pre>"},{"location":"react-framework/#custom-tools","title":"Custom Tools","text":"<p>Add new tools to the ecosystem:</p> <pre><code># Extend ActionType enum\nclass ExtendedActionType(ActionType):\n    DEPENDENCY_ANALYSIS = \"dependency_analysis\"\n    SECURITY_SCAN = \"security_scan\"\n    PERFORMANCE_PROFILE = \"performance_profile\"\n\n# Add tool implementations\ndef _tool_dependency_analysis(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"Custom dependency analysis tool\"\"\"\n    file_path = params.get('file_path', '')\n    # ... implementation\n    return {'dependencies': dependencies, 'analysis': analysis}\n\n# Register new tools\nself.tools[ExtendedActionType.DEPENDENCY_ANALYSIS] = self._tool_dependency_analysis\n</code></pre>"},{"location":"react-framework/#batch-processing","title":"Batch Processing","text":"<p>Process multiple repositories:</p> <pre><code>def batch_analyze_repositories(repo_paths: List[str], focus: str = \"all\") -&gt; Dict[str, Any]:\n    results = {}\n\n    for repo_path in repo_paths:\n        try:\n            repo = LocalCodeRepo(repo_path)\n            config = CfConfig()\n            supervisor = ReActSupervisorAgent(repo, config)\n\n            result = supervisor.explore_repository(focus=focus)\n            results[repo_path] = result\n\n        except Exception as e:\n            results[repo_path] = {'error': str(e)}\n\n    return results\n</code></pre>"},{"location":"react-framework/#api-reference","title":"API Reference","text":""},{"location":"react-framework/#core-classes","title":"Core Classes","text":""},{"location":"react-framework/#reactagent-abstract-base-class","title":"<code>ReActAgent</code> (Abstract Base Class)","text":"<pre><code>class ReActAgent(ABC):\n    def __init__(self, repo: CodeRepo, config: CfConfig, agent_name: str, \n                 react_config: Optional[ReActConfig] = None)\n\n    def execute_react_loop(self, goal: str, max_iterations: Optional[int] = None) -&gt; Dict[str, Any]\n\n    @abstractmethod\n    def reason(self) -&gt; str\n\n    @abstractmethod\n    def plan_action(self, reasoning: str) -&gt; ReActAction\n\n    def act(self, action: ReActAction) -&gt; ReActObservation\n\n    def observe(self, observation: ReActObservation)\n\n    @abstractmethod\n    def _generate_summary(self) -&gt; str\n</code></pre>"},{"location":"react-framework/#reactconfig","title":"<code>ReActConfig</code>","text":"<pre><code>@dataclass\nclass ReActConfig:\n    max_iterations: int = 20\n    iteration_timeout: float = 30.0\n    total_timeout: float = 600.0\n    max_errors: int = 10\n    max_consecutive_errors: int = 3\n    error_recovery_enabled: bool = True\n    cache_enabled: bool = True\n    cache_max_size: int = 1000\n    cache_ttl: int = 3600\n    tracing_enabled: bool = True\n\n    @classmethod\n    def from_env(cls) -&gt; 'ReActConfig'\n\n    def apply_performance_profile(self, profile: str)\n\n    def validate(self) -&gt; bool\n</code></pre>"},{"location":"react-framework/#reactaction","title":"<code>ReActAction</code>","text":"<pre><code>@dataclass\nclass ReActAction:\n    action_type: ActionType\n    description: str\n    parameters: Dict[str, Any] = field(default_factory=dict)\n    expected_outcome: str = \"\"\n    tool_name: str = \"\"\n</code></pre>"},{"location":"react-framework/#reactobservation","title":"<code>ReActObservation</code>","text":"<pre><code>@dataclass\nclass ReActObservation:\n    action_taken: str\n    result: Any\n    success: bool\n    insight: str\n    confidence: float = 0.0\n    suggests_next_action: Optional[str] = None\n    goal_progress: float = 0.0\n</code></pre>"},{"location":"react-framework/#reacttracer","title":"<code>ReActTracer</code>","text":"<pre><code>class ReActTracer:\n    def __init__(self, log_level: str = \"INFO\", trace_dir: Optional[str] = None)\n\n    def start_session(self, agent_name: str, goal: str) -&gt; str\n\n    def trace_phase(self, session_id: str, phase: str, iteration: int, \n                   content: Dict[str, Any], duration: float = 0.0, \n                   success: bool = True, error: Optional[str] = None) -&gt; str\n\n    def end_session(self, session_id: str, final_result: Dict[str, Any]) -&gt; ReActSession\n\n    def get_global_metrics(self) -&gt; Dict[str, Any]\n\n    def export_metrics(self, output_file: str)\n</code></pre>"},{"location":"react-framework/#specialized-agents","title":"Specialized Agents","text":""},{"location":"react-framework/#reactsupervisoragent","title":"<code>ReActSupervisorAgent</code>","text":"<pre><code>class ReActSupervisorAgent(ReActAgent):\n    def explore_repository(self, focus: str = \"all\", max_agents: int = 3) -&gt; Dict[str, Any]\n\n    def activate_agent(self, agent_type: str, sub_goal: str) -&gt; Dict[str, Any]\n\n    def synthesize_cross_agent_insights(self, agent_results: Dict[str, Any]) -&gt; List[Dict[str, Any]]\n</code></pre>"},{"location":"react-framework/#reactdocumentationagent","title":"<code>ReActDocumentationAgent</code>","text":"<pre><code>class ReActDocumentationAgent(ReActAgent):\n    def discover_documentation(self) -&gt; List[str]\n\n    def analyze_documentation_structure(self, doc_files: List[str]) -&gt; Dict[str, Any]\n\n    def extract_documentation_insights(self, content: str) -&gt; Dict[str, Any]\n</code></pre>"},{"location":"react-framework/#reactcodebaseagent","title":"<code>ReActCodebaseAgent</code>","text":"<pre><code>class ReActCodebaseAgent(ReActAgent):\n    def extract_code_entities(self, file_path: str) -&gt; List[CodeEntity]\n\n    def analyze_code_patterns(self, files: List[str]) -&gt; List[CodePattern]\n\n    def assess_code_complexity(self, file_path: str) -&gt; Dict[str, Any]\n</code></pre>"},{"location":"react-framework/#reactarchitectureagent","title":"<code>ReActArchitectureAgent</code>","text":"<pre><code>class ReActArchitectureAgent(ReActAgent):\n    def identify_components(self) -&gt; List[Dict[str, Any]]\n\n    def detect_architectural_patterns(self) -&gt; List[Dict[str, Any]]\n\n    def analyze_system_boundaries(self) -&gt; Dict[str, Any]\n</code></pre>"},{"location":"react-framework/#troubleshooting","title":"Troubleshooting","text":""},{"location":"react-framework/#common-issues","title":"Common Issues","text":""},{"location":"react-framework/#1-llm-connection-failures","title":"1. LLM Connection Failures","text":"<pre><code># Check API key configuration\necho $CF_LLM_API_KEY\n\n# Test with simple LLM fallback\nCF_LLM_MODEL=simple cf analyze /repo\n</code></pre>"},{"location":"react-framework/#2-cache-permission-issues","title":"2. Cache Permission Issues","text":"<pre><code># Check cache directory permissions\nls -la ./traces/cache/\n\n# Use custom cache directory\nCF_REACT_TRACE_DIR=/tmp/cf_traces cf analyze /repo\n</code></pre>"},{"location":"react-framework/#3-timeout-issues","title":"3. Timeout Issues","text":"<pre><code># Increase timeouts for large repositories\nCF_REACT_ITERATION_TIMEOUT=60.0 CF_REACT_TOTAL_TIMEOUT=1800.0 cf analyze /repo\n\n# Use fast profile\nCF_REACT_MAX_ITERATIONS=10 cf analyze /repo\n</code></pre>"},{"location":"react-framework/#4-memory-issues","title":"4. Memory Issues","text":"<pre><code># Reduce cache size\nCF_REACT_CACHE_MAX_SIZE=500 cf analyze /repo\n\n# Disable caching\nCF_REACT_CACHE_ENABLED=false cf analyze /repo\n</code></pre>"},{"location":"react-framework/#debug-mode","title":"Debug Mode","text":"<p>Enable verbose logging for debugging:</p> <pre><code># Enable debug logging\nCF_REACT_LOG_LEVEL=DEBUG CF_REACT_VERBOSE_LOGGING=true cf analyze /repo\n\n# Enable tracing\nCF_REACT_TRACING_ENABLED=true CF_REACT_TRACE_DIR=./debug_traces cf analyze /repo\n</code></pre>"},{"location":"react-framework/#performance-tuning","title":"Performance Tuning","text":"<pre><code># Quick analysis\nCF_REACT_MAX_ITERATIONS=5 CF_REACT_ITERATION_TIMEOUT=10.0 cf analyze /repo\n\n# Comprehensive analysis\nCF_REACT_MAX_ITERATIONS=100 CF_REACT_ITERATION_TIMEOUT=120.0 cf analyze /repo\n\n# Parallel tools (future feature)\nCF_REACT_PARALLEL_TOOLS=true CF_REACT_MAX_PARALLEL_TOOLS=3 cf analyze /repo\n</code></pre>"},{"location":"react-framework/#error-recovery","title":"Error Recovery","text":"<p>If agents get stuck or error out:</p> <pre><code># Enable aggressive error recovery\nCF_REACT_ERROR_RECOVERY=true CF_REACT_MAX_CONSECUTIVE_ERRORS=1 cf analyze /repo\n\n# Reduce circuit breaker threshold\nCF_REACT_CIRCUIT_BREAKER_THRESHOLD=3 cf analyze /repo\n</code></pre> <p>For additional support, please refer to the Architecture Documentation or open an issue on the project repository.</p>"},{"location":"api/","title":"API Reference","text":"<p>Welcome to the CodeFusion ReAct Framework API documentation. This section provides comprehensive documentation for all classes, methods, and interfaces in the framework.</p>"},{"location":"api/#core-components","title":"Core Components","text":""},{"location":"api/#react-foundation","title":"ReAct Foundation","text":"<ul> <li>ReAct Agent - Base agent implementing Reason \u2192 Act \u2192 Observe loops</li> <li>ReAct Config - Configuration and performance tuning</li> <li>ReAct Tracing - Execution monitoring and metrics</li> </ul>"},{"location":"api/#specialized-agents","title":"Specialized Agents","text":"<ul> <li>Supervisor Agent - Multi-agent orchestration and coordination</li> <li>Documentation Agent - Documentation analysis and processing</li> <li>Codebase Agent - Source code analysis and pattern detection</li> <li>Architecture Agent - System design and architectural analysis</li> </ul>"},{"location":"api/#infrastructure","title":"Infrastructure","text":"<ul> <li>LLM Integration - Language model providers and interfaces</li> <li>Tools - Exploration tool ecosystem</li> <li>Repository Interface - Code repository access and operations</li> <li>Configuration - Global configuration management</li> </ul>"},{"location":"api/#quick-api-examples","title":"Quick API Examples","text":""},{"location":"api/#basic-react-agent-usage","title":"Basic ReAct Agent Usage","text":"<pre><code>from cf.agents.react_supervisor_agent import ReActSupervisorAgent\nfrom cf.aci.repo import LocalCodeRepo\nfrom cf.config import CfConfig\n\n# Initialize components\nrepo = LocalCodeRepo(\"/path/to/repository\")\nconfig = CfConfig()\nsupervisor = ReActSupervisorAgent(repo, config)\n\n# Run multi-agent analysis\nresults = supervisor.explore_repository(\n    goal=\"analyze authentication system\",\n    focus=\"all\"\n)\n\n# Access results\nagent_results = supervisor.get_agent_results()\ninsights = supervisor.get_cross_agent_insights()\n</code></pre>"},{"location":"api/#custom-agent-development","title":"Custom Agent Development","text":"<pre><code>from cf.core.react_agent import ReActAgent, ReActAction, ActionType\n\nclass CustomAnalysisAgent(ReActAgent):\n    def reason(self) -&gt; str:\n        # Implement reasoning logic\n        if not self.state.observations:\n            return \"Need to start analysis by scanning codebase\"\n        return \"Continue with detailed examination\"\n\n    def plan_action(self, reasoning: str) -&gt; ReActAction:\n        # Plan next action based on reasoning\n        return ReActAction(\n            action_type=ActionType.SCAN_DIRECTORY,\n            description=\"Scan for analysis targets\",\n            parameters={'directory': '.', 'pattern': '*.py'}\n        )\n\n    def _generate_summary(self) -&gt; str:\n        return f\"Custom analysis complete: {len(self.state.observations)} findings\"\n</code></pre>"},{"location":"api/#llm-integration","title":"LLM Integration","text":"<pre><code>from cf.llm.real_llm import RealLLM, LLMConfig\n\n# Configure LLM provider\nconfig = LLMConfig(\n    model=\"gpt-4\",\n    api_key=\"your-api-key\",\n    max_tokens=1000,\n    temperature=0.7\n)\n\nllm = RealLLM(config)\n\n# Use for reasoning\nreasoning_result = llm.reasoning(\n    context=\"Current codebase state\",\n    question=\"What should I analyze next?\",\n    agent_type=\"codebase\"\n)\n\n# Use for summarization\nsummary_result = llm.summarize(\n    content=\"Analysis findings...\",\n    summary_type=\"comprehensive\",\n    focus=\"security patterns\"\n)\n</code></pre>"},{"location":"api/#navigation","title":"Navigation","text":"<p>Use the sidebar to navigate through the API documentation. Each section provides:</p> <ul> <li>Class Overview: Purpose and role in the framework</li> <li>Constructor Parameters: How to initialize the class</li> <li>Methods: All public methods with parameters and return types</li> <li>Examples: Practical usage examples</li> <li>Integration: How the class integrates with other components</li> </ul>"},{"location":"api/#type-definitions","title":"Type Definitions","text":"<p>All APIs use type hints for better development experience:</p> <pre><code>from typing import Dict, List, Any, Optional\nfrom cf.core.react_agent import ReActAction, ReActObservation, ActionType\n</code></pre>"},{"location":"api/#error-handling","title":"Error Handling","text":"<p>The framework includes comprehensive error handling:</p> <pre><code>try:\n    results = supervisor.explore_repository(goal=\"analysis\")\nexcept Exception as e:\n    print(f\"Analysis failed: {e}\")\n    # Framework includes automatic recovery mechanisms\n</code></pre> <p>For detailed information about specific components, explore the individual API documentation pages.</p>"},{"location":"api/architecture-agent/","title":"Architecture Agent","text":"<p>               Bases: <code>ReActAgent</code></p> <p>Architecture agent that uses ReAct pattern for systematic architectural analysis.</p> <p>ReAct Loop: 1. Reason: Analyze what architectural aspects to explore next 2. Act: Use tools to scan, analyze, and understand system design 3. Observe: Reflect on findings and build architectural understanding</p> Source code in <code>cf/agents/react_architecture_agent.py</code> <pre><code>class ReActArchitectureAgent(ReActAgent):\n    \"\"\"\n    Architecture agent that uses ReAct pattern for systematic architectural analysis.\n\n    ReAct Loop:\n    1. Reason: Analyze what architectural aspects to explore next\n    2. Act: Use tools to scan, analyze, and understand system design\n    3. Observe: Reflect on findings and build architectural understanding\n    \"\"\"\n\n    def __init__(self, repo: CodeRepo, config: CfConfig):\n        super().__init__(repo, config, \"ArchitectureAgent\")\n\n        # Architecture analysis state\n        self.components = []\n        self.patterns = []\n        self.data_flows = []\n        self.architectural_layers = {}\n        self.system_boundaries = {}\n\n        # Component identification patterns\n        self.component_patterns = {\n            'api': ['api', 'rest', 'graphql', 'endpoint', 'route', 'controller'],\n            'service': ['service', 'manager', 'handler', 'processor', 'worker'],\n            'model': ['model', 'entity', 'dto', 'schema', 'data'],\n            'database': ['db', 'database', 'repository', 'dao', 'orm', 'storage'],\n            'ui': ['ui', 'view', 'component', 'page', 'template', 'frontend'],\n            'middleware': ['middleware', 'filter', 'interceptor', 'guard'],\n            'config': ['config', 'settings', 'environment', 'constants'],\n            'util': ['util', 'helper', 'common', 'shared', 'lib', 'utils']\n        }\n\n        # Pattern detection strategies\n        self.pattern_detectors = {\n            'mvc': self._detect_mvc_pattern,\n            'microservices': self._detect_microservices_pattern,\n            'layered': self._detect_layered_pattern,\n            'repository': self._detect_repository_pattern,\n            'factory': self._detect_factory_pattern,\n            'observer': self._detect_observer_pattern,\n            'singleton': self._detect_singleton_pattern,\n            'adapter': self._detect_adapter_pattern,\n            'decorator': self._detect_decorator_pattern,\n            'strategy': self._detect_strategy_pattern\n        }\n\n        # Quality attributes to assess\n        self.quality_attributes = [\n            'maintainability', 'scalability', 'performance', \n            'security', 'reliability', 'testability'\n        ]\n\n    def map_architecture(self, description: str) -&gt; Dict[str, Any]:\n        \"\"\"\n        Main entry point for architecture mapping using ReAct pattern.\n\n        Args:\n            description: Description of what to focus on during analysis\n\n        Returns:\n            Comprehensive architectural analysis results\n        \"\"\"\n        goal = f\"Map architecture for: {description}\"\n        return self.execute_react_loop(goal, max_iterations=18)\n\n    def reason(self) -&gt; str:\n        \"\"\"\n        Reasoning phase: Determine what architectural analysis action to take next.\n\n        Returns:\n            Reasoning about next action to take\n        \"\"\"\n        current_context = self.state.current_context\n        iteration = self.state.iteration\n\n        # First iteration: Start with high-level structure analysis\n        if iteration == 1:\n            return \"I should start by understanding the overall repository structure to identify architectural layers and major components.\"\n\n        # Early iterations: Focus on component discovery\n        if iteration &lt;= 3 and not self.components:\n            return \"I need to identify system components by scanning the directory structure and looking for architectural patterns.\"\n\n        # If we have some components but need more context\n        if self.components and len(self.components) &lt; 3:\n            return f\"I found {len(self.components)} components but need to discover more. Let me analyze code files to understand the system better.\"\n\n        # Focus on understanding relationships and data flows\n        if self.components and not self.data_flows:\n            return \"I have identified components. Now I should analyze how they interact and what data flows between them.\"\n\n        # Pattern detection phase\n        if len(self.components) &gt;= 3 and not self.patterns:\n            return \"I have good component coverage. Now I should detect architectural patterns and design principles used in the system.\"\n\n        # Goal-specific analysis\n        if \"microservice\" in self.state.goal.lower():\n            return \"The goal mentions microservices. I should look for service boundaries, communication patterns, and deployment structures.\"\n        elif \"api\" in self.state.goal.lower():\n            return \"The goal mentions API. I should analyze API design, endpoints, and how the API layer is structured.\"\n        elif \"database\" in self.state.goal.lower():\n            return \"The goal mentions database. I should analyze data models, database access patterns, and data architecture.\"\n        elif \"security\" in self.state.goal.lower():\n            return \"The goal mentions security. I should analyze authentication, authorization, and security patterns.\"\n\n        # Deep analysis phase\n        if len(self.components) &gt;= 3 and self.patterns:\n            return \"I have good understanding of components and patterns. Now I should analyze quality attributes and architectural decisions.\"\n\n        # Default reasoning\n        return \"I should continue analyzing the architecture systematically, focusing on understanding the system design and its implications.\"\n\n    def plan_action(self, reasoning: str) -&gt; ReActAction:\n        \"\"\"\n        Plan the next action based on reasoning.\n\n        Args:\n            reasoning: The reasoning output\n\n        Returns:\n            Action to take\n        \"\"\"\n        iteration = self.state.iteration\n\n        # Early iterations: Structure analysis\n        if iteration &lt;= 2:\n            return ReActAction(\n                action_type=ActionType.SCAN_DIRECTORY,\n                description=\"Scan repository structure for architectural analysis\",\n                parameters={'directory': '.', 'max_depth': 4},\n                expected_outcome=\"Understand overall system structure and identify main components\"\n            )\n\n        # Component discovery phase\n        if not self.components and iteration &lt;= 5:\n            return ReActAction(\n                action_type=ActionType.LIST_FILES,\n                description=\"List files to identify architectural components\",\n                parameters={'pattern': '*', 'directory': '.'},\n                expected_outcome=\"Identify files that represent different architectural components\"\n            )\n\n        # Analyze main application files\n        if iteration &lt;= 6:\n            return ReActAction(\n                action_type=ActionType.SEARCH_FILES,\n                description=\"Search for main application entry points\",\n                parameters={'pattern': 'main', 'file_types': ['.py', '.js', '.java', '.go'], 'max_results': 10},\n                expected_outcome=\"Find main application files and understand entry points\"\n            )\n\n        # Configuration analysis\n        if iteration &lt;= 8:\n            return ReActAction(\n                action_type=ActionType.SEARCH_FILES,\n                description=\"Search for configuration files\",\n                parameters={'pattern': 'config', 'file_types': ['.yaml', '.yml', '.json', '.toml', '.ini'], 'max_results': 15},\n                expected_outcome=\"Understand system configuration and deployment patterns\"\n            )\n\n        # API analysis\n        if \"api\" in self.state.goal.lower():\n            return ReActAction(\n                action_type=ActionType.SEARCH_FILES,\n                description=\"Search for API-related files and patterns\",\n                parameters={'pattern': 'api', 'file_types': ['.py', '.js', '.java', '.go'], 'max_results': 20},\n                expected_outcome=\"Understand API architecture and endpoints\"\n            )\n\n        # Service discovery\n        if \"service\" in self.state.goal.lower() or \"microservice\" in self.state.goal.lower():\n            return ReActAction(\n                action_type=ActionType.SEARCH_FILES,\n                description=\"Search for service-related patterns\",\n                parameters={'pattern': 'service', 'file_types': ['.py', '.js', '.java', '.go'], 'max_results': 20},\n                expected_outcome=\"Identify services and service boundaries\"\n            )\n\n        # Database analysis\n        if \"database\" in self.state.goal.lower() or \"data\" in self.state.goal.lower():\n            return ReActAction(\n                action_type=ActionType.SEARCH_FILES,\n                description=\"Search for database and data access patterns\",\n                parameters={'pattern': 'model', 'file_types': ['.py', '.js', '.java', '.go'], 'max_results': 20},\n                expected_outcome=\"Understand data models and database architecture\"\n            )\n\n        # Read important architectural files\n        if self.components and iteration &lt;= 12:\n            # Look for architecture documentation\n            return ReActAction(\n                action_type=ActionType.SEARCH_FILES,\n                description=\"Search for architecture documentation\",\n                parameters={'pattern': 'architecture', 'file_types': ['.md', '.txt', '.rst'], 'max_results': 5},\n                expected_outcome=\"Find architectural documentation and design decisions\"\n            )\n\n        # Analyze specific component files\n        if self.components and iteration &lt;= 15:\n            component_files = []\n            for component in self.components:\n                component_files.extend(component.files)\n\n            if component_files:\n                return ReActAction(\n                    action_type=ActionType.READ_FILE,\n                    description=f\"Read component file: {component_files[0]}\",\n                    parameters={'file_path': component_files[0], 'max_lines': 200},\n                    expected_outcome=\"Understand component implementation and patterns\"\n                )\n\n        # Use LLM for synthesis\n        return ReActAction(\n            action_type=ActionType.LLM_REASONING,\n            description=\"Use LLM to synthesize architectural insights\",\n            parameters={\n                'context': f\"Components: {len(self.components)}, Patterns: {len(self.patterns)}, Goal: {self.state.goal}\",\n                'question': \"What architectural insights can be derived from the current analysis?\"\n            },\n            expected_outcome=\"Generate architectural insights and recommendations\"\n        )\n\n    def observe(self, observation):\n        \"\"\"\n        Enhanced observation phase for architectural analysis.\n\n        Args:\n            observation: Observation from the action\n        \"\"\"\n        super().observe(observation)\n\n        # Process architecture-specific observations\n        if observation.success and observation.result:\n            result = observation.result\n\n            # If we scanned a directory, analyze structure\n            if isinstance(result, dict) and 'contents' in result:\n                self._analyze_directory_structure(result['contents'])\n\n            # If we listed files, identify component files\n            elif isinstance(result, dict) and 'files' in result:\n                self._identify_component_files(result['files'])\n\n            # If we searched files, analyze patterns\n            elif isinstance(result, dict) and 'results' in result:\n                self._analyze_search_results(result['results'])\n\n            # If we read a file, analyze its architectural significance\n            elif isinstance(result, dict) and 'content' in result:\n                self._analyze_file_content(result['file_path'], result['content'])\n\n    def _analyze_directory_structure(self, contents: List[Dict[str, Any]]):\n        \"\"\"Analyze directory structure for architectural patterns.\"\"\"\n        directories = [item for item in contents if item['is_directory']]\n\n        # Identify architectural layers\n        for directory in directories:\n            path = directory['path']\n            layer_type = self._identify_layer_type(path)\n\n            if layer_type:\n                self.architectural_layers[path] = layer_type\n                self.logger.info(f\"\ud83c\udfd7\ufe0f Identified layer: {path} -&gt; {layer_type}\")\n\n        # Identify components from directory structure\n        for directory in directories:\n            path = directory['path']\n            component_type = self._identify_component_type(path)\n\n            if component_type:\n                component = SystemComponent(\n                    name=Path(path).name,\n                    type=component_type,\n                    description=f\"{component_type.title()} component\",\n                    responsibilities=[f\"Handle {component_type} operations\"],\n                    files=[path]\n                )\n                self.components.append(component)\n                self.logger.info(f\"\ud83c\udfd7\ufe0f Identified component: {path} -&gt; {component_type}\")\n\n    def _identify_layer_type(self, path: str) -&gt; Optional[str]:\n        \"\"\"Identify architectural layer type from directory path.\"\"\"\n        path_lower = path.lower()\n\n        layer_patterns = {\n            'presentation': ['ui', 'view', 'frontend', 'client', 'web', 'gui'],\n            'business': ['business', 'service', 'logic', 'core', 'domain'],\n            'data': ['data', 'dal', 'repository', 'storage', 'database', 'db'],\n            'infrastructure': ['infrastructure', 'infra', 'external', 'adapters'],\n            'api': ['api', 'rest', 'graphql', 'endpoint', 'routes'],\n            'test': ['test', 'tests', 'testing', 'spec', 'e2e'],\n            'config': ['config', 'configuration', 'settings', 'env']\n        }\n\n        for layer_type, patterns in layer_patterns.items():\n            if any(pattern in path_lower for pattern in patterns):\n                return layer_type\n\n        return None\n\n    def _identify_component_type(self, path: str) -&gt; Optional[str]:\n        \"\"\"Identify component type from path.\"\"\"\n        path_lower = path.lower()\n\n        for component_type, patterns in self.component_patterns.items():\n            if any(pattern in path_lower for pattern in patterns):\n                return component_type\n\n        return None\n\n    def _identify_component_files(self, files: List[Dict[str, Any]]):\n        \"\"\"Identify component files from file list.\"\"\"\n        for file_info in files:\n            file_path = file_info['path']\n            component_type = self._identify_component_type(file_path)\n\n            if component_type:\n                # Check if component already exists\n                existing_component = None\n                for component in self.components:\n                    if component.type == component_type:\n                        existing_component = component\n                        break\n\n                if existing_component:\n                    existing_component.files.append(file_path)\n                else:\n                    component = SystemComponent(\n                        name=f\"{component_type}_component\",\n                        type=component_type,\n                        description=f\"{component_type.title()} component\",\n                        responsibilities=[f\"Handle {component_type} operations\"],\n                        files=[file_path]\n                    )\n                    self.components.append(component)\n                    self.logger.info(f\"\ud83c\udfd7\ufe0f Identified component file: {file_path} -&gt; {component_type}\")\n\n    def _analyze_search_results(self, results: List[Dict[str, Any]]):\n        \"\"\"Analyze search results for architectural patterns.\"\"\"\n        for result in results:\n            file_path = result['file_path']\n            matches = result.get('matches', [])\n\n            # Analyze matches for architectural patterns\n            for match in matches:\n                content = match.get('content', '')\n                self._detect_patterns_in_content(file_path, content)\n\n    def _analyze_file_content(self, file_path: str, content: str):\n        \"\"\"Analyze file content for architectural insights.\"\"\"\n        # Detect architectural patterns in the content\n        self._detect_patterns_in_content(file_path, content)\n\n        # Analyze imports and dependencies\n        self._analyze_dependencies(file_path, content)\n\n        # Analyze data flows\n        self._analyze_data_flows(file_path, content)\n\n    def _detect_patterns_in_content(self, file_path: str, content: str):\n        \"\"\"Detect architectural patterns in content.\"\"\"\n        # Run all pattern detectors\n        for pattern_name, detector in self.pattern_detectors.items():\n            if detector(content):\n                pattern = ArchitecturalPattern(\n                    pattern_name=pattern_name,\n                    description=f\"{pattern_name.title()} pattern detected\",\n                    components=[file_path],\n                    evidence=[f\"Found in {file_path}\"],\n                    confidence=0.7\n                )\n                self.patterns.append(pattern)\n                self.logger.info(f\"\ud83d\udd0d Detected pattern: {pattern_name} in {file_path}\")\n\n    def _analyze_dependencies(self, file_path: str, content: str):\n        \"\"\"Analyze dependencies and relationships.\"\"\"\n        # Extract import statements\n        imports = re.findall(r'import\\s+(\\w+)|from\\s+(\\w+)', content)\n\n        # Update component dependencies\n        for component in self.components:\n            if file_path in component.files:\n                for import_match in imports:\n                    imported_module = import_match[0] or import_match[1]\n                    if imported_module and imported_module not in component.dependencies:\n                        component.dependencies.append(imported_module)\n\n    def _analyze_data_flows(self, file_path: str, content: str):\n        \"\"\"Analyze data flows in the content.\"\"\"\n        # Look for HTTP requests/responses\n        if 'request' in content.lower() and 'response' in content.lower():\n            data_flow = DataFlow(\n                source=file_path,\n                target=\"external_api\",\n                flow_type=\"request\",\n                description=\"HTTP request/response flow\",\n                protocols=[\"HTTP\"]\n            )\n            self.data_flows.append(data_flow)\n\n        # Look for database operations\n        if any(keyword in content.lower() for keyword in ['select', 'insert', 'update', 'delete']):\n            data_flow = DataFlow(\n                source=file_path,\n                target=\"database\",\n                flow_type=\"data\",\n                description=\"Database operation flow\",\n                protocols=[\"SQL\"]\n            )\n            self.data_flows.append(data_flow)\n\n    # Pattern detection methods\n    def _detect_mvc_pattern(self, content: str) -&gt; bool:\n        \"\"\"Detect MVC pattern.\"\"\"\n        mvc_keywords = ['model', 'view', 'controller']\n        return sum(1 for keyword in mvc_keywords if keyword in content.lower()) &gt;= 2\n\n    def _detect_microservices_pattern(self, content: str) -&gt; bool:\n        \"\"\"Detect microservices pattern.\"\"\"\n        microservice_keywords = ['service', 'api', 'endpoint', 'docker', 'kubernetes']\n        return sum(1 for keyword in microservice_keywords if keyword in content.lower()) &gt;= 2\n\n    def _detect_layered_pattern(self, content: str) -&gt; bool:\n        \"\"\"Detect layered architecture pattern.\"\"\"\n        layer_keywords = ['layer', 'tier', 'business', 'presentation', 'data']\n        return sum(1 for keyword in layer_keywords if keyword in content.lower()) &gt;= 2\n\n    def _detect_repository_pattern(self, content: str) -&gt; bool:\n        \"\"\"Detect repository pattern.\"\"\"\n        repo_keywords = ['repository', 'repo', 'dao', 'data access']\n        return any(keyword in content.lower() for keyword in repo_keywords)\n\n    def _detect_factory_pattern(self, content: str) -&gt; bool:\n        \"\"\"Detect factory pattern.\"\"\"\n        factory_keywords = ['factory', 'create', 'builder']\n        return any(keyword in content.lower() for keyword in factory_keywords) and 'class' in content.lower()\n\n    def _detect_observer_pattern(self, content: str) -&gt; bool:\n        \"\"\"Detect observer pattern.\"\"\"\n        observer_keywords = ['observer', 'notify', 'subscribe', 'event']\n        return sum(1 for keyword in observer_keywords if keyword in content.lower()) &gt;= 2\n\n    def _detect_singleton_pattern(self, content: str) -&gt; bool:\n        \"\"\"Detect singleton pattern.\"\"\"\n        return '__new__' in content and 'instance' in content.lower()\n\n    def _detect_adapter_pattern(self, content: str) -&gt; bool:\n        \"\"\"Detect adapter pattern.\"\"\"\n        adapter_keywords = ['adapter', 'wrapper', 'adapt']\n        return any(keyword in content.lower() for keyword in adapter_keywords)\n\n    def _detect_decorator_pattern(self, content: str) -&gt; bool:\n        \"\"\"Detect decorator pattern.\"\"\"\n        return '@' in content or 'decorator' in content.lower()\n\n    def _detect_strategy_pattern(self, content: str) -&gt; bool:\n        \"\"\"Detect strategy pattern.\"\"\"\n        strategy_keywords = ['strategy', 'algorithm', 'policy']\n        return any(keyword in content.lower() for keyword in strategy_keywords)\n\n    def _generate_summary(self) -&gt; str:\n        \"\"\"Generate a comprehensive summary of architecture analysis.\"\"\"\n        summary = f\"Architecture Analysis Summary:\\\\n\"\n        summary += f\"\u2022 Identified {len(self.components)} system components\\\\n\"\n        summary += f\"\u2022 Detected {len(self.patterns)} architectural patterns\\\\n\"\n        summary += f\"\u2022 Mapped {len(self.data_flows)} data flows\\\\n\"\n        summary += f\"\u2022 Found {len(self.architectural_layers)} architectural layers\\\\n\"\n\n        # Component types\n        if self.components:\n            component_types = defaultdict(int)\n            for component in self.components:\n                component_types[component.type] += 1\n\n            comp_summary = ', '.join(f'{ctype}({count})' for ctype, count in component_types.items())\n            summary += f\"\u2022 Component types: {comp_summary}\\\\n\"\n\n        # Pattern types\n        if self.patterns:\n            pattern_names = [pattern.pattern_name for pattern in self.patterns]\n            summary += f\"\u2022 Patterns found: {', '.join(set(pattern_names))}\\\\n\"\n\n        # Architectural layers\n        if self.architectural_layers:\n            layer_types = list(set(self.architectural_layers.values()))\n            summary += f\"\u2022 Architectural layers: {', '.join(layer_types)}\\\\n\"\n\n        # Cache performance\n        if self.state.cache_hits &gt; 0:\n            summary += f\"\u2022 Cache hits: {self.state.cache_hits}\\\\n\"\n\n        if self.state.error_count &gt; 0:\n            summary += f\"\u2022 Errors encountered: {self.state.error_count}\\\\n\"\n\n        return summary\n\n    def get_components(self) -&gt; List[SystemComponent]:\n        \"\"\"Get all identified system components.\"\"\"\n        return self.components\n\n    def get_patterns(self) -&gt; List[ArchitecturalPattern]:\n        \"\"\"Get all detected architectural patterns.\"\"\"\n        return self.patterns\n\n    def get_data_flows(self) -&gt; List[DataFlow]:\n        \"\"\"Get all mapped data flows.\"\"\"\n        return self.data_flows\n\n    def get_architectural_layers(self) -&gt; Dict[str, str]:\n        \"\"\"Get all identified architectural layers.\"\"\"\n        return self.architectural_layers\n</code></pre> <p>The Architecture Agent specializes in analyzing system design and architectural patterns using the ReAct pattern.</p>"},{"location":"api/architecture-agent/#cf.agents.react_architecture_agent.ReActArchitectureAgent.get_architectural_layers","title":"<code>get_architectural_layers()</code>","text":"<p>Get all identified architectural layers.</p> Source code in <code>cf/agents/react_architecture_agent.py</code> <pre><code>def get_architectural_layers(self) -&gt; Dict[str, str]:\n    \"\"\"Get all identified architectural layers.\"\"\"\n    return self.architectural_layers\n</code></pre>"},{"location":"api/architecture-agent/#cf.agents.react_architecture_agent.ReActArchitectureAgent.get_components","title":"<code>get_components()</code>","text":"<p>Get all identified system components.</p> Source code in <code>cf/agents/react_architecture_agent.py</code> <pre><code>def get_components(self) -&gt; List[SystemComponent]:\n    \"\"\"Get all identified system components.\"\"\"\n    return self.components\n</code></pre>"},{"location":"api/architecture-agent/#cf.agents.react_architecture_agent.ReActArchitectureAgent.get_data_flows","title":"<code>get_data_flows()</code>","text":"<p>Get all mapped data flows.</p> Source code in <code>cf/agents/react_architecture_agent.py</code> <pre><code>def get_data_flows(self) -&gt; List[DataFlow]:\n    \"\"\"Get all mapped data flows.\"\"\"\n    return self.data_flows\n</code></pre>"},{"location":"api/architecture-agent/#cf.agents.react_architecture_agent.ReActArchitectureAgent.get_patterns","title":"<code>get_patterns()</code>","text":"<p>Get all detected architectural patterns.</p> Source code in <code>cf/agents/react_architecture_agent.py</code> <pre><code>def get_patterns(self) -&gt; List[ArchitecturalPattern]:\n    \"\"\"Get all detected architectural patterns.\"\"\"\n    return self.patterns\n</code></pre>"},{"location":"api/architecture-agent/#cf.agents.react_architecture_agent.ReActArchitectureAgent.map_architecture","title":"<code>map_architecture(description)</code>","text":"<p>Main entry point for architecture mapping using ReAct pattern.</p> <p>Parameters:</p> Name Type Description Default <code>description</code> <code>str</code> <p>Description of what to focus on during analysis</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Comprehensive architectural analysis results</p> Source code in <code>cf/agents/react_architecture_agent.py</code> <pre><code>def map_architecture(self, description: str) -&gt; Dict[str, Any]:\n    \"\"\"\n    Main entry point for architecture mapping using ReAct pattern.\n\n    Args:\n        description: Description of what to focus on during analysis\n\n    Returns:\n        Comprehensive architectural analysis results\n    \"\"\"\n    goal = f\"Map architecture for: {description}\"\n    return self.execute_react_loop(goal, max_iterations=18)\n</code></pre>"},{"location":"api/architecture-agent/#cf.agents.react_architecture_agent.ReActArchitectureAgent.observe","title":"<code>observe(observation)</code>","text":"<p>Enhanced observation phase for architectural analysis.</p> <p>Parameters:</p> Name Type Description Default <code>observation</code> <p>Observation from the action</p> required Source code in <code>cf/agents/react_architecture_agent.py</code> <pre><code>def observe(self, observation):\n    \"\"\"\n    Enhanced observation phase for architectural analysis.\n\n    Args:\n        observation: Observation from the action\n    \"\"\"\n    super().observe(observation)\n\n    # Process architecture-specific observations\n    if observation.success and observation.result:\n        result = observation.result\n\n        # If we scanned a directory, analyze structure\n        if isinstance(result, dict) and 'contents' in result:\n            self._analyze_directory_structure(result['contents'])\n\n        # If we listed files, identify component files\n        elif isinstance(result, dict) and 'files' in result:\n            self._identify_component_files(result['files'])\n\n        # If we searched files, analyze patterns\n        elif isinstance(result, dict) and 'results' in result:\n            self._analyze_search_results(result['results'])\n\n        # If we read a file, analyze its architectural significance\n        elif isinstance(result, dict) and 'content' in result:\n            self._analyze_file_content(result['file_path'], result['content'])\n</code></pre>"},{"location":"api/architecture-agent/#cf.agents.react_architecture_agent.ReActArchitectureAgent.plan_action","title":"<code>plan_action(reasoning)</code>","text":"<p>Plan the next action based on reasoning.</p> <p>Parameters:</p> Name Type Description Default <code>reasoning</code> <code>str</code> <p>The reasoning output</p> required <p>Returns:</p> Type Description <code>ReActAction</code> <p>Action to take</p> Source code in <code>cf/agents/react_architecture_agent.py</code> <pre><code>def plan_action(self, reasoning: str) -&gt; ReActAction:\n    \"\"\"\n    Plan the next action based on reasoning.\n\n    Args:\n        reasoning: The reasoning output\n\n    Returns:\n        Action to take\n    \"\"\"\n    iteration = self.state.iteration\n\n    # Early iterations: Structure analysis\n    if iteration &lt;= 2:\n        return ReActAction(\n            action_type=ActionType.SCAN_DIRECTORY,\n            description=\"Scan repository structure for architectural analysis\",\n            parameters={'directory': '.', 'max_depth': 4},\n            expected_outcome=\"Understand overall system structure and identify main components\"\n        )\n\n    # Component discovery phase\n    if not self.components and iteration &lt;= 5:\n        return ReActAction(\n            action_type=ActionType.LIST_FILES,\n            description=\"List files to identify architectural components\",\n            parameters={'pattern': '*', 'directory': '.'},\n            expected_outcome=\"Identify files that represent different architectural components\"\n        )\n\n    # Analyze main application files\n    if iteration &lt;= 6:\n        return ReActAction(\n            action_type=ActionType.SEARCH_FILES,\n            description=\"Search for main application entry points\",\n            parameters={'pattern': 'main', 'file_types': ['.py', '.js', '.java', '.go'], 'max_results': 10},\n            expected_outcome=\"Find main application files and understand entry points\"\n        )\n\n    # Configuration analysis\n    if iteration &lt;= 8:\n        return ReActAction(\n            action_type=ActionType.SEARCH_FILES,\n            description=\"Search for configuration files\",\n            parameters={'pattern': 'config', 'file_types': ['.yaml', '.yml', '.json', '.toml', '.ini'], 'max_results': 15},\n            expected_outcome=\"Understand system configuration and deployment patterns\"\n        )\n\n    # API analysis\n    if \"api\" in self.state.goal.lower():\n        return ReActAction(\n            action_type=ActionType.SEARCH_FILES,\n            description=\"Search for API-related files and patterns\",\n            parameters={'pattern': 'api', 'file_types': ['.py', '.js', '.java', '.go'], 'max_results': 20},\n            expected_outcome=\"Understand API architecture and endpoints\"\n        )\n\n    # Service discovery\n    if \"service\" in self.state.goal.lower() or \"microservice\" in self.state.goal.lower():\n        return ReActAction(\n            action_type=ActionType.SEARCH_FILES,\n            description=\"Search for service-related patterns\",\n            parameters={'pattern': 'service', 'file_types': ['.py', '.js', '.java', '.go'], 'max_results': 20},\n            expected_outcome=\"Identify services and service boundaries\"\n        )\n\n    # Database analysis\n    if \"database\" in self.state.goal.lower() or \"data\" in self.state.goal.lower():\n        return ReActAction(\n            action_type=ActionType.SEARCH_FILES,\n            description=\"Search for database and data access patterns\",\n            parameters={'pattern': 'model', 'file_types': ['.py', '.js', '.java', '.go'], 'max_results': 20},\n            expected_outcome=\"Understand data models and database architecture\"\n        )\n\n    # Read important architectural files\n    if self.components and iteration &lt;= 12:\n        # Look for architecture documentation\n        return ReActAction(\n            action_type=ActionType.SEARCH_FILES,\n            description=\"Search for architecture documentation\",\n            parameters={'pattern': 'architecture', 'file_types': ['.md', '.txt', '.rst'], 'max_results': 5},\n            expected_outcome=\"Find architectural documentation and design decisions\"\n        )\n\n    # Analyze specific component files\n    if self.components and iteration &lt;= 15:\n        component_files = []\n        for component in self.components:\n            component_files.extend(component.files)\n\n        if component_files:\n            return ReActAction(\n                action_type=ActionType.READ_FILE,\n                description=f\"Read component file: {component_files[0]}\",\n                parameters={'file_path': component_files[0], 'max_lines': 200},\n                expected_outcome=\"Understand component implementation and patterns\"\n            )\n\n    # Use LLM for synthesis\n    return ReActAction(\n        action_type=ActionType.LLM_REASONING,\n        description=\"Use LLM to synthesize architectural insights\",\n        parameters={\n            'context': f\"Components: {len(self.components)}, Patterns: {len(self.patterns)}, Goal: {self.state.goal}\",\n            'question': \"What architectural insights can be derived from the current analysis?\"\n        },\n        expected_outcome=\"Generate architectural insights and recommendations\"\n    )\n</code></pre>"},{"location":"api/architecture-agent/#cf.agents.react_architecture_agent.ReActArchitectureAgent.reason","title":"<code>reason()</code>","text":"<p>Reasoning phase: Determine what architectural analysis action to take next.</p> <p>Returns:</p> Type Description <code>str</code> <p>Reasoning about next action to take</p> Source code in <code>cf/agents/react_architecture_agent.py</code> <pre><code>def reason(self) -&gt; str:\n    \"\"\"\n    Reasoning phase: Determine what architectural analysis action to take next.\n\n    Returns:\n        Reasoning about next action to take\n    \"\"\"\n    current_context = self.state.current_context\n    iteration = self.state.iteration\n\n    # First iteration: Start with high-level structure analysis\n    if iteration == 1:\n        return \"I should start by understanding the overall repository structure to identify architectural layers and major components.\"\n\n    # Early iterations: Focus on component discovery\n    if iteration &lt;= 3 and not self.components:\n        return \"I need to identify system components by scanning the directory structure and looking for architectural patterns.\"\n\n    # If we have some components but need more context\n    if self.components and len(self.components) &lt; 3:\n        return f\"I found {len(self.components)} components but need to discover more. Let me analyze code files to understand the system better.\"\n\n    # Focus on understanding relationships and data flows\n    if self.components and not self.data_flows:\n        return \"I have identified components. Now I should analyze how they interact and what data flows between them.\"\n\n    # Pattern detection phase\n    if len(self.components) &gt;= 3 and not self.patterns:\n        return \"I have good component coverage. Now I should detect architectural patterns and design principles used in the system.\"\n\n    # Goal-specific analysis\n    if \"microservice\" in self.state.goal.lower():\n        return \"The goal mentions microservices. I should look for service boundaries, communication patterns, and deployment structures.\"\n    elif \"api\" in self.state.goal.lower():\n        return \"The goal mentions API. I should analyze API design, endpoints, and how the API layer is structured.\"\n    elif \"database\" in self.state.goal.lower():\n        return \"The goal mentions database. I should analyze data models, database access patterns, and data architecture.\"\n    elif \"security\" in self.state.goal.lower():\n        return \"The goal mentions security. I should analyze authentication, authorization, and security patterns.\"\n\n    # Deep analysis phase\n    if len(self.components) &gt;= 3 and self.patterns:\n        return \"I have good understanding of components and patterns. Now I should analyze quality attributes and architectural decisions.\"\n\n    # Default reasoning\n    return \"I should continue analyzing the architecture systematically, focusing on understanding the system design and its implications.\"\n</code></pre>"},{"location":"api/architecture-agent/#overview","title":"Overview","text":"<p>The Architecture Agent excels at:</p> <ul> <li>System component identification</li> <li>Architectural pattern detection</li> <li>Data flow mapping</li> <li>Layer analysis</li> <li>Design pattern recognition</li> </ul>"},{"location":"api/architecture-agent/#usage-examples","title":"Usage Examples","text":""},{"location":"api/architecture-agent/#basic-architecture-analysis","title":"Basic Architecture Analysis","text":"<pre><code>from cf.agents.react_architecture_agent import ReActArchitectureAgent\nfrom cf.aci.repo import LocalCodeRepo\nfrom cf.config import CfConfig\n\n# Initialize agent\nrepo = LocalCodeRepo(\"/path/to/repository\")\nconfig = CfConfig()\narch_agent = ReActArchitectureAgent(repo, config)\n\n# Analyze architecture\nresults = arch_agent.map_architecture(\"system architecture and design patterns\")\n\nprint(f\"Components identified: {len(results.get('components', {}))}\")\nprint(f\"Patterns detected: {len(results.get('patterns', []))}\")\nprint(f\"Layers found: {len(results.get('layers', {}))}\")\n</code></pre>"},{"location":"api/architecture-agent/#component-analysis","title":"Component Analysis","text":"<pre><code># Get system components\ncomponents = arch_agent.get_system_components()\n\nfor component_type, component_list in components.items():\n    print(f\"{component_type.title()} Components: {len(component_list)}\")\n    for component in component_list[:3]:  # Show first 3\n        print(f\"  - {component.name} ({component.component_type})\")\n</code></pre>"},{"location":"api/architecture-agent/#pattern-detection","title":"Pattern Detection","text":"<pre><code># Get architectural patterns\npatterns = arch_agent.get_architectural_patterns()\n\nfor pattern in patterns:\n    print(f\"Pattern: {pattern.pattern_type}\")\n    print(f\"Description: {pattern.description}\")\n    print(f\"Confidence: {pattern.confidence}\")\n    print(f\"Occurrences: {pattern.occurrences}\")\n</code></pre> <p>For complete API documentation, see the source code.</p>"},{"location":"api/codebase-agent/","title":"Codebase Agent","text":"<p>               Bases: <code>ReActAgent</code></p> <p>Codebase agent that uses ReAct pattern for systematic code analysis.</p> <p>ReAct Loop: 1. Reason: Analyze what code to explore next 2. Act: Use tools to scan, read, search, or analyze code 3. Observe: Reflect on findings and plan next steps</p> Source code in <code>cf/agents/react_codebase_agent.py</code> <pre><code>class ReActCodebaseAgent(ReActAgent):\n    \"\"\"\n    Codebase agent that uses ReAct pattern for systematic code analysis.\n\n    ReAct Loop:\n    1. Reason: Analyze what code to explore next\n    2. Act: Use tools to scan, read, search, or analyze code\n    3. Observe: Reflect on findings and plan next steps\n    \"\"\"\n\n    def __init__(self, repo: CodeRepo, config: CfConfig):\n        super().__init__(repo, config, \"CodebaseAgent\")\n\n        # Language-specific analyzers\n        self.language_analyzers = {\n            'python': self._analyze_python_code,\n            'javascript': self._analyze_javascript_code,\n            'typescript': self._analyze_javascript_code,  # Use JS analyzer for TS\n        }\n\n        # Code analysis state\n        self.code_files = []\n        self.analyzed_files = {}\n        self.code_entities = {}\n        self.code_patterns = []\n        self.dependency_graph = {}\n        self.language_stats = defaultdict(int)\n\n        # Pattern detection\n        self.pattern_detectors = {\n            'design_patterns': self._detect_design_patterns,\n            'naming_conventions': self._detect_naming_conventions,\n            'architectural_patterns': self._detect_architectural_patterns,\n            'code_smells': self._detect_code_smells\n        }\n\n    def analyze_codebase(self, description: str) -&gt; Dict[str, Any]:\n        \"\"\"\n        Main entry point for codebase analysis using ReAct pattern.\n\n        Args:\n            description: Description of what to focus on during analysis\n\n        Returns:\n            Comprehensive codebase analysis results\n        \"\"\"\n        goal = f\"Analyze codebase for: {description}\"\n        return self.execute_react_loop(goal, max_iterations=20)\n\n    def reason(self) -&gt; str:\n        \"\"\"\n        Reasoning phase: Determine what code analysis action to take next.\n\n        Returns:\n            Reasoning about next action to take\n        \"\"\"\n        current_context = self.state.current_context\n        iteration = self.state.iteration\n\n        # First iteration: Start with directory scan to understand structure\n        if iteration == 1:\n            return \"I should start by scanning the repository structure to understand the codebase layout and identify source code files.\"\n\n        # Early iterations: Focus on discovery\n        if iteration &lt;= 3 and not self.code_files:\n            return \"I need to identify source code files by scanning directories and looking for common programming language extensions.\"\n\n        # If we have code files but haven't analyzed them yet\n        if self.code_files and not self.analyzed_files:\n            return f\"I found {len(self.code_files)} code files. Now I should analyze the most important ones to understand the codebase structure.\"\n\n        # If we have some analysis but need more depth\n        if self.analyzed_files and len(self.analyzed_files) &lt; 5:\n            return \"I've analyzed some files but need to dive deeper. Let me examine more files and look for patterns and dependencies.\"\n\n        # Focus on specific goal-related analysis\n        if \"api\" in self.state.goal.lower():\n            return \"The goal mentions API. I should search for API-related patterns, endpoints, and routing code.\"\n        elif \"database\" in self.state.goal.lower():\n            return \"The goal mentions database. I should search for database models, queries, and data access patterns.\"\n        elif \"test\" in self.state.goal.lower():\n            return \"The goal mentions testing. I should search for test files and testing patterns.\"\n        elif \"config\" in self.state.goal.lower():\n            return \"The goal mentions configuration. I should search for configuration files and settings.\"\n\n        # If we have good coverage, focus on patterns and relationships\n        if len(self.analyzed_files) &gt;= 5:\n            return \"I have analyzed multiple files. Now I should look for patterns, dependencies, and architectural insights.\"\n\n        # Default reasoning\n        return \"I should continue analyzing the codebase systematically, focusing on files that are most relevant to the goal.\"\n\n    def plan_action(self, reasoning: str) -&gt; ReActAction:\n        \"\"\"\n        Plan the next action based on reasoning.\n\n        Args:\n            reasoning: The reasoning output\n\n        Returns:\n            Action to take\n        \"\"\"\n        iteration = self.state.iteration\n\n        # Early iterations: Directory scanning and file discovery\n        if iteration &lt;= 2:\n            return ReActAction(\n                action_type=ActionType.SCAN_DIRECTORY,\n                description=\"Scan repository for source code files\",\n                parameters={'directory': '.', 'max_depth': 3},\n                expected_outcome=\"Understand repository structure and find source code\"\n            )\n\n        # Find source code files if not found yet\n        if not self.code_files and iteration &lt;= 4:\n            return ReActAction(\n                action_type=ActionType.LIST_FILES,\n                description=\"List source code files\",\n                parameters={'pattern': '.py', 'directory': '.'},\n                expected_outcome=\"Identify Python source files\"\n            )\n\n        # Analyze high-priority source files\n        if self.code_files and len(self.analyzed_files) &lt; 5:\n            # Prioritize main files, __init__.py, and files with 'main' in name\n            priority_files = [f for f in self.code_files if 'main' in f.lower() or '__init__' in f.lower()]\n            if priority_files:\n                file_to_analyze = priority_files[0]\n            else:\n                file_to_analyze = self.code_files[0]\n\n            return ReActAction(\n                action_type=ActionType.READ_FILE,\n                description=f\"Read and analyze source file: {file_to_analyze}\",\n                parameters={'file_path': file_to_analyze, 'max_lines': 500},\n                expected_outcome=\"Understand code structure and extract entities\"\n            )\n\n        # Goal-specific searches\n        if \"api\" in self.state.goal.lower():\n            return ReActAction(\n                action_type=ActionType.SEARCH_FILES,\n                description=\"Search for API-related code patterns\",\n                parameters={'pattern': 'api', 'file_types': ['.py', '.js', '.ts'], 'max_results': 20},\n                expected_outcome=\"Find API endpoints, routes, and handlers\"\n            )\n\n        elif \"class\" in self.state.goal.lower():\n            return ReActAction(\n                action_type=ActionType.SEARCH_FILES,\n                description=\"Search for class definitions\",\n                parameters={'pattern': 'class ', 'file_types': ['.py', '.js', '.ts', '.java'], 'max_results': 20},\n                expected_outcome=\"Find class definitions and OOP patterns\"\n            )\n\n        elif \"function\" in self.state.goal.lower():\n            return ReActAction(\n                action_type=ActionType.SEARCH_FILES,\n                description=\"Search for function definitions\",\n                parameters={'pattern': 'def ', 'file_types': ['.py'], 'max_results': 20},\n                expected_outcome=\"Find function definitions and analyze structure\"\n            )\n\n        elif \"import\" in self.state.goal.lower() or \"dependency\" in self.state.goal.lower():\n            return ReActAction(\n                action_type=ActionType.SEARCH_FILES,\n                description=\"Search for import statements\",\n                parameters={'pattern': 'import ', 'file_types': ['.py', '.js', '.ts'], 'max_results': 30},\n                expected_outcome=\"Understand dependencies and module structure\"\n            )\n\n        # Analyze specific files for patterns\n        if self.analyzed_files:\n            return ReActAction(\n                action_type=ActionType.ANALYZE_CODE,\n                description=\"Analyze code patterns and complexity\",\n                parameters={'file_path': list(self.analyzed_files.keys())[0], 'analysis_type': 'patterns'},\n                expected_outcome=\"Extract code patterns and complexity metrics\"\n            )\n\n        # Default: Use LLM reasoning\n        return ReActAction(\n            action_type=ActionType.LLM_REASONING,\n            description=\"Use LLM to determine next code analysis step\",\n            parameters={\n                'context': str(self.state.current_context),\n                'question': f\"What should I analyze next for: {self.state.goal}?\"\n            },\n            expected_outcome=\"Get guidance on next analysis step\"\n        )\n\n    def observe(self, observation):\n        \"\"\"\n        Enhanced observation phase for codebase analysis.\n\n        Args:\n            observation: Observation from the action\n        \"\"\"\n        super().observe(observation)\n\n        # Process code-specific observations\n        if observation.success and observation.result:\n            result = observation.result\n\n            # If we scanned a directory, extract source code files\n            if isinstance(result, dict) and 'contents' in result:\n                for item in result['contents']:\n                    if not item['is_directory'] and self._is_source_code_file(item['path']):\n                        if item['path'] not in self.code_files:\n                            self.code_files.append(item['path'])\n                            self.language_stats[self._detect_language(item['path'])] += 1\n                            self.logger.info(f\"\ud83d\udcbe Found source file: {item['path']}\")\n\n            # If we listed files, filter for source code\n            elif isinstance(result, dict) and 'files' in result:\n                for file_info in result['files']:\n                    if self._is_source_code_file(file_info['path']):\n                        if file_info['path'] not in self.code_files:\n                            self.code_files.append(file_info['path'])\n                            self.language_stats[self._detect_language(file_info['path'])] += 1\n                            self.logger.info(f\"\ud83d\udcbe Found source file: {file_info['path']}\")\n\n            # If we read a file, analyze its code content\n            elif isinstance(result, dict) and 'content' in result:\n                file_path = result['file_path']\n                content = result['content']\n\n                # Analyze the code content\n                analysis = self._analyze_code_content(file_path, content)\n                self.analyzed_files[file_path] = analysis\n\n                # Extract code entities\n                entities = self._extract_code_entities(file_path, content)\n                self.code_entities[file_path] = entities\n\n                # Detect patterns\n                patterns = self._detect_patterns_in_file(file_path, content)\n                self.code_patterns.extend(patterns)\n\n                self.logger.info(f\"\ud83d\udd0d Analyzed code file: {file_path}\")\n\n            # If we searched files, process the results\n            elif isinstance(result, dict) and 'results' in result:\n                for search_result in result['results']:\n                    file_path = search_result['file_path']\n                    matches = search_result.get('matches', [])\n\n                    # Process search matches\n                    if matches:\n                        self._process_search_matches(file_path, matches)\n                        self.logger.info(f\"\ud83d\udd0d Found {len(matches)} matches in {file_path}\")\n\n    def _is_source_code_file(self, file_path: str) -&gt; bool:\n        \"\"\"Check if a file is source code.\"\"\"\n        # Common source code extensions\n        source_extensions = [\n            '.py', '.js', '.ts', '.tsx', '.jsx',\n            '.java', '.c', '.cpp', '.cc', '.cxx',\n            '.h', '.hpp', '.go', '.rs', '.kt',\n            '.swift', '.php', '.rb', '.scala',\n            '.cs', '.vb', '.clj', '.hs', '.ml'\n        ]\n\n        return any(file_path.lower().endswith(ext) for ext in source_extensions)\n\n    def _analyze_code_content(self, file_path: str, content: str) -&gt; Dict[str, Any]:\n        \"\"\"Analyze code content and extract metrics.\"\"\"\n        lines = content.split('\\\\n')\n        non_empty_lines = [line for line in lines if line.strip()]\n\n        # Basic metrics\n        line_count = len(lines)\n        code_line_count = len(non_empty_lines)\n        comment_lines = len([line for line in lines if line.strip().startswith('#')])\n\n        # Language-specific analysis\n        language = self._detect_language(file_path)\n        language_analysis = {}\n\n        if language == 'python':\n            language_analysis = self._analyze_python_code(content)\n        elif language == 'javascript':\n            language_analysis = self._analyze_javascript_code(content)\n\n        # Complexity estimation\n        complexity = self._estimate_complexity(content, language)\n\n        return {\n            'file_path': file_path,\n            'language': language,\n            'line_count': line_count,\n            'code_line_count': code_line_count,\n            'comment_lines': comment_lines,\n            'complexity': complexity,\n            'language_analysis': language_analysis,\n            'has_classes': 'class ' in content,\n            'has_functions': 'def ' in content or 'function ' in content,\n            'has_imports': 'import ' in content or 'from ' in content,\n            'has_tests': 'test' in file_path.lower() or 'assert' in content\n        }\n\n    def _extract_code_entities(self, file_path: str, content: str) -&gt; List[CodeEntity]:\n        \"\"\"Extract code entities from file content.\"\"\"\n        entities = []\n        lines = content.split('\\\\n')\n\n        # Extract Python classes and functions\n        if file_path.endswith('.py'):\n            try:\n                tree = ast.parse(content)\n                for node in ast.walk(tree):\n                    if isinstance(node, ast.ClassDef):\n                        entities.append(CodeEntity(\n                            name=node.name,\n                            type='class',\n                            file_path=file_path,\n                            line_start=node.lineno,\n                            line_end=getattr(node, 'end_lineno', node.lineno),\n                            signature=f\"class {node.name}\",\n                            docstring=ast.get_docstring(node) or None\n                        ))\n                    elif isinstance(node, ast.FunctionDef):\n                        entities.append(CodeEntity(\n                            name=node.name,\n                            type='function',\n                            file_path=file_path,\n                            line_start=node.lineno,\n                            line_end=getattr(node, 'end_lineno', node.lineno),\n                            signature=f\"def {node.name}\",\n                            docstring=ast.get_docstring(node) or None\n                        ))\n            except SyntaxError:\n                # Fall back to regex-based extraction\n                entities.extend(self._extract_entities_with_regex(file_path, content))\n        else:\n            # Use regex for other languages\n            entities.extend(self._extract_entities_with_regex(file_path, content))\n\n        return entities\n\n    def _extract_entities_with_regex(self, file_path: str, content: str) -&gt; List[CodeEntity]:\n        \"\"\"Extract entities using regex patterns.\"\"\"\n        entities = []\n        lines = content.split('\\\\n')\n\n        # Python patterns\n        if file_path.endswith('.py'):\n            # Class definitions\n            for i, line in enumerate(lines):\n                if re.match(r'^class \\\\w+', line.strip()):\n                    class_name = re.search(r'class (\\\\w+)', line).group(1)\n                    entities.append(CodeEntity(\n                        name=class_name,\n                        type='class',\n                        file_path=file_path,\n                        line_start=i + 1,\n                        line_end=i + 1,\n                        signature=line.strip()\n                    ))\n\n                # Function definitions\n                elif re.match(r'^def \\\\w+', line.strip()):\n                    func_name = re.search(r'def (\\\\w+)', line).group(1)\n                    entities.append(CodeEntity(\n                        name=func_name,\n                        type='function',\n                        file_path=file_path,\n                        line_start=i + 1,\n                        line_end=i + 1,\n                        signature=line.strip()\n                    ))\n\n        return entities\n\n    def _detect_patterns_in_file(self, file_path: str, content: str) -&gt; List[CodePattern]:\n        \"\"\"Detect code patterns in a file.\"\"\"\n        patterns = []\n\n        # Detect design patterns\n        if 'class' in content and 'def __init__' in content:\n            patterns.append(CodePattern(\n                pattern_type='design_pattern',\n                description='Constructor pattern detected',\n                examples=[file_path],\n                confidence=0.8,\n                occurrences=1\n            ))\n\n        # Detect naming conventions\n        if re.search(r'def [a-z_]+[a-z0-9_]*\\\\(', content):\n            patterns.append(CodePattern(\n                pattern_type='naming_convention',\n                description='Snake case function naming',\n                examples=[file_path],\n                confidence=0.9,\n                occurrences=len(re.findall(r'def [a-z_]+[a-z0-9_]*\\\\(', content))\n            ))\n\n        # Detect architectural patterns\n        if 'api' in content.lower() and ('route' in content.lower() or 'endpoint' in content.lower()):\n            patterns.append(CodePattern(\n                pattern_type='architectural_pattern',\n                description='API/REST pattern detected',\n                examples=[file_path],\n                confidence=0.7,\n                occurrences=1\n            ))\n\n        return patterns\n\n    def _process_search_matches(self, file_path: str, matches: List[Dict[str, Any]]):\n        \"\"\"Process search matches and update context.\"\"\"\n        for match in matches:\n            line_content = match.get('content', '')\n            line_num = match.get('line_num', 0)\n\n            # Update context with interesting matches\n            if 'class ' in line_content:\n                self.state.current_context.setdefault('classes_found', []).append(\n                    {'file': file_path, 'line': line_num, 'content': line_content}\n                )\n            elif 'def ' in line_content:\n                self.state.current_context.setdefault('functions_found', []).append(\n                    {'file': file_path, 'line': line_num, 'content': line_content}\n                )\n            elif 'import ' in line_content:\n                self.state.current_context.setdefault('imports_found', []).append(\n                    {'file': file_path, 'line': line_num, 'content': line_content}\n                )\n\n    def _analyze_python_code(self, content: str) -&gt; Dict[str, Any]:\n        \"\"\"Analyze Python-specific code patterns.\"\"\"\n        analysis = {\n            'classes': len(re.findall(r'^class \\\\w+', content, re.MULTILINE)),\n            'functions': len(re.findall(r'^def \\\\w+', content, re.MULTILINE)),\n            'imports': len(re.findall(r'^import \\\\w+|^from \\\\w+', content, re.MULTILINE)),\n            'decorators': len(re.findall(r'^@\\\\w+', content, re.MULTILINE)),\n            'async_functions': len(re.findall(r'^async def \\\\w+', content, re.MULTILINE)),\n            'has_main': '__main__' in content,\n            'has_docstrings': '\\\"\\\"\\\"' in content or \"'''\" in content\n        }\n\n        return analysis\n\n    def _analyze_javascript_code(self, content: str) -&gt; Dict[str, Any]:\n        \"\"\"Analyze JavaScript-specific code patterns.\"\"\"\n        analysis = {\n            'functions': len(re.findall(r'function \\\\w+|\\\\w+\\\\s*=\\\\s*function', content)),\n            'arrow_functions': len(re.findall(r'=&gt;', content)),\n            'classes': len(re.findall(r'class \\\\w+', content)),\n            'imports': len(re.findall(r'import \\\\w+|require\\\\(', content)),\n            'exports': len(re.findall(r'export |module\\\\.exports', content)),\n            'async_functions': len(re.findall(r'async function|async \\\\w+', content)),\n            'promises': len(re.findall(r'\\\\.then\\\\(|\\\\.catch\\\\(', content))\n        }\n\n        return analysis\n\n    def _estimate_complexity(self, content: str, language: str) -&gt; int:\n        \"\"\"Estimate code complexity using simple heuristics.\"\"\"\n        # Count branching statements\n        if_statements = len(re.findall(r'\\\\bif\\\\b', content))\n        for_statements = len(re.findall(r'\\\\bfor\\\\b', content))\n        while_statements = len(re.findall(r'\\\\bwhile\\\\b', content))\n        try_statements = len(re.findall(r'\\\\btry\\\\b', content))\n\n        # Basic complexity calculation\n        complexity = 1 + if_statements + for_statements + while_statements + try_statements\n\n        return complexity\n\n    def _detect_design_patterns(self, content: str) -&gt; List[CodePattern]:\n        \"\"\"Detect design patterns in code.\"\"\"\n        patterns = []\n\n        # Singleton pattern\n        if 'class' in content and '__new__' in content:\n            patterns.append(CodePattern(\n                pattern_type='singleton',\n                description='Singleton pattern detected',\n                examples=[],\n                confidence=0.7,\n                occurrences=1\n            ))\n\n        # Factory pattern\n        if 'create' in content.lower() and 'class' in content:\n            patterns.append(CodePattern(\n                pattern_type='factory',\n                description='Factory pattern detected',\n                examples=[],\n                confidence=0.6,\n                occurrences=1\n            ))\n\n        return patterns\n\n    def _detect_naming_conventions(self, content: str) -&gt; List[CodePattern]:\n        \"\"\"Detect naming conventions in code.\"\"\"\n        patterns = []\n\n        # Check for consistent naming\n        snake_case_funcs = len(re.findall(r'def [a-z_]+[a-z0-9_]*\\\\(', content))\n        camel_case_funcs = len(re.findall(r'def [a-z][a-zA-Z0-9]*\\\\(', content))\n\n        if snake_case_funcs &gt; camel_case_funcs:\n            patterns.append(CodePattern(\n                pattern_type='naming_convention',\n                description='Snake case naming convention',\n                examples=[],\n                confidence=0.9,\n                occurrences=snake_case_funcs\n            ))\n\n        return patterns\n\n    def _detect_architectural_patterns(self, content: str) -&gt; List[CodePattern]:\n        \"\"\"Detect architectural patterns in code.\"\"\"\n        patterns = []\n\n        # MVC pattern\n        if any(keyword in content.lower() for keyword in ['model', 'view', 'controller']):\n            patterns.append(CodePattern(\n                pattern_type='mvc',\n                description='MVC pattern detected',\n                examples=[],\n                confidence=0.6,\n                occurrences=1\n            ))\n\n        return patterns\n\n    def _detect_code_smells(self, content: str) -&gt; List[CodePattern]:\n        \"\"\"Detect code smells.\"\"\"\n        patterns = []\n\n        # Long functions (heuristic)\n        lines = content.split('\\\\n')\n        current_function_length = 0\n        in_function = False\n\n        for line in lines:\n            if line.strip().startswith('def '):\n                in_function = True\n                current_function_length = 0\n            elif in_function:\n                current_function_length += 1\n                if current_function_length &gt; 50:  # Arbitrary threshold\n                    patterns.append(CodePattern(\n                        pattern_type='code_smell',\n                        description='Long function detected',\n                        examples=[],\n                        confidence=0.8,\n                        occurrences=1\n                    ))\n                    in_function = False\n\n            if line.strip() == '':\n                in_function = False\n\n        return patterns\n\n    def _generate_summary(self) -&gt; str:\n        \"\"\"Generate a comprehensive summary of codebase analysis.\"\"\"\n        if not self.code_files:\n            return \"No source code files found in the repository.\"\n\n        summary = f\"Codebase Analysis Summary:\\\\n\"\n        summary += f\"\u2022 Found {len(self.code_files)} source code files\\\\n\"\n        summary += f\"\u2022 Analyzed {len(self.analyzed_files)} files in detail\\\\n\"\n        summary += f\"\u2022 Extracted {sum(len(entities) for entities in self.code_entities.values())} code entities\\\\n\"\n        summary += f\"\u2022 Detected {len(self.code_patterns)} code patterns\\\\n\"\n\n        # Language distribution\n        if self.language_stats:\n            lang_summary = ', '.join(f'{lang}({count})' for lang, count in self.language_stats.items())\n            summary += f\"\u2022 Languages: {lang_summary}\\\\n\"\n\n        # Entity types\n        if self.code_entities:\n            entity_types = defaultdict(int)\n            for entities in self.code_entities.values():\n                for entity in entities:\n                    entity_types[entity.type] += 1\n\n            if entity_types:\n                entity_summary = ', '.join(f'{etype}({count})' for etype, count in entity_types.items())\n                summary += f\"\u2022 Entities: {entity_summary}\\\\n\"\n\n        # Pattern types\n        if self.code_patterns:\n            pattern_types = defaultdict(int)\n            for pattern in self.code_patterns:\n                pattern_types[pattern.pattern_type] += 1\n\n            pattern_summary = ', '.join(f'{ptype}({count})' for ptype, count in pattern_types.items())\n            summary += f\"\u2022 Patterns: {pattern_summary}\\\\n\"\n\n        # Cache performance\n        if self.state.cache_hits &gt; 0:\n            summary += f\"\u2022 Cache hits: {self.state.cache_hits}\\\\n\"\n\n        if self.state.error_count &gt; 0:\n            summary += f\"\u2022 Errors encountered: {self.state.error_count}\\\\n\"\n\n        return summary\n\n    def get_code_entities(self) -&gt; Dict[str, List[CodeEntity]]:\n        \"\"\"Get all extracted code entities.\"\"\"\n        return self.code_entities\n\n    def get_code_patterns(self) -&gt; List[CodePattern]:\n        \"\"\"Get all detected code patterns.\"\"\"\n        return self.code_patterns\n\n    def get_analyzed_files(self) -&gt; Dict[str, Any]:\n        \"\"\"Get all analyzed files.\"\"\"\n        return self.analyzed_files\n\n    def get_language_stats(self) -&gt; Dict[str, int]:\n        \"\"\"Get language distribution statistics.\"\"\"\n        return dict(self.language_stats)\n</code></pre> <p>The Codebase Agent specializes in comprehensive source code analysis using the ReAct pattern.</p>"},{"location":"api/codebase-agent/#cf.agents.react_codebase_agent.ReActCodebaseAgent.analyze_codebase","title":"<code>analyze_codebase(description)</code>","text":"<p>Main entry point for codebase analysis using ReAct pattern.</p> <p>Parameters:</p> Name Type Description Default <code>description</code> <code>str</code> <p>Description of what to focus on during analysis</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Comprehensive codebase analysis results</p> Source code in <code>cf/agents/react_codebase_agent.py</code> <pre><code>def analyze_codebase(self, description: str) -&gt; Dict[str, Any]:\n    \"\"\"\n    Main entry point for codebase analysis using ReAct pattern.\n\n    Args:\n        description: Description of what to focus on during analysis\n\n    Returns:\n        Comprehensive codebase analysis results\n    \"\"\"\n    goal = f\"Analyze codebase for: {description}\"\n    return self.execute_react_loop(goal, max_iterations=20)\n</code></pre>"},{"location":"api/codebase-agent/#cf.agents.react_codebase_agent.ReActCodebaseAgent.get_analyzed_files","title":"<code>get_analyzed_files()</code>","text":"<p>Get all analyzed files.</p> Source code in <code>cf/agents/react_codebase_agent.py</code> <pre><code>def get_analyzed_files(self) -&gt; Dict[str, Any]:\n    \"\"\"Get all analyzed files.\"\"\"\n    return self.analyzed_files\n</code></pre>"},{"location":"api/codebase-agent/#cf.agents.react_codebase_agent.ReActCodebaseAgent.get_code_entities","title":"<code>get_code_entities()</code>","text":"<p>Get all extracted code entities.</p> Source code in <code>cf/agents/react_codebase_agent.py</code> <pre><code>def get_code_entities(self) -&gt; Dict[str, List[CodeEntity]]:\n    \"\"\"Get all extracted code entities.\"\"\"\n    return self.code_entities\n</code></pre>"},{"location":"api/codebase-agent/#cf.agents.react_codebase_agent.ReActCodebaseAgent.get_code_patterns","title":"<code>get_code_patterns()</code>","text":"<p>Get all detected code patterns.</p> Source code in <code>cf/agents/react_codebase_agent.py</code> <pre><code>def get_code_patterns(self) -&gt; List[CodePattern]:\n    \"\"\"Get all detected code patterns.\"\"\"\n    return self.code_patterns\n</code></pre>"},{"location":"api/codebase-agent/#cf.agents.react_codebase_agent.ReActCodebaseAgent.get_language_stats","title":"<code>get_language_stats()</code>","text":"<p>Get language distribution statistics.</p> Source code in <code>cf/agents/react_codebase_agent.py</code> <pre><code>def get_language_stats(self) -&gt; Dict[str, int]:\n    \"\"\"Get language distribution statistics.\"\"\"\n    return dict(self.language_stats)\n</code></pre>"},{"location":"api/codebase-agent/#cf.agents.react_codebase_agent.ReActCodebaseAgent.observe","title":"<code>observe(observation)</code>","text":"<p>Enhanced observation phase for codebase analysis.</p> <p>Parameters:</p> Name Type Description Default <code>observation</code> <p>Observation from the action</p> required Source code in <code>cf/agents/react_codebase_agent.py</code> <pre><code>def observe(self, observation):\n    \"\"\"\n    Enhanced observation phase for codebase analysis.\n\n    Args:\n        observation: Observation from the action\n    \"\"\"\n    super().observe(observation)\n\n    # Process code-specific observations\n    if observation.success and observation.result:\n        result = observation.result\n\n        # If we scanned a directory, extract source code files\n        if isinstance(result, dict) and 'contents' in result:\n            for item in result['contents']:\n                if not item['is_directory'] and self._is_source_code_file(item['path']):\n                    if item['path'] not in self.code_files:\n                        self.code_files.append(item['path'])\n                        self.language_stats[self._detect_language(item['path'])] += 1\n                        self.logger.info(f\"\ud83d\udcbe Found source file: {item['path']}\")\n\n        # If we listed files, filter for source code\n        elif isinstance(result, dict) and 'files' in result:\n            for file_info in result['files']:\n                if self._is_source_code_file(file_info['path']):\n                    if file_info['path'] not in self.code_files:\n                        self.code_files.append(file_info['path'])\n                        self.language_stats[self._detect_language(file_info['path'])] += 1\n                        self.logger.info(f\"\ud83d\udcbe Found source file: {file_info['path']}\")\n\n        # If we read a file, analyze its code content\n        elif isinstance(result, dict) and 'content' in result:\n            file_path = result['file_path']\n            content = result['content']\n\n            # Analyze the code content\n            analysis = self._analyze_code_content(file_path, content)\n            self.analyzed_files[file_path] = analysis\n\n            # Extract code entities\n            entities = self._extract_code_entities(file_path, content)\n            self.code_entities[file_path] = entities\n\n            # Detect patterns\n            patterns = self._detect_patterns_in_file(file_path, content)\n            self.code_patterns.extend(patterns)\n\n            self.logger.info(f\"\ud83d\udd0d Analyzed code file: {file_path}\")\n\n        # If we searched files, process the results\n        elif isinstance(result, dict) and 'results' in result:\n            for search_result in result['results']:\n                file_path = search_result['file_path']\n                matches = search_result.get('matches', [])\n\n                # Process search matches\n                if matches:\n                    self._process_search_matches(file_path, matches)\n                    self.logger.info(f\"\ud83d\udd0d Found {len(matches)} matches in {file_path}\")\n</code></pre>"},{"location":"api/codebase-agent/#cf.agents.react_codebase_agent.ReActCodebaseAgent.plan_action","title":"<code>plan_action(reasoning)</code>","text":"<p>Plan the next action based on reasoning.</p> <p>Parameters:</p> Name Type Description Default <code>reasoning</code> <code>str</code> <p>The reasoning output</p> required <p>Returns:</p> Type Description <code>ReActAction</code> <p>Action to take</p> Source code in <code>cf/agents/react_codebase_agent.py</code> <pre><code>def plan_action(self, reasoning: str) -&gt; ReActAction:\n    \"\"\"\n    Plan the next action based on reasoning.\n\n    Args:\n        reasoning: The reasoning output\n\n    Returns:\n        Action to take\n    \"\"\"\n    iteration = self.state.iteration\n\n    # Early iterations: Directory scanning and file discovery\n    if iteration &lt;= 2:\n        return ReActAction(\n            action_type=ActionType.SCAN_DIRECTORY,\n            description=\"Scan repository for source code files\",\n            parameters={'directory': '.', 'max_depth': 3},\n            expected_outcome=\"Understand repository structure and find source code\"\n        )\n\n    # Find source code files if not found yet\n    if not self.code_files and iteration &lt;= 4:\n        return ReActAction(\n            action_type=ActionType.LIST_FILES,\n            description=\"List source code files\",\n            parameters={'pattern': '.py', 'directory': '.'},\n            expected_outcome=\"Identify Python source files\"\n        )\n\n    # Analyze high-priority source files\n    if self.code_files and len(self.analyzed_files) &lt; 5:\n        # Prioritize main files, __init__.py, and files with 'main' in name\n        priority_files = [f for f in self.code_files if 'main' in f.lower() or '__init__' in f.lower()]\n        if priority_files:\n            file_to_analyze = priority_files[0]\n        else:\n            file_to_analyze = self.code_files[0]\n\n        return ReActAction(\n            action_type=ActionType.READ_FILE,\n            description=f\"Read and analyze source file: {file_to_analyze}\",\n            parameters={'file_path': file_to_analyze, 'max_lines': 500},\n            expected_outcome=\"Understand code structure and extract entities\"\n        )\n\n    # Goal-specific searches\n    if \"api\" in self.state.goal.lower():\n        return ReActAction(\n            action_type=ActionType.SEARCH_FILES,\n            description=\"Search for API-related code patterns\",\n            parameters={'pattern': 'api', 'file_types': ['.py', '.js', '.ts'], 'max_results': 20},\n            expected_outcome=\"Find API endpoints, routes, and handlers\"\n        )\n\n    elif \"class\" in self.state.goal.lower():\n        return ReActAction(\n            action_type=ActionType.SEARCH_FILES,\n            description=\"Search for class definitions\",\n            parameters={'pattern': 'class ', 'file_types': ['.py', '.js', '.ts', '.java'], 'max_results': 20},\n            expected_outcome=\"Find class definitions and OOP patterns\"\n        )\n\n    elif \"function\" in self.state.goal.lower():\n        return ReActAction(\n            action_type=ActionType.SEARCH_FILES,\n            description=\"Search for function definitions\",\n            parameters={'pattern': 'def ', 'file_types': ['.py'], 'max_results': 20},\n            expected_outcome=\"Find function definitions and analyze structure\"\n        )\n\n    elif \"import\" in self.state.goal.lower() or \"dependency\" in self.state.goal.lower():\n        return ReActAction(\n            action_type=ActionType.SEARCH_FILES,\n            description=\"Search for import statements\",\n            parameters={'pattern': 'import ', 'file_types': ['.py', '.js', '.ts'], 'max_results': 30},\n            expected_outcome=\"Understand dependencies and module structure\"\n        )\n\n    # Analyze specific files for patterns\n    if self.analyzed_files:\n        return ReActAction(\n            action_type=ActionType.ANALYZE_CODE,\n            description=\"Analyze code patterns and complexity\",\n            parameters={'file_path': list(self.analyzed_files.keys())[0], 'analysis_type': 'patterns'},\n            expected_outcome=\"Extract code patterns and complexity metrics\"\n        )\n\n    # Default: Use LLM reasoning\n    return ReActAction(\n        action_type=ActionType.LLM_REASONING,\n        description=\"Use LLM to determine next code analysis step\",\n        parameters={\n            'context': str(self.state.current_context),\n            'question': f\"What should I analyze next for: {self.state.goal}?\"\n        },\n        expected_outcome=\"Get guidance on next analysis step\"\n    )\n</code></pre>"},{"location":"api/codebase-agent/#cf.agents.react_codebase_agent.ReActCodebaseAgent.reason","title":"<code>reason()</code>","text":"<p>Reasoning phase: Determine what code analysis action to take next.</p> <p>Returns:</p> Type Description <code>str</code> <p>Reasoning about next action to take</p> Source code in <code>cf/agents/react_codebase_agent.py</code> <pre><code>def reason(self) -&gt; str:\n    \"\"\"\n    Reasoning phase: Determine what code analysis action to take next.\n\n    Returns:\n        Reasoning about next action to take\n    \"\"\"\n    current_context = self.state.current_context\n    iteration = self.state.iteration\n\n    # First iteration: Start with directory scan to understand structure\n    if iteration == 1:\n        return \"I should start by scanning the repository structure to understand the codebase layout and identify source code files.\"\n\n    # Early iterations: Focus on discovery\n    if iteration &lt;= 3 and not self.code_files:\n        return \"I need to identify source code files by scanning directories and looking for common programming language extensions.\"\n\n    # If we have code files but haven't analyzed them yet\n    if self.code_files and not self.analyzed_files:\n        return f\"I found {len(self.code_files)} code files. Now I should analyze the most important ones to understand the codebase structure.\"\n\n    # If we have some analysis but need more depth\n    if self.analyzed_files and len(self.analyzed_files) &lt; 5:\n        return \"I've analyzed some files but need to dive deeper. Let me examine more files and look for patterns and dependencies.\"\n\n    # Focus on specific goal-related analysis\n    if \"api\" in self.state.goal.lower():\n        return \"The goal mentions API. I should search for API-related patterns, endpoints, and routing code.\"\n    elif \"database\" in self.state.goal.lower():\n        return \"The goal mentions database. I should search for database models, queries, and data access patterns.\"\n    elif \"test\" in self.state.goal.lower():\n        return \"The goal mentions testing. I should search for test files and testing patterns.\"\n    elif \"config\" in self.state.goal.lower():\n        return \"The goal mentions configuration. I should search for configuration files and settings.\"\n\n    # If we have good coverage, focus on patterns and relationships\n    if len(self.analyzed_files) &gt;= 5:\n        return \"I have analyzed multiple files. Now I should look for patterns, dependencies, and architectural insights.\"\n\n    # Default reasoning\n    return \"I should continue analyzing the codebase systematically, focusing on files that are most relevant to the goal.\"\n</code></pre>"},{"location":"api/codebase-agent/#overview","title":"Overview","text":"<p>The Codebase Agent excels at:</p> <ul> <li>Source code analysis and pattern detection</li> <li>Function and class extraction</li> <li>Dependency analysis</li> <li>Code complexity assessment</li> <li>Language-specific analysis (Python, JavaScript, TypeScript, etc.)</li> </ul>"},{"location":"api/codebase-agent/#usage-examples","title":"Usage Examples","text":""},{"location":"api/codebase-agent/#basic-code-analysis","title":"Basic Code Analysis","text":"<pre><code>from cf.agents.react_codebase_agent import ReActCodebaseAgent\nfrom cf.aci.repo import LocalCodeRepo\nfrom cf.config import CfConfig\n\n# Initialize agent\nrepo = LocalCodeRepo(\"/path/to/repository\")\nconfig = CfConfig()\ncode_agent = ReActCodebaseAgent(repo, config)\n\n# Analyze codebase\nresults = code_agent.analyze_codebase(\"comprehensive code structure analysis\")\n\nprint(f\"Code files analyzed: {len(results.get('analyzed_files', {}))}\")\nprint(f\"Code entities found: {len(results.get('code_entities', {}))}\")\nprint(f\"Patterns detected: {len(results.get('code_patterns', []))}\")\n</code></pre>"},{"location":"api/codebase-agent/#language-specific-analysis","title":"Language-Specific Analysis","text":"<pre><code># Python-specific analysis\npython_results = code_agent.analyze_codebase(\"Python code patterns and structure\")\n\n# JavaScript/TypeScript analysis  \njs_results = code_agent.analyze_codebase(\"JavaScript and TypeScript analysis\")\n\n# Access language statistics\nlanguage_stats = code_agent.get_language_stats()\nprint(f\"Languages found: {language_stats}\")\n</code></pre>"},{"location":"api/codebase-agent/#code-entity-extraction","title":"Code Entity Extraction","text":"<pre><code># Get detailed code entities\nentities = code_agent.get_code_entities()\n\nfor file_path, file_entities in entities.items():\n    print(f\"File: {file_path}\")\n    for entity in file_entities:\n        print(f\"  {entity.type}: {entity.name} (lines {entity.line_start}-{entity.line_end})\")\n        if entity.docstring:\n            print(f\"    Docstring: {entity.docstring[:100]}...\")\n</code></pre> <p>For complete API documentation, see the source code.</p>"},{"location":"api/config/","title":"Configuration","text":"<p>Configuration class for CodeFusion that loads from YAML/JSON files.</p> Source code in <code>cf/config.py</code> <pre><code>@dataclass\nclass CfConfig:\n    \"\"\"Configuration class for CodeFusion that loads from YAML/JSON files.\"\"\"\n\n    # Core settings\n    repo_path: Optional[str] = None\n    output_dir: str = \"./output\"\n\n    # Simple exploration settings\n    max_file_size: int = 1024 * 1024  # 1MB\n    excluded_dirs: list = field(\n        default_factory=lambda: [\".git\", \"__pycache__\", \"node_modules\", \".venv\", \"venv\"]\n    )\n    excluded_extensions: list = field(\n        default_factory=lambda: [\".pyc\", \".pyo\", \".pyd\", \".so\", \".dll\", \".exe\", \".env\"]\n    )\n    max_exploration_depth: int = 5\n\n    # Multi-agent settings\n    agents: Dict[str, Any] = field(default_factory=lambda: {\n        \"supervisor\": {\"enabled\": True, \"max_agents\": 4, \"timeout\": 300},\n        \"documentation\": {\"enabled\": True, \"file_types\": [\".md\", \".rst\", \".txt\", \".adoc\"], \"max_files\": 50},\n        \"codebase\": {\"enabled\": True, \"languages\": [\"python\", \"javascript\", \"typescript\", \"java\", \"go\", \"rust\", \"c\", \"cpp\"], \"max_files\": 200},\n        \"architecture\": {\"enabled\": True, \"diagram_types\": [\"mermaid\", \"plantuml\", \"graphviz\"], \"max_components\": 100},\n        \"summary\": {\"enabled\": True, \"max_sections\": 10, \"cheat_sheet_format\": \"markdown\"}\n    })\n\n    # Error recovery settings\n    error_recovery: Dict[str, Any] = field(default_factory=lambda: {\n        \"enabled\": True,\n        \"max_retries\": 3,\n        \"circuit_breaker_threshold\": 5,\n        \"loop_detection_window\": 10\n    })\n\n    @classmethod\n    def from_file(cls, config_path: str) -&gt; \"CfConfig\":\n        \"\"\"Load configuration from a YAML or JSON file.\"\"\"\n        path = Path(config_path)\n\n        if not path.exists():\n            raise FileNotFoundError(f\"Configuration file not found: {config_path}\")\n\n        with open(path, \"r\", encoding=\"utf-8\") as f:\n            if path.suffix.lower() in [\".yaml\", \".yml\"]:\n                data = yaml.safe_load(f)\n            elif path.suffix.lower() == \".json\":\n                data = json.load(f)\n            else:\n                raise ValueError(\n                    f\"Unsupported configuration file format: {path.suffix}\"\n                )\n\n        # Load environment variables to override config\n        config = cls(**data)\n        config._load_env_overrides()\n        return config\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -&gt; \"CfConfig\":\n        \"\"\"Create configuration from dictionary.\"\"\"\n        return cls(**data)\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert configuration to dictionary.\"\"\"\n        return {\n            \"repo_path\": self.repo_path,\n            \"output_dir\": self.output_dir,\n            \"max_file_size\": self.max_file_size,\n            \"excluded_dirs\": self.excluded_dirs,\n            \"excluded_extensions\": self.excluded_extensions,\n            \"max_exploration_depth\": self.max_exploration_depth,\n            \"agents\": self.agents,\n            \"error_recovery\": self.error_recovery,\n        }\n\n    def save(self, config_path: str) -&gt; None:\n        \"\"\"Save configuration to a YAML or JSON file.\"\"\"\n        path = Path(config_path)\n        data = self.to_dict()\n\n        with open(path, \"w\", encoding=\"utf-8\") as f:\n            if path.suffix.lower() in [\".yaml\", \".yml\"]:\n                yaml.dump(data, f, default_flow_style=False, indent=2)\n            elif path.suffix.lower() == \".json\":\n                json.dump(data, f, indent=2)\n            else:\n                raise ValueError(\n                    f\"Unsupported configuration file format: {path.suffix}\"\n                )\n\n    def validate(self) -&gt; None:\n        \"\"\"Validate configuration settings.\"\"\"\n        if self.max_exploration_depth &lt; 1:\n            raise ValueError(\"max_exploration_depth must be at least 1\")\n\n        if self.max_file_size &lt; 1:\n            raise ValueError(\"max_file_size must be at least 1\")\n\n    def _load_env_overrides(self) -&gt; None:\n        \"\"\"Load environment variable overrides.\"\"\"\n        # Simple configuration - no environment overrides needed for basic exploration\n        pass\n</code></pre> <p>Configuration for ReAct agent behavior.</p> Source code in <code>cf/core/react_config.py</code> <pre><code>@dataclass\nclass ReActConfig:\n    \"\"\"Configuration for ReAct agent behavior.\"\"\"\n\n    # Loop parameters\n    max_iterations: int = 20\n    iteration_timeout: float = 30.0  # seconds per iteration\n    total_timeout: float = 600.0  # seconds for entire loop\n\n    # Error handling\n    max_errors: int = 10\n    max_consecutive_errors: int = 3\n    error_recovery_enabled: bool = True\n    circuit_breaker_threshold: int = 5\n\n    # Stuck detection\n    stuck_detection_enabled: bool = True\n    max_same_action_repeats: int = 3\n    loop_detection_window: int = 10\n\n    # Tool parameters\n    tool_timeout: float = 15.0  # seconds per tool call\n    max_tool_retries: int = 2\n    tool_validation_enabled: bool = True\n\n    # Cache parameters\n    cache_enabled: bool = True\n    cache_max_size: int = 1000\n    cache_ttl: int = 3600  # seconds\n\n    # Logging and tracing\n    tracing_enabled: bool = True\n    trace_directory: Optional[str] = None\n    log_level: str = \"INFO\"\n    verbose_logging: bool = False\n\n    # LLM parameters\n    llm_reasoning_enabled: bool = True\n    llm_reasoning_threshold: int = 5  # Use LLM after this many iterations\n    llm_summary_enabled: bool = True\n\n    # Performance parameters\n    parallel_tools_enabled: bool = False\n    max_parallel_tools: int = 3\n\n    @classmethod\n    def from_env(cls) -&gt; 'ReActConfig':\n        \"\"\"Create configuration from environment variables.\"\"\"\n        return cls(\n            # Loop parameters\n            max_iterations=int(os.getenv('CF_REACT_MAX_ITERATIONS', '20')),\n            iteration_timeout=float(os.getenv('CF_REACT_ITERATION_TIMEOUT', '30.0')),\n            total_timeout=float(os.getenv('CF_REACT_TOTAL_TIMEOUT', '600.0')),\n\n            # Error handling\n            max_errors=int(os.getenv('CF_REACT_MAX_ERRORS', '10')),\n            max_consecutive_errors=int(os.getenv('CF_REACT_MAX_CONSECUTIVE_ERRORS', '3')),\n            error_recovery_enabled=os.getenv('CF_REACT_ERROR_RECOVERY', 'true').lower() == 'true',\n            circuit_breaker_threshold=int(os.getenv('CF_REACT_CIRCUIT_BREAKER_THRESHOLD', '5')),\n\n            # Stuck detection\n            stuck_detection_enabled=os.getenv('CF_REACT_STUCK_DETECTION', 'true').lower() == 'true',\n            max_same_action_repeats=int(os.getenv('CF_REACT_MAX_SAME_ACTION_REPEATS', '3')),\n            loop_detection_window=int(os.getenv('CF_REACT_LOOP_DETECTION_WINDOW', '10')),\n\n            # Tool parameters\n            tool_timeout=float(os.getenv('CF_REACT_TOOL_TIMEOUT', '15.0')),\n            max_tool_retries=int(os.getenv('CF_REACT_MAX_TOOL_RETRIES', '2')),\n            tool_validation_enabled=os.getenv('CF_REACT_TOOL_VALIDATION', 'true').lower() == 'true',\n\n            # Cache parameters\n            cache_enabled=os.getenv('CF_REACT_CACHE_ENABLED', 'true').lower() == 'true',\n            cache_max_size=int(os.getenv('CF_REACT_CACHE_MAX_SIZE', '1000')),\n            cache_ttl=int(os.getenv('CF_REACT_CACHE_TTL', '3600')),\n\n            # Logging and tracing\n            tracing_enabled=os.getenv('CF_REACT_TRACING_ENABLED', 'true').lower() == 'true',\n            trace_directory=os.getenv('CF_REACT_TRACE_DIR'),\n            log_level=os.getenv('CF_REACT_LOG_LEVEL', 'INFO'),\n            verbose_logging=os.getenv('CF_REACT_VERBOSE_LOGGING', 'false').lower() == 'true',\n\n            # LLM parameters\n            llm_reasoning_enabled=os.getenv('CF_REACT_LLM_REASONING', 'true').lower() == 'true',\n            llm_reasoning_threshold=int(os.getenv('CF_REACT_LLM_REASONING_THRESHOLD', '5')),\n            llm_summary_enabled=os.getenv('CF_REACT_LLM_SUMMARY', 'true').lower() == 'true',\n\n            # Performance parameters\n            parallel_tools_enabled=os.getenv('CF_REACT_PARALLEL_TOOLS', 'false').lower() == 'true',\n            max_parallel_tools=int(os.getenv('CF_REACT_MAX_PARALLEL_TOOLS', '3'))\n        )\n\n    @classmethod\n    def from_dict(cls, config_dict: Dict[str, Any]) -&gt; 'ReActConfig':\n        \"\"\"Create configuration from dictionary.\"\"\"\n        return cls(**config_dict)\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert configuration to dictionary.\"\"\"\n        return {\n            'max_iterations': self.max_iterations,\n            'iteration_timeout': self.iteration_timeout,\n            'total_timeout': self.total_timeout,\n            'max_errors': self.max_errors,\n            'max_consecutive_errors': self.max_consecutive_errors,\n            'error_recovery_enabled': self.error_recovery_enabled,\n            'circuit_breaker_threshold': self.circuit_breaker_threshold,\n            'stuck_detection_enabled': self.stuck_detection_enabled,\n            'max_same_action_repeats': self.max_same_action_repeats,\n            'loop_detection_window': self.loop_detection_window,\n            'tool_timeout': self.tool_timeout,\n            'max_tool_retries': self.max_tool_retries,\n            'tool_validation_enabled': self.tool_validation_enabled,\n            'cache_enabled': self.cache_enabled,\n            'cache_max_size': self.cache_max_size,\n            'cache_ttl': self.cache_ttl,\n            'tracing_enabled': self.tracing_enabled,\n            'trace_directory': self.trace_directory,\n            'log_level': self.log_level,\n            'verbose_logging': self.verbose_logging,\n            'llm_reasoning_enabled': self.llm_reasoning_enabled,\n            'llm_reasoning_threshold': self.llm_reasoning_threshold,\n            'llm_summary_enabled': self.llm_summary_enabled,\n            'parallel_tools_enabled': self.parallel_tools_enabled,\n            'max_parallel_tools': self.max_parallel_tools\n        }\n\n    def update_from_dict(self, updates: Dict[str, Any]):\n        \"\"\"Update configuration from dictionary.\"\"\"\n        for key, value in updates.items():\n            if hasattr(self, key):\n                setattr(self, key, value)\n\n    def validate(self) -&gt; bool:\n        \"\"\"Validate configuration parameters.\"\"\"\n        if self.max_iterations &lt;= 0:\n            raise ValueError(\"max_iterations must be positive\")\n\n        if self.iteration_timeout &lt;= 0:\n            raise ValueError(\"iteration_timeout must be positive\")\n\n        if self.total_timeout &lt;= 0:\n            raise ValueError(\"total_timeout must be positive\")\n\n        if self.max_errors &lt;= 0:\n            raise ValueError(\"max_errors must be positive\")\n\n        if self.max_consecutive_errors &lt;= 0:\n            raise ValueError(\"max_consecutive_errors must be positive\")\n\n        if self.circuit_breaker_threshold &lt;= 0:\n            raise ValueError(\"circuit_breaker_threshold must be positive\")\n\n        if self.max_same_action_repeats &lt;= 0:\n            raise ValueError(\"max_same_action_repeats must be positive\")\n\n        if self.loop_detection_window &lt;= 0:\n            raise ValueError(\"loop_detection_window must be positive\")\n\n        if self.tool_timeout &lt;= 0:\n            raise ValueError(\"tool_timeout must be positive\")\n\n        if self.max_tool_retries &lt; 0:\n            raise ValueError(\"max_tool_retries must be non-negative\")\n\n        if self.cache_max_size &lt;= 0:\n            raise ValueError(\"cache_max_size must be positive\")\n\n        if self.cache_ttl &lt;= 0:\n            raise ValueError(\"cache_ttl must be positive\")\n\n        if self.llm_reasoning_threshold &lt;= 0:\n            raise ValueError(\"llm_reasoning_threshold must be positive\")\n\n        if self.max_parallel_tools &lt;= 0:\n            raise ValueError(\"max_parallel_tools must be positive\")\n\n        return True\n\n    def get_performance_profile(self) -&gt; str:\n        \"\"\"Get a performance profile description.\"\"\"\n        if self.max_iterations &lt;= 10 and self.tool_timeout &lt;= 10:\n            return \"fast\"\n        elif self.max_iterations &lt;= 30 and self.tool_timeout &lt;= 30:\n            return \"balanced\"\n        else:\n            return \"thorough\"\n\n    def apply_performance_profile(self, profile: str):\n        \"\"\"Apply a predefined performance profile.\"\"\"\n        if profile == \"fast\":\n            self.max_iterations = 10\n            self.iteration_timeout = 15.0\n            self.total_timeout = 300.0\n            self.tool_timeout = 10.0\n            self.max_errors = 5\n            self.cache_max_size = 500\n\n        elif profile == \"balanced\":\n            self.max_iterations = 20\n            self.iteration_timeout = 30.0\n            self.total_timeout = 600.0\n            self.tool_timeout = 15.0\n            self.max_errors = 10\n            self.cache_max_size = 1000\n\n        elif profile == \"thorough\":\n            self.max_iterations = 50\n            self.iteration_timeout = 60.0\n            self.total_timeout = 1800.0\n            self.tool_timeout = 30.0\n            self.max_errors = 20\n            self.cache_max_size = 2000\n\n        else:\n            raise ValueError(f\"Unknown performance profile: {profile}\")\n</code></pre> <p>The CodeFusion framework provides comprehensive configuration options for performance tuning, LLM integration, and behavioral customization.</p>"},{"location":"api/config/#cf.config.CfConfig.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create configuration from dictionary.</p> Source code in <code>cf/config.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict[str, Any]) -&gt; \"CfConfig\":\n    \"\"\"Create configuration from dictionary.\"\"\"\n    return cls(**data)\n</code></pre>"},{"location":"api/config/#cf.config.CfConfig.from_file","title":"<code>from_file(config_path)</code>  <code>classmethod</code>","text":"<p>Load configuration from a YAML or JSON file.</p> Source code in <code>cf/config.py</code> <pre><code>@classmethod\ndef from_file(cls, config_path: str) -&gt; \"CfConfig\":\n    \"\"\"Load configuration from a YAML or JSON file.\"\"\"\n    path = Path(config_path)\n\n    if not path.exists():\n        raise FileNotFoundError(f\"Configuration file not found: {config_path}\")\n\n    with open(path, \"r\", encoding=\"utf-8\") as f:\n        if path.suffix.lower() in [\".yaml\", \".yml\"]:\n            data = yaml.safe_load(f)\n        elif path.suffix.lower() == \".json\":\n            data = json.load(f)\n        else:\n            raise ValueError(\n                f\"Unsupported configuration file format: {path.suffix}\"\n            )\n\n    # Load environment variables to override config\n    config = cls(**data)\n    config._load_env_overrides()\n    return config\n</code></pre>"},{"location":"api/config/#cf.config.CfConfig.save","title":"<code>save(config_path)</code>","text":"<p>Save configuration to a YAML or JSON file.</p> Source code in <code>cf/config.py</code> <pre><code>def save(self, config_path: str) -&gt; None:\n    \"\"\"Save configuration to a YAML or JSON file.\"\"\"\n    path = Path(config_path)\n    data = self.to_dict()\n\n    with open(path, \"w\", encoding=\"utf-8\") as f:\n        if path.suffix.lower() in [\".yaml\", \".yml\"]:\n            yaml.dump(data, f, default_flow_style=False, indent=2)\n        elif path.suffix.lower() == \".json\":\n            json.dump(data, f, indent=2)\n        else:\n            raise ValueError(\n                f\"Unsupported configuration file format: {path.suffix}\"\n            )\n</code></pre>"},{"location":"api/config/#cf.config.CfConfig.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert configuration to dictionary.</p> Source code in <code>cf/config.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert configuration to dictionary.\"\"\"\n    return {\n        \"repo_path\": self.repo_path,\n        \"output_dir\": self.output_dir,\n        \"max_file_size\": self.max_file_size,\n        \"excluded_dirs\": self.excluded_dirs,\n        \"excluded_extensions\": self.excluded_extensions,\n        \"max_exploration_depth\": self.max_exploration_depth,\n        \"agents\": self.agents,\n        \"error_recovery\": self.error_recovery,\n    }\n</code></pre>"},{"location":"api/config/#cf.config.CfConfig.validate","title":"<code>validate()</code>","text":"<p>Validate configuration settings.</p> Source code in <code>cf/config.py</code> <pre><code>def validate(self) -&gt; None:\n    \"\"\"Validate configuration settings.\"\"\"\n    if self.max_exploration_depth &lt; 1:\n        raise ValueError(\"max_exploration_depth must be at least 1\")\n\n    if self.max_file_size &lt; 1:\n        raise ValueError(\"max_file_size must be at least 1\")\n</code></pre>"},{"location":"api/config/#cf.core.react_config.ReActConfig.apply_performance_profile","title":"<code>apply_performance_profile(profile)</code>","text":"<p>Apply a predefined performance profile.</p> Source code in <code>cf/core/react_config.py</code> <pre><code>def apply_performance_profile(self, profile: str):\n    \"\"\"Apply a predefined performance profile.\"\"\"\n    if profile == \"fast\":\n        self.max_iterations = 10\n        self.iteration_timeout = 15.0\n        self.total_timeout = 300.0\n        self.tool_timeout = 10.0\n        self.max_errors = 5\n        self.cache_max_size = 500\n\n    elif profile == \"balanced\":\n        self.max_iterations = 20\n        self.iteration_timeout = 30.0\n        self.total_timeout = 600.0\n        self.tool_timeout = 15.0\n        self.max_errors = 10\n        self.cache_max_size = 1000\n\n    elif profile == \"thorough\":\n        self.max_iterations = 50\n        self.iteration_timeout = 60.0\n        self.total_timeout = 1800.0\n        self.tool_timeout = 30.0\n        self.max_errors = 20\n        self.cache_max_size = 2000\n\n    else:\n        raise ValueError(f\"Unknown performance profile: {profile}\")\n</code></pre>"},{"location":"api/config/#cf.core.react_config.ReActConfig.from_dict","title":"<code>from_dict(config_dict)</code>  <code>classmethod</code>","text":"<p>Create configuration from dictionary.</p> Source code in <code>cf/core/react_config.py</code> <pre><code>@classmethod\ndef from_dict(cls, config_dict: Dict[str, Any]) -&gt; 'ReActConfig':\n    \"\"\"Create configuration from dictionary.\"\"\"\n    return cls(**config_dict)\n</code></pre>"},{"location":"api/config/#cf.core.react_config.ReActConfig.from_env","title":"<code>from_env()</code>  <code>classmethod</code>","text":"<p>Create configuration from environment variables.</p> Source code in <code>cf/core/react_config.py</code> <pre><code>@classmethod\ndef from_env(cls) -&gt; 'ReActConfig':\n    \"\"\"Create configuration from environment variables.\"\"\"\n    return cls(\n        # Loop parameters\n        max_iterations=int(os.getenv('CF_REACT_MAX_ITERATIONS', '20')),\n        iteration_timeout=float(os.getenv('CF_REACT_ITERATION_TIMEOUT', '30.0')),\n        total_timeout=float(os.getenv('CF_REACT_TOTAL_TIMEOUT', '600.0')),\n\n        # Error handling\n        max_errors=int(os.getenv('CF_REACT_MAX_ERRORS', '10')),\n        max_consecutive_errors=int(os.getenv('CF_REACT_MAX_CONSECUTIVE_ERRORS', '3')),\n        error_recovery_enabled=os.getenv('CF_REACT_ERROR_RECOVERY', 'true').lower() == 'true',\n        circuit_breaker_threshold=int(os.getenv('CF_REACT_CIRCUIT_BREAKER_THRESHOLD', '5')),\n\n        # Stuck detection\n        stuck_detection_enabled=os.getenv('CF_REACT_STUCK_DETECTION', 'true').lower() == 'true',\n        max_same_action_repeats=int(os.getenv('CF_REACT_MAX_SAME_ACTION_REPEATS', '3')),\n        loop_detection_window=int(os.getenv('CF_REACT_LOOP_DETECTION_WINDOW', '10')),\n\n        # Tool parameters\n        tool_timeout=float(os.getenv('CF_REACT_TOOL_TIMEOUT', '15.0')),\n        max_tool_retries=int(os.getenv('CF_REACT_MAX_TOOL_RETRIES', '2')),\n        tool_validation_enabled=os.getenv('CF_REACT_TOOL_VALIDATION', 'true').lower() == 'true',\n\n        # Cache parameters\n        cache_enabled=os.getenv('CF_REACT_CACHE_ENABLED', 'true').lower() == 'true',\n        cache_max_size=int(os.getenv('CF_REACT_CACHE_MAX_SIZE', '1000')),\n        cache_ttl=int(os.getenv('CF_REACT_CACHE_TTL', '3600')),\n\n        # Logging and tracing\n        tracing_enabled=os.getenv('CF_REACT_TRACING_ENABLED', 'true').lower() == 'true',\n        trace_directory=os.getenv('CF_REACT_TRACE_DIR'),\n        log_level=os.getenv('CF_REACT_LOG_LEVEL', 'INFO'),\n        verbose_logging=os.getenv('CF_REACT_VERBOSE_LOGGING', 'false').lower() == 'true',\n\n        # LLM parameters\n        llm_reasoning_enabled=os.getenv('CF_REACT_LLM_REASONING', 'true').lower() == 'true',\n        llm_reasoning_threshold=int(os.getenv('CF_REACT_LLM_REASONING_THRESHOLD', '5')),\n        llm_summary_enabled=os.getenv('CF_REACT_LLM_SUMMARY', 'true').lower() == 'true',\n\n        # Performance parameters\n        parallel_tools_enabled=os.getenv('CF_REACT_PARALLEL_TOOLS', 'false').lower() == 'true',\n        max_parallel_tools=int(os.getenv('CF_REACT_MAX_PARALLEL_TOOLS', '3'))\n    )\n</code></pre>"},{"location":"api/config/#cf.core.react_config.ReActConfig.get_performance_profile","title":"<code>get_performance_profile()</code>","text":"<p>Get a performance profile description.</p> Source code in <code>cf/core/react_config.py</code> <pre><code>def get_performance_profile(self) -&gt; str:\n    \"\"\"Get a performance profile description.\"\"\"\n    if self.max_iterations &lt;= 10 and self.tool_timeout &lt;= 10:\n        return \"fast\"\n    elif self.max_iterations &lt;= 30 and self.tool_timeout &lt;= 30:\n        return \"balanced\"\n    else:\n        return \"thorough\"\n</code></pre>"},{"location":"api/config/#cf.core.react_config.ReActConfig.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert configuration to dictionary.</p> Source code in <code>cf/core/react_config.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert configuration to dictionary.\"\"\"\n    return {\n        'max_iterations': self.max_iterations,\n        'iteration_timeout': self.iteration_timeout,\n        'total_timeout': self.total_timeout,\n        'max_errors': self.max_errors,\n        'max_consecutive_errors': self.max_consecutive_errors,\n        'error_recovery_enabled': self.error_recovery_enabled,\n        'circuit_breaker_threshold': self.circuit_breaker_threshold,\n        'stuck_detection_enabled': self.stuck_detection_enabled,\n        'max_same_action_repeats': self.max_same_action_repeats,\n        'loop_detection_window': self.loop_detection_window,\n        'tool_timeout': self.tool_timeout,\n        'max_tool_retries': self.max_tool_retries,\n        'tool_validation_enabled': self.tool_validation_enabled,\n        'cache_enabled': self.cache_enabled,\n        'cache_max_size': self.cache_max_size,\n        'cache_ttl': self.cache_ttl,\n        'tracing_enabled': self.tracing_enabled,\n        'trace_directory': self.trace_directory,\n        'log_level': self.log_level,\n        'verbose_logging': self.verbose_logging,\n        'llm_reasoning_enabled': self.llm_reasoning_enabled,\n        'llm_reasoning_threshold': self.llm_reasoning_threshold,\n        'llm_summary_enabled': self.llm_summary_enabled,\n        'parallel_tools_enabled': self.parallel_tools_enabled,\n        'max_parallel_tools': self.max_parallel_tools\n    }\n</code></pre>"},{"location":"api/config/#cf.core.react_config.ReActConfig.update_from_dict","title":"<code>update_from_dict(updates)</code>","text":"<p>Update configuration from dictionary.</p> Source code in <code>cf/core/react_config.py</code> <pre><code>def update_from_dict(self, updates: Dict[str, Any]):\n    \"\"\"Update configuration from dictionary.\"\"\"\n    for key, value in updates.items():\n        if hasattr(self, key):\n            setattr(self, key, value)\n</code></pre>"},{"location":"api/config/#cf.core.react_config.ReActConfig.validate","title":"<code>validate()</code>","text":"<p>Validate configuration parameters.</p> Source code in <code>cf/core/react_config.py</code> <pre><code>def validate(self) -&gt; bool:\n    \"\"\"Validate configuration parameters.\"\"\"\n    if self.max_iterations &lt;= 0:\n        raise ValueError(\"max_iterations must be positive\")\n\n    if self.iteration_timeout &lt;= 0:\n        raise ValueError(\"iteration_timeout must be positive\")\n\n    if self.total_timeout &lt;= 0:\n        raise ValueError(\"total_timeout must be positive\")\n\n    if self.max_errors &lt;= 0:\n        raise ValueError(\"max_errors must be positive\")\n\n    if self.max_consecutive_errors &lt;= 0:\n        raise ValueError(\"max_consecutive_errors must be positive\")\n\n    if self.circuit_breaker_threshold &lt;= 0:\n        raise ValueError(\"circuit_breaker_threshold must be positive\")\n\n    if self.max_same_action_repeats &lt;= 0:\n        raise ValueError(\"max_same_action_repeats must be positive\")\n\n    if self.loop_detection_window &lt;= 0:\n        raise ValueError(\"loop_detection_window must be positive\")\n\n    if self.tool_timeout &lt;= 0:\n        raise ValueError(\"tool_timeout must be positive\")\n\n    if self.max_tool_retries &lt; 0:\n        raise ValueError(\"max_tool_retries must be non-negative\")\n\n    if self.cache_max_size &lt;= 0:\n        raise ValueError(\"cache_max_size must be positive\")\n\n    if self.cache_ttl &lt;= 0:\n        raise ValueError(\"cache_ttl must be positive\")\n\n    if self.llm_reasoning_threshold &lt;= 0:\n        raise ValueError(\"llm_reasoning_threshold must be positive\")\n\n    if self.max_parallel_tools &lt;= 0:\n        raise ValueError(\"max_parallel_tools must be positive\")\n\n    return True\n</code></pre>"},{"location":"api/config/#global-configuration","title":"Global Configuration","text":""},{"location":"api/config/#basic-configuration","title":"Basic Configuration","text":"<pre><code>from cf.config import CfConfig\n\n# Default configuration\nconfig = CfConfig()\n\n# Load from file\nconfig = CfConfig.from_yaml(\"config/my_config.yaml\")\nconfig = CfConfig.from_json(\"config/my_config.json\")\n</code></pre>"},{"location":"api/config/#configuration-file-example","title":"Configuration File Example","text":"<pre><code># config.yaml\nllm:\n  model: \"gpt-4\"\n  api_key: \"your-api-key\"\n  max_tokens: 1500\n  temperature: 0.3\n\nreact:\n  max_iterations: 25\n  iteration_timeout: 45.0\n  total_timeout: 900.0\n  cache_enabled: true\n  cache_max_size: 1000\n\nlogging:\n  level: INFO\n  format: \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n</code></pre>"},{"location":"api/config/#react-configuration","title":"ReAct Configuration","text":""},{"location":"api/config/#performance-profiles","title":"Performance Profiles","text":"<pre><code>from cf.core.react_config import ReActConfig\n\n# Fast analysis\nfast_config = ReActConfig(\n    max_iterations=10,\n    iteration_timeout=15.0,\n    total_timeout=300.0\n)\n\n# Balanced analysis\nbalanced_config = ReActConfig(\n    max_iterations=20,\n    iteration_timeout=30.0,\n    total_timeout=600.0\n)\n\n# Thorough analysis\nthorough_config = ReActConfig(\n    max_iterations=50,\n    iteration_timeout=60.0,\n    total_timeout=1800.0\n)\n</code></pre>"},{"location":"api/config/#environment-variables","title":"Environment Variables","text":"<pre><code># ReAct Loop Configuration\nexport CF_REACT_MAX_ITERATIONS=25\nexport CF_REACT_ITERATION_TIMEOUT=45.0\nexport CF_REACT_TOTAL_TIMEOUT=900.0\n\n# Caching Configuration\nexport CF_REACT_CACHE_ENABLED=true\nexport CF_REACT_CACHE_MAX_SIZE=1000\nexport CF_REACT_CACHE_TTL=3600\n\n# LLM Configuration\nexport CF_LLM_MODEL=gpt-4\nexport CF_LLM_API_KEY=your-api-key\nexport CF_LLM_MAX_TOKENS=1500\nexport CF_LLM_TEMPERATURE=0.3\n</code></pre>"},{"location":"api/config/#usage-examples","title":"Usage Examples","text":""},{"location":"api/config/#custom-configuration","title":"Custom Configuration","text":"<pre><code># Create custom configuration\nconfig = CfConfig(\n    llm_model=\"claude-3-sonnet-20240229\",\n    llm_api_key=\"your-anthropic-key\",\n    cache_enabled=True,\n    verbose_logging=True\n)\n\n# Use with agents\nfrom cf.agents.react_supervisor_agent import ReActSupervisorAgent\nsupervisor = ReActSupervisorAgent(repo, config)\n</code></pre>"},{"location":"api/config/#runtime-configuration-updates","title":"Runtime Configuration Updates","text":"<pre><code># Update configuration at runtime\nconfig.llm_model = \"gpt-4-turbo\"\nconfig.cache_max_size = 2000\n\n# Apply to existing agents\nagent.update_config(config)\n</code></pre> <p>For complete configuration options, see the source code.</p>"},{"location":"api/documentation-agent/","title":"Documentation Agent","text":"<p>               Bases: <code>ReActAgent</code></p> <p>Documentation agent that uses ReAct pattern for systematic documentation analysis.</p> <p>ReAct Loop: 1. Reason: Analyze what documentation to explore next 2. Act: Use tools to scan, read, or search documentation 3. Observe: Reflect on findings and plan next steps</p> Source code in <code>cf/agents/react_documentation_agent.py</code> <pre><code>class ReActDocumentationAgent(ReActAgent):\n    \"\"\"\n    Documentation agent that uses ReAct pattern for systematic documentation analysis.\n\n    ReAct Loop:\n    1. Reason: Analyze what documentation to explore next\n    2. Act: Use tools to scan, read, or search documentation\n    3. Observe: Reflect on findings and plan next steps\n    \"\"\"\n\n    def __init__(self, repo: CodeRepo, config: CfConfig):\n        super().__init__(repo, config, \"DocumentationAgent\")\n\n        # Documentation-specific patterns\n        self.doc_patterns = {\n            'readme': ['README.md', 'readme.md', 'README.rst', 'readme.rst', 'README.txt'],\n            'api_docs': ['API.md', 'api.md', 'docs/api.md', 'docs/API.md'],\n            'architecture': ['ARCHITECTURE.md', 'architecture.md', 'docs/architecture.md'],\n            'contributing': ['CONTRIBUTING.md', 'contributing.md', 'CONTRIBUTE.md'],\n            'changelog': ['CHANGELOG.md', 'changelog.md', 'CHANGES.md', 'HISTORY.md'],\n            'license': ['LICENSE', 'LICENSE.md', 'license.md', 'LICENSE.txt'],\n            'install': ['INSTALL.md', 'install.md', 'INSTALLATION.md', 'installation.md'],\n            'usage': ['USAGE.md', 'usage.md', 'docs/usage.md', 'docs/USAGE.md'],\n            'examples': ['EXAMPLES.md', 'examples.md', 'docs/examples.md']\n        }\n\n        # Documentation analysis state\n        self.found_docs = []\n        self.analyzed_docs = {}\n        self.documentation_insights = []\n        self.key_sections = []\n\n    def scan_documentation(self, description: str) -&gt; Dict[str, Any]:\n        \"\"\"\n        Main entry point for documentation scanning using ReAct pattern.\n\n        Args:\n            description: Description of what to focus on during scanning\n\n        Returns:\n            Comprehensive documentation analysis results\n        \"\"\"\n        goal = f\"Analyze documentation for: {description}\"\n        return self.execute_react_loop(goal, max_iterations=15)\n\n    def reason(self) -&gt; str:\n        \"\"\"\n        Reasoning phase: Determine what documentation action to take next.\n\n        Returns:\n            Reasoning about next action to take\n        \"\"\"\n        current_context = self.state.current_context\n        iteration = self.state.iteration\n\n        # First iteration: Start with directory scan to find documentation\n        if iteration == 1:\n            return \"I should start by scanning the repository structure to identify documentation files. This will give me an overview of what documentation exists.\"\n\n        # If we haven't found documentation files yet, scan more thoroughly\n        if not self.found_docs and iteration &lt;= 3:\n            return \"I haven't found documentation files yet. Let me scan more directories and look for common documentation patterns.\"\n\n        # If we have documentation files but haven't analyzed them\n        if self.found_docs and not self.analyzed_docs:\n            return f\"I found {len(self.found_docs)} documentation files. Now I should read and analyze the most important ones, starting with README files.\"\n\n        # If we have some analysis but need more depth\n        if self.analyzed_docs and len(self.analyzed_docs) &lt; 3:\n            return \"I've analyzed some documentation but need to dive deeper. Let me search for specific patterns and sections relevant to the goal.\"\n\n        # If we have good coverage, focus on synthesis\n        if len(self.analyzed_docs) &gt;= 3:\n            return \"I have analyzed multiple documentation files. Now I should synthesize the information and look for specific details related to the goal.\"\n\n        # Default reasoning\n        return \"I should continue analyzing documentation systematically, focusing on files that are most relevant to the goal.\"\n\n    def plan_action(self, reasoning: str) -&gt; ReActAction:\n        \"\"\"\n        Plan the next action based on reasoning.\n\n        Args:\n            reasoning: The reasoning output\n\n        Returns:\n            Action to take\n        \"\"\"\n        iteration = self.state.iteration\n\n        # Early iterations: Directory scanning and file discovery\n        if iteration &lt;= 2:\n            return ReActAction(\n                action_type=ActionType.SCAN_DIRECTORY,\n                description=\"Scan repository for documentation files\",\n                parameters={'directory': '.', 'max_depth': 3},\n                expected_outcome=\"Find documentation files and directory structure\"\n            )\n\n        # Find documentation files if not found yet\n        if not self.found_docs and iteration &lt;= 4:\n            return ReActAction(\n                action_type=ActionType.LIST_FILES,\n                description=\"List files to find documentation\",\n                parameters={'pattern': '.md', 'directory': '.'},\n                expected_outcome=\"Identify markdown and documentation files\"\n            )\n\n        # Read high-priority documentation files\n        if self.found_docs and not self.analyzed_docs:\n            # Prioritize README files\n            readme_files = [f for f in self.found_docs if 'readme' in f.lower()]\n            if readme_files:\n                return ReActAction(\n                    action_type=ActionType.READ_FILE,\n                    description=f\"Read README file: {readme_files[0]}\",\n                    parameters={'file_path': readme_files[0], 'max_lines': 200},\n                    expected_outcome=\"Understand project overview and main documentation\"\n                )\n            else:\n                return ReActAction(\n                    action_type=ActionType.READ_FILE,\n                    description=f\"Read documentation file: {self.found_docs[0]}\",\n                    parameters={'file_path': self.found_docs[0], 'max_lines': 200},\n                    expected_outcome=\"Understand documentation content\"\n                )\n\n        # Search for specific patterns related to the goal\n        if \"api\" in self.state.goal.lower():\n            return ReActAction(\n                action_type=ActionType.SEARCH_FILES,\n                description=\"Search for API documentation patterns\",\n                parameters={'pattern': 'api', 'file_types': ['.md', '.rst', '.txt'], 'max_results': 10},\n                expected_outcome=\"Find API-related documentation\"\n            )\n\n        elif \"architecture\" in self.state.goal.lower():\n            return ReActAction(\n                action_type=ActionType.SEARCH_FILES,\n                description=\"Search for architecture documentation\",\n                parameters={'pattern': 'architecture', 'file_types': ['.md', '.rst', '.txt'], 'max_results': 10},\n                expected_outcome=\"Find architecture documentation\"\n            )\n\n        elif \"install\" in self.state.goal.lower() or \"setup\" in self.state.goal.lower():\n            return ReActAction(\n                action_type=ActionType.SEARCH_FILES,\n                description=\"Search for installation/setup documentation\",\n                parameters={'pattern': 'install', 'file_types': ['.md', '.rst', '.txt'], 'max_results': 10},\n                expected_outcome=\"Find installation and setup instructions\"\n            )\n\n        # Default: Use LLM reasoning to determine next step\n        return ReActAction(\n            action_type=ActionType.LLM_REASONING,\n            description=\"Use LLM to determine next documentation analysis step\",\n            parameters={\n                'context': str(self.state.current_context),\n                'question': f\"What should I analyze next for: {self.state.goal}?\"\n            },\n            expected_outcome=\"Get guidance on next analysis step\"\n        )\n\n    def observe(self, observation):\n        \"\"\"\n        Enhanced observation phase for documentation analysis.\n\n        Args:\n            observation: Observation from the action\n        \"\"\"\n        super().observe(observation)\n\n        # Process documentation-specific observations\n        if observation.success and observation.result:\n            result = observation.result\n\n            # If we scanned a directory, extract documentation files\n            if isinstance(result, dict) and 'contents' in result:\n                for item in result['contents']:\n                    if not item['is_directory'] and self._is_documentation_file(item['path']):\n                        if item['path'] not in self.found_docs:\n                            self.found_docs.append(item['path'])\n                            self.logger.info(f\"\ud83d\udcc4 Found documentation: {item['path']}\")\n\n            # If we listed files, filter for documentation\n            elif isinstance(result, dict) and 'files' in result:\n                for file_info in result['files']:\n                    if self._is_documentation_file(file_info['path']):\n                        if file_info['path'] not in self.found_docs:\n                            self.found_docs.append(file_info['path'])\n                            self.logger.info(f\"\ud83d\udcc4 Found documentation: {file_info['path']}\")\n\n            # If we read a file, analyze its content\n            elif isinstance(result, dict) and 'content' in result:\n                file_path = result['file_path']\n                content = result['content']\n\n                # Analyze the documentation content\n                analysis = self._analyze_documentation_content(file_path, content)\n                self.analyzed_docs[file_path] = analysis\n\n                # Extract key insights\n                insights = self._extract_insights(file_path, content, analysis)\n                self.documentation_insights.extend(insights)\n\n                self.logger.info(f\"\ud83d\udccb Analyzed documentation: {file_path}\")\n\n            # If we searched files, process the results\n            elif isinstance(result, dict) and 'results' in result:\n                for search_result in result['results']:\n                    file_path = search_result['file_path']\n                    if file_path not in self.found_docs:\n                        self.found_docs.append(file_path)\n                        self.logger.info(f\"\ud83d\udd0d Found through search: {file_path}\")\n\n    def _is_documentation_file(self, file_path: str) -&gt; bool:\n        \"\"\"Check if a file is likely documentation.\"\"\"\n        path_lower = file_path.lower()\n\n        # Check against known documentation patterns\n        for doc_type, patterns in self.doc_patterns.items():\n            for pattern in patterns:\n                if pattern.lower() in path_lower:\n                    return True\n\n        # Check file extensions\n        doc_extensions = ['.md', '.rst', '.txt', '.adoc', '.wiki']\n        if any(path_lower.endswith(ext) for ext in doc_extensions):\n            return True\n\n        # Check for documentation keywords in path\n        doc_keywords = ['doc', 'readme', 'manual', 'guide', 'help']\n        if any(keyword in path_lower for keyword in doc_keywords):\n            return True\n\n        return False\n\n    def _analyze_documentation_content(self, file_path: str, content: str) -&gt; Dict[str, Any]:\n        \"\"\"Analyze documentation content and extract structure.\"\"\"\n        lines = content.split('\\n')\n\n        # Extract headings\n        headings = []\n        for i, line in enumerate(lines):\n            if line.strip().startswith('#'):\n                level = len(line) - len(line.lstrip('#'))\n                title = line.strip('#').strip()\n                headings.append({\n                    'level': level,\n                    'title': title,\n                    'line_num': i + 1\n                })\n\n        # Classify content type\n        content_type = self._classify_documentation_type(file_path, content)\n\n        # Extract code blocks\n        code_blocks = re.findall(r'```(\\\\w+)?\\\\s*(.*?)```', content, re.DOTALL)\n\n        # Extract links\n        links = re.findall(r'\\\\[(.*?)\\\\]\\\\((.*?)\\\\)', content)\n\n        # Calculate metrics\n        word_count = len(content.split())\n        line_count = len(lines)\n\n        return {\n            'file_path': file_path,\n            'content_type': content_type,\n            'headings': headings,\n            'code_blocks': len(code_blocks),\n            'links': links,\n            'word_count': word_count,\n            'line_count': line_count,\n            'has_installation': 'install' in content.lower(),\n            'has_usage': 'usage' in content.lower() or 'example' in content.lower(),\n            'has_api': 'api' in content.lower(),\n            'has_architecture': 'architecture' in content.lower() or 'design' in content.lower()\n        }\n\n    def _classify_documentation_type(self, file_path: str, content: str) -&gt; str:\n        \"\"\"Classify the type of documentation.\"\"\"\n        path_lower = file_path.lower()\n        content_lower = content.lower()\n\n        if 'readme' in path_lower:\n            return 'readme'\n        elif 'api' in path_lower or 'api' in content_lower:\n            return 'api'\n        elif 'architecture' in path_lower or 'architecture' in content_lower:\n            return 'architecture'\n        elif 'install' in path_lower or 'setup' in content_lower:\n            return 'installation'\n        elif 'usage' in path_lower or 'example' in content_lower:\n            return 'usage'\n        elif 'contributing' in path_lower:\n            return 'contributing'\n        elif 'changelog' in path_lower:\n            return 'changelog'\n        elif 'license' in path_lower:\n            return 'license'\n        else:\n            return 'general'\n\n    def _extract_insights(self, file_path: str, content: str, analysis: Dict[str, Any]) -&gt; List[Dict[str, Any]]:\n        \"\"\"Extract key insights from documentation content.\"\"\"\n        insights = []\n\n        # Insight about content type\n        insights.append({\n            'type': 'content_classification',\n            'content': f\"This is {analysis['content_type']} documentation\",\n            'confidence': 0.9,\n            'source': file_path\n        })\n\n        # Insight about structure\n        if analysis['headings']:\n            insights.append({\n                'type': 'structure',\n                'content': f\"Well-structured with {len(analysis['headings'])} sections\",\n                'confidence': 0.8,\n                'source': file_path\n            })\n\n        # Insight about technical content\n        if analysis['code_blocks'] &gt; 0:\n            insights.append({\n                'type': 'technical_content',\n                'content': f\"Contains {analysis['code_blocks']} code examples\",\n                'confidence': 0.9,\n                'source': file_path\n            })\n\n        # Insight about completeness\n        completeness_score = 0\n        if analysis['has_installation']: completeness_score += 1\n        if analysis['has_usage']: completeness_score += 1\n        if analysis['has_api']: completeness_score += 1\n        if analysis['has_architecture']: completeness_score += 1\n\n        insights.append({\n            'type': 'completeness',\n            'content': f\"Documentation completeness score: {completeness_score}/4\",\n            'confidence': 0.7,\n            'source': file_path\n        })\n\n        return insights\n\n    def _generate_summary(self) -&gt; str:\n        \"\"\"Generate a comprehensive summary of documentation analysis.\"\"\"\n        if not self.found_docs:\n            return \"No documentation files found in the repository.\"\n\n        summary = f\"Documentation Analysis Summary:\\\\n\"\n        summary += f\"\u2022 Found {len(self.found_docs)} documentation files\\\\n\"\n        summary += f\"\u2022 Analyzed {len(self.analyzed_docs)} files in detail\\\\n\"\n        summary += f\"\u2022 Generated {len(self.documentation_insights)} insights\\\\n\"\n\n        # Summarize by type\n        if self.analyzed_docs:\n            types = [analysis['content_type'] for analysis in self.analyzed_docs.values()]\n            type_counts = {t: types.count(t) for t in set(types)}\n            summary += f\"\u2022 Document types: {', '.join(f'{t}({c})' for t, c in type_counts.items())}\\\\n\"\n\n        # Key findings\n        key_findings = []\n        for insight in self.documentation_insights:\n            if insight['confidence'] &gt; 0.8:\n                key_findings.append(insight['content'])\n\n        if key_findings:\n            summary += f\"\u2022 Key findings: {'; '.join(key_findings[:3])}\\\\n\"\n\n        # Cache performance\n        if self.state.cache_hits &gt; 0:\n            summary += f\"\u2022 Cache hits: {self.state.cache_hits}\\\\n\"\n\n        if self.state.error_count &gt; 0:\n            summary += f\"\u2022 Errors encountered: {self.state.error_count}\\\\n\"\n\n        return summary\n\n    def get_documentation_insights(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"Get all documentation insights.\"\"\"\n        return self.documentation_insights\n\n    def get_analyzed_docs(self) -&gt; Dict[str, Any]:\n        \"\"\"Get all analyzed documentation.\"\"\"\n        return self.analyzed_docs\n\n    def get_found_docs(self) -&gt; List[str]:\n        \"\"\"Get list of found documentation files.\"\"\"\n        return self.found_docs\n</code></pre> <p>The Documentation Agent specializes in analyzing and understanding various forms of project documentation using the ReAct pattern.</p>"},{"location":"api/documentation-agent/#cf.agents.react_documentation_agent.ReActDocumentationAgent.get_analyzed_docs","title":"<code>get_analyzed_docs()</code>","text":"<p>Get all analyzed documentation.</p> Source code in <code>cf/agents/react_documentation_agent.py</code> <pre><code>def get_analyzed_docs(self) -&gt; Dict[str, Any]:\n    \"\"\"Get all analyzed documentation.\"\"\"\n    return self.analyzed_docs\n</code></pre>"},{"location":"api/documentation-agent/#cf.agents.react_documentation_agent.ReActDocumentationAgent.get_documentation_insights","title":"<code>get_documentation_insights()</code>","text":"<p>Get all documentation insights.</p> Source code in <code>cf/agents/react_documentation_agent.py</code> <pre><code>def get_documentation_insights(self) -&gt; List[Dict[str, Any]]:\n    \"\"\"Get all documentation insights.\"\"\"\n    return self.documentation_insights\n</code></pre>"},{"location":"api/documentation-agent/#cf.agents.react_documentation_agent.ReActDocumentationAgent.get_found_docs","title":"<code>get_found_docs()</code>","text":"<p>Get list of found documentation files.</p> Source code in <code>cf/agents/react_documentation_agent.py</code> <pre><code>def get_found_docs(self) -&gt; List[str]:\n    \"\"\"Get list of found documentation files.\"\"\"\n    return self.found_docs\n</code></pre>"},{"location":"api/documentation-agent/#cf.agents.react_documentation_agent.ReActDocumentationAgent.observe","title":"<code>observe(observation)</code>","text":"<p>Enhanced observation phase for documentation analysis.</p> <p>Parameters:</p> Name Type Description Default <code>observation</code> <p>Observation from the action</p> required Source code in <code>cf/agents/react_documentation_agent.py</code> <pre><code>def observe(self, observation):\n    \"\"\"\n    Enhanced observation phase for documentation analysis.\n\n    Args:\n        observation: Observation from the action\n    \"\"\"\n    super().observe(observation)\n\n    # Process documentation-specific observations\n    if observation.success and observation.result:\n        result = observation.result\n\n        # If we scanned a directory, extract documentation files\n        if isinstance(result, dict) and 'contents' in result:\n            for item in result['contents']:\n                if not item['is_directory'] and self._is_documentation_file(item['path']):\n                    if item['path'] not in self.found_docs:\n                        self.found_docs.append(item['path'])\n                        self.logger.info(f\"\ud83d\udcc4 Found documentation: {item['path']}\")\n\n        # If we listed files, filter for documentation\n        elif isinstance(result, dict) and 'files' in result:\n            for file_info in result['files']:\n                if self._is_documentation_file(file_info['path']):\n                    if file_info['path'] not in self.found_docs:\n                        self.found_docs.append(file_info['path'])\n                        self.logger.info(f\"\ud83d\udcc4 Found documentation: {file_info['path']}\")\n\n        # If we read a file, analyze its content\n        elif isinstance(result, dict) and 'content' in result:\n            file_path = result['file_path']\n            content = result['content']\n\n            # Analyze the documentation content\n            analysis = self._analyze_documentation_content(file_path, content)\n            self.analyzed_docs[file_path] = analysis\n\n            # Extract key insights\n            insights = self._extract_insights(file_path, content, analysis)\n            self.documentation_insights.extend(insights)\n\n            self.logger.info(f\"\ud83d\udccb Analyzed documentation: {file_path}\")\n\n        # If we searched files, process the results\n        elif isinstance(result, dict) and 'results' in result:\n            for search_result in result['results']:\n                file_path = search_result['file_path']\n                if file_path not in self.found_docs:\n                    self.found_docs.append(file_path)\n                    self.logger.info(f\"\ud83d\udd0d Found through search: {file_path}\")\n</code></pre>"},{"location":"api/documentation-agent/#cf.agents.react_documentation_agent.ReActDocumentationAgent.plan_action","title":"<code>plan_action(reasoning)</code>","text":"<p>Plan the next action based on reasoning.</p> <p>Parameters:</p> Name Type Description Default <code>reasoning</code> <code>str</code> <p>The reasoning output</p> required <p>Returns:</p> Type Description <code>ReActAction</code> <p>Action to take</p> Source code in <code>cf/agents/react_documentation_agent.py</code> <pre><code>def plan_action(self, reasoning: str) -&gt; ReActAction:\n    \"\"\"\n    Plan the next action based on reasoning.\n\n    Args:\n        reasoning: The reasoning output\n\n    Returns:\n        Action to take\n    \"\"\"\n    iteration = self.state.iteration\n\n    # Early iterations: Directory scanning and file discovery\n    if iteration &lt;= 2:\n        return ReActAction(\n            action_type=ActionType.SCAN_DIRECTORY,\n            description=\"Scan repository for documentation files\",\n            parameters={'directory': '.', 'max_depth': 3},\n            expected_outcome=\"Find documentation files and directory structure\"\n        )\n\n    # Find documentation files if not found yet\n    if not self.found_docs and iteration &lt;= 4:\n        return ReActAction(\n            action_type=ActionType.LIST_FILES,\n            description=\"List files to find documentation\",\n            parameters={'pattern': '.md', 'directory': '.'},\n            expected_outcome=\"Identify markdown and documentation files\"\n        )\n\n    # Read high-priority documentation files\n    if self.found_docs and not self.analyzed_docs:\n        # Prioritize README files\n        readme_files = [f for f in self.found_docs if 'readme' in f.lower()]\n        if readme_files:\n            return ReActAction(\n                action_type=ActionType.READ_FILE,\n                description=f\"Read README file: {readme_files[0]}\",\n                parameters={'file_path': readme_files[0], 'max_lines': 200},\n                expected_outcome=\"Understand project overview and main documentation\"\n            )\n        else:\n            return ReActAction(\n                action_type=ActionType.READ_FILE,\n                description=f\"Read documentation file: {self.found_docs[0]}\",\n                parameters={'file_path': self.found_docs[0], 'max_lines': 200},\n                expected_outcome=\"Understand documentation content\"\n            )\n\n    # Search for specific patterns related to the goal\n    if \"api\" in self.state.goal.lower():\n        return ReActAction(\n            action_type=ActionType.SEARCH_FILES,\n            description=\"Search for API documentation patterns\",\n            parameters={'pattern': 'api', 'file_types': ['.md', '.rst', '.txt'], 'max_results': 10},\n            expected_outcome=\"Find API-related documentation\"\n        )\n\n    elif \"architecture\" in self.state.goal.lower():\n        return ReActAction(\n            action_type=ActionType.SEARCH_FILES,\n            description=\"Search for architecture documentation\",\n            parameters={'pattern': 'architecture', 'file_types': ['.md', '.rst', '.txt'], 'max_results': 10},\n            expected_outcome=\"Find architecture documentation\"\n        )\n\n    elif \"install\" in self.state.goal.lower() or \"setup\" in self.state.goal.lower():\n        return ReActAction(\n            action_type=ActionType.SEARCH_FILES,\n            description=\"Search for installation/setup documentation\",\n            parameters={'pattern': 'install', 'file_types': ['.md', '.rst', '.txt'], 'max_results': 10},\n            expected_outcome=\"Find installation and setup instructions\"\n        )\n\n    # Default: Use LLM reasoning to determine next step\n    return ReActAction(\n        action_type=ActionType.LLM_REASONING,\n        description=\"Use LLM to determine next documentation analysis step\",\n        parameters={\n            'context': str(self.state.current_context),\n            'question': f\"What should I analyze next for: {self.state.goal}?\"\n        },\n        expected_outcome=\"Get guidance on next analysis step\"\n    )\n</code></pre>"},{"location":"api/documentation-agent/#cf.agents.react_documentation_agent.ReActDocumentationAgent.reason","title":"<code>reason()</code>","text":"<p>Reasoning phase: Determine what documentation action to take next.</p> <p>Returns:</p> Type Description <code>str</code> <p>Reasoning about next action to take</p> Source code in <code>cf/agents/react_documentation_agent.py</code> <pre><code>def reason(self) -&gt; str:\n    \"\"\"\n    Reasoning phase: Determine what documentation action to take next.\n\n    Returns:\n        Reasoning about next action to take\n    \"\"\"\n    current_context = self.state.current_context\n    iteration = self.state.iteration\n\n    # First iteration: Start with directory scan to find documentation\n    if iteration == 1:\n        return \"I should start by scanning the repository structure to identify documentation files. This will give me an overview of what documentation exists.\"\n\n    # If we haven't found documentation files yet, scan more thoroughly\n    if not self.found_docs and iteration &lt;= 3:\n        return \"I haven't found documentation files yet. Let me scan more directories and look for common documentation patterns.\"\n\n    # If we have documentation files but haven't analyzed them\n    if self.found_docs and not self.analyzed_docs:\n        return f\"I found {len(self.found_docs)} documentation files. Now I should read and analyze the most important ones, starting with README files.\"\n\n    # If we have some analysis but need more depth\n    if self.analyzed_docs and len(self.analyzed_docs) &lt; 3:\n        return \"I've analyzed some documentation but need to dive deeper. Let me search for specific patterns and sections relevant to the goal.\"\n\n    # If we have good coverage, focus on synthesis\n    if len(self.analyzed_docs) &gt;= 3:\n        return \"I have analyzed multiple documentation files. Now I should synthesize the information and look for specific details related to the goal.\"\n\n    # Default reasoning\n    return \"I should continue analyzing documentation systematically, focusing on files that are most relevant to the goal.\"\n</code></pre>"},{"location":"api/documentation-agent/#cf.agents.react_documentation_agent.ReActDocumentationAgent.scan_documentation","title":"<code>scan_documentation(description)</code>","text":"<p>Main entry point for documentation scanning using ReAct pattern.</p> <p>Parameters:</p> Name Type Description Default <code>description</code> <code>str</code> <p>Description of what to focus on during scanning</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Comprehensive documentation analysis results</p> Source code in <code>cf/agents/react_documentation_agent.py</code> <pre><code>def scan_documentation(self, description: str) -&gt; Dict[str, Any]:\n    \"\"\"\n    Main entry point for documentation scanning using ReAct pattern.\n\n    Args:\n        description: Description of what to focus on during scanning\n\n    Returns:\n        Comprehensive documentation analysis results\n    \"\"\"\n    goal = f\"Analyze documentation for: {description}\"\n    return self.execute_react_loop(goal, max_iterations=15)\n</code></pre>"},{"location":"api/documentation-agent/#overview","title":"Overview","text":"<p>The Documentation Agent excels at:</p> <ul> <li>Scanning and identifying documentation files</li> <li>Analyzing README files, guides, and manuals</li> <li>Extracting API documentation patterns</li> <li>Understanding project structure from docs</li> <li>Cross-referencing documentation consistency</li> </ul>"},{"location":"api/documentation-agent/#usage-examples","title":"Usage Examples","text":""},{"location":"api/documentation-agent/#basic-documentation-analysis","title":"Basic Documentation Analysis","text":"<pre><code>from cf.agents.react_documentation_agent import ReActDocumentationAgent\nfrom cf.aci.repo import LocalCodeRepo\nfrom cf.config import CfConfig\n\n# Initialize agent\nrepo = LocalCodeRepo(\"/path/to/repository\")\nconfig = CfConfig()\ndoc_agent = ReActDocumentationAgent(repo, config)\n\n# Analyze documentation\nresults = doc_agent.scan_documentation(\"comprehensive documentation review\")\n\nprint(f\"Documentation files found: {len(results.get('documentation_files', []))}\")\nprint(f\"Analysis summary: {results.get('summary')}\")\n</code></pre>"},{"location":"api/documentation-agent/#focused-documentation-types","title":"Focused Documentation Types","text":"<pre><code># API documentation analysis\napi_docs = doc_agent.scan_documentation(\"API documentation and endpoints\")\n\n# Setup and installation guides\nsetup_docs = doc_agent.scan_documentation(\"installation and setup documentation\")\n\n# Architecture documentation\narch_docs = doc_agent.scan_documentation(\"system architecture and design documentation\")\n</code></pre>"},{"location":"api/documentation-agent/#key-features","title":"Key Features","text":""},{"location":"api/documentation-agent/#document-type-detection","title":"Document Type Detection","text":"<p>The agent automatically identifies various documentation types:</p> <ul> <li>README files: Project overviews and quick starts</li> <li>API Documentation: Endpoint descriptions and usage</li> <li>Guides: Step-by-step instructions</li> <li>Reference: Technical specifications</li> <li>Examples: Code samples and tutorials</li> </ul>"},{"location":"api/documentation-agent/#content-analysis","title":"Content Analysis","text":"<pre><code># Access detailed analysis results\nresults = doc_agent.scan_documentation(\"complete documentation audit\")\n\nanalyzed_docs = doc_agent.get_analyzed_documentation()\nfor file_path, analysis in analyzed_docs.items():\n    print(f\"File: {file_path}\")\n    print(f\"Type: {analysis.get('doc_type')}\")\n    print(f\"Quality Score: {analysis.get('quality_score')}\")\n    print(f\"Key Sections: {analysis.get('sections')}\")\n    print(\"---\")\n</code></pre>"},{"location":"api/documentation-agent/#documentation-quality-assessment","title":"Documentation Quality Assessment","text":"<pre><code># Get quality insights\nquality_assessment = doc_agent.get_documentation_quality()\n\nprint(f\"Overall Quality: {quality_assessment.get('overall_score')}\")\nprint(f\"Completeness: {quality_assessment.get('completeness')}\")\nprint(f\"Structure: {quality_assessment.get('structure_score')}\")\nprint(f\"Recommendations: {quality_assessment.get('recommendations')}\")\n</code></pre>"},{"location":"api/documentation-agent/#integration-examples","title":"Integration Examples","text":""},{"location":"api/documentation-agent/#with-supervisor-agent","title":"With Supervisor Agent","text":"<pre><code>from cf.agents.react_supervisor_agent import ReActSupervisorAgent\n\nsupervisor = ReActSupervisorAgent(repo, config)\n\n# Documentation-focused analysis\nresults = supervisor.explore_repository(\n    goal=\"evaluate documentation quality and coverage\",\n    focus=\"docs\"\n)\n\n# Access documentation agent results\ndoc_results = supervisor.get_agent_results()['documentation']\n</code></pre>"},{"location":"api/documentation-agent/#custom-documentation-workflows","title":"Custom Documentation Workflows","text":"<pre><code>def documentation_audit_workflow(repo_path: str) -&gt; Dict[str, Any]:\n    \"\"\"Comprehensive documentation audit workflow.\"\"\"\n    repo = LocalCodeRepo(repo_path)\n    config = CfConfig()\n    doc_agent = ReActDocumentationAgent(repo, config)\n\n    # Phase 1: Discovery\n    discovery = doc_agent.scan_documentation(\"discover all documentation\")\n\n    # Phase 2: Quality Analysis\n    quality = doc_agent.scan_documentation(\"assess documentation quality\")\n\n    # Phase 3: Completeness Check\n    completeness = doc_agent.scan_documentation(\"check documentation completeness\")\n\n    return {\n        'discovery': discovery,\n        'quality': quality,\n        'completeness': completeness,\n        'recommendations': generate_doc_recommendations(doc_agent)\n    }\n</code></pre>"},{"location":"api/documentation-agent/#advanced-features","title":"Advanced Features","text":""},{"location":"api/documentation-agent/#custom-document-processing","title":"Custom Document Processing","text":"<pre><code>class CustomDocumentationAgent(ReActDocumentationAgent):\n    def __init__(self, repo, config):\n        super().__init__(repo, config)\n        self.custom_doc_types = {\n            'confluence': self._process_confluence_docs,\n            'wiki': self._process_wiki_docs,\n            'openapi': self._process_openapi_specs\n        }\n\n    def _process_confluence_docs(self, content: str) -&gt; Dict[str, Any]:\n        \"\"\"Process Confluence documentation.\"\"\"\n        # Custom processing logic\n        pass\n\n    def _process_wiki_docs(self, content: str) -&gt; Dict[str, Any]:\n        \"\"\"Process wiki documentation.\"\"\"\n        # Custom processing logic  \n        pass\n\n    def _process_openapi_specs(self, content: str) -&gt; Dict[str, Any]:\n        \"\"\"Process OpenAPI specifications.\"\"\"\n        # Custom processing logic\n        pass\n</code></pre>"},{"location":"api/documentation-agent/#documentation-metrics","title":"Documentation Metrics","text":"<pre><code># Get comprehensive metrics\nmetrics = doc_agent.get_documentation_metrics()\n\nprint(\"Documentation Metrics:\")\nprint(f\"  Total Files: {metrics.get('total_files')}\")\nprint(f\"  Coverage Score: {metrics.get('coverage_score')}\")\nprint(f\"  Average Quality: {metrics.get('average_quality')}\")\nprint(f\"  Missing Areas: {metrics.get('missing_areas')}\")\nprint(f\"  Improvement Suggestions: {metrics.get('suggestions')}\")\n</code></pre>"},{"location":"api/documentation-agent/#configuration-options","title":"Configuration Options","text":"<pre><code>from cf.core.react_config import ReActConfig\n\n# Documentation-specific configuration\ndoc_config = ReActConfig(\n    max_iterations=15,  # Sufficient for thorough doc analysis\n    iteration_timeout=30.0,\n    cache_enabled=True,\n    cache_max_size=500  # Docs are typically smaller\n)\n\ndoc_agent = ReActDocumentationAgent(\n    repo, \n    config, \n    react_config=doc_config\n)\n</code></pre>"},{"location":"api/llm/","title":"LLM Integration","text":"<p>The CodeFusion ReAct framework provides comprehensive Language Model integration for AI-powered reasoning and analysis.</p>"},{"location":"api/llm/#real-llm-provider","title":"Real LLM Provider","text":"<p>Real LLM interface using LiteLLM for unified provider access.</p> <p>Supports all major providers through LiteLLM: - OpenAI: \"gpt-3.5-turbo\", \"gpt-4\", etc. - Anthropic: \"claude-3-sonnet-20240229\", \"claude-3-opus-20240229\", etc. - LLaMA via Together AI: \"together_ai/meta-llama/Llama-2-7b-chat-hf\" - LLaMA via Replicate: \"replicate/meta/llama-2-7b-chat\" - LLaMA via Ollama: \"ollama/llama2\" - And many more</p> Source code in <code>cf/llm/real_llm.py</code> <pre><code>class RealLLM:\n    \"\"\"\n    Real LLM interface using LiteLLM for unified provider access.\n\n    Supports all major providers through LiteLLM:\n    - OpenAI: \"gpt-3.5-turbo\", \"gpt-4\", etc.\n    - Anthropic: \"claude-3-sonnet-20240229\", \"claude-3-opus-20240229\", etc.\n    - LLaMA via Together AI: \"together_ai/meta-llama/Llama-2-7b-chat-hf\"\n    - LLaMA via Replicate: \"replicate/meta/llama-2-7b-chat\"\n    - LLaMA via Ollama: \"ollama/llama2\"\n    - And many more\n    \"\"\"\n\n    def __init__(self, config: Optional[LLMConfig] = None):\n        self.config = config or self._load_config()\n        self.logger = logging.getLogger(self.__class__.__name__)\n\n        # Initialize LiteLLM\n        self.client = None\n        self._init_litellm()\n\n    def _load_config(self) -&gt; LLMConfig:\n        \"\"\"Load LLM configuration from environment variables.\"\"\"\n        model = os.getenv('CF_LLM_MODEL', 'gpt-3.5-turbo')\n        api_key = os.getenv('CF_LLM_API_KEY', '')\n        api_base = os.getenv('CF_LLM_API_BASE', '')\n\n        # Set provider-specific environment variables for LiteLLM\n        if api_key:\n            if 'gpt' in model or 'openai' in model:\n                os.environ['OPENAI_API_KEY'] = api_key\n            elif 'claude' in model or 'anthropic' in model:\n                os.environ['ANTHROPIC_API_KEY'] = api_key\n            elif 'together_ai' in model:\n                os.environ['TOGETHER_AI_API_KEY'] = api_key\n            elif 'replicate' in model:\n                os.environ['REPLICATE_API_TOKEN'] = api_key\n\n        return LLMConfig(\n            model=model,\n            api_key=api_key,\n            api_base=api_base,\n            max_tokens=int(os.getenv('CF_LLM_MAX_TOKENS', '1000')),\n            temperature=float(os.getenv('CF_LLM_TEMPERATURE', '0.7')),\n            timeout=int(os.getenv('CF_LLM_TIMEOUT', '30'))\n        )\n\n    def _init_litellm(self):\n        \"\"\"Initialize LiteLLM.\"\"\"\n        try:\n            import litellm\n\n            # Configure LiteLLM\n            if self.config.api_base:\n                litellm.api_base = self.config.api_base\n\n            # Set timeout\n            litellm.request_timeout = self.config.timeout\n\n            # Test the model only if API key is provided\n            if self.config.api_key:\n                try:\n                    test_response = litellm.completion(\n                        model=self.config.model,\n                        messages=[{\"role\": \"user\", \"content\": \"Hello\"}],\n                        max_tokens=10,\n                        temperature=0.1\n                    )\n                    self.client = litellm\n                    self.logger.info(f\"LiteLLM initialized successfully with model: {self.config.model}\")\n                except Exception as e:\n                    self.logger.warning(f\"LiteLLM test failed for model {self.config.model}: {e}\")\n                    self.client = None\n            else:\n                # Skip test if no API key provided, but still set up client for future use\n                self.client = litellm\n                self.logger.info(f\"LiteLLM configured for model {self.config.model} (no API key test)\")\n\n        except ImportError:\n            self.logger.error(\"LiteLLM package not installed. Install with: pip install litellm\")\n            self.client = None\n        except Exception as e:\n            self.logger.error(f\"Failed to initialize LiteLLM: {e}\")\n            self.client = None\n\n    def reasoning(self, context: str, question: str, agent_type: str = 'general') -&gt; Dict[str, Any]:\n        \"\"\"\n        Generate reasoning response using LiteLLM.\n\n        Args:\n            context: Current context/state\n            question: Question to reason about\n            agent_type: Type of agent requesting reasoning\n\n        Returns:\n            Reasoning response with suggested actions\n        \"\"\"\n        if not self.client:\n            return self._fallback_reasoning(context, question, agent_type)\n\n        try:\n            prompt = self._build_reasoning_prompt(context, question, agent_type)\n            response = self._call_llm(prompt)\n\n            # Parse the response\n            parsed_response = self._parse_reasoning_response(response)\n\n            return {\n                'reasoning': parsed_response.get('reasoning', response),\n                'confidence': parsed_response.get('confidence', 0.8),\n                'suggested_actions': parsed_response.get('suggested_actions', ['read_file', 'search_files']),\n                'context_analysis': parsed_response.get('context_analysis', {}),\n                'model_used': self.config.model,\n                'raw_response': response\n            }\n\n        except Exception as e:\n            self.logger.error(f\"LLM reasoning failed: {e}\")\n            return self._fallback_reasoning(context, question, agent_type)\n\n    def summarize(self, content: str, summary_type: str = 'general', focus: str = 'all') -&gt; Dict[str, Any]:\n        \"\"\"\n        Generate summary using LiteLLM.\n\n        Args:\n            content: Content to summarize\n            summary_type: Type of summary to generate\n            focus: Focus area for the summary\n\n        Returns:\n            Summary response\n        \"\"\"\n        if not self.client:\n            return self._fallback_summary(content, summary_type, focus)\n\n        try:\n            prompt = self._build_summary_prompt(content, summary_type, focus)\n            response = self._call_llm(prompt)\n\n            # Parse the response\n            parsed_response = self._parse_summary_response(response)\n\n            return {\n                'summary': parsed_response.get('summary', response),\n                'key_points': parsed_response.get('key_points', []),\n                'confidence': parsed_response.get('confidence', 0.7),\n                'focus': focus,\n                'content_analysis': parsed_response.get('content_analysis', {}),\n                'model_used': self.config.model,\n                'raw_response': response\n            }\n\n        except Exception as e:\n            self.logger.error(f\"LLM summarization failed: {e}\")\n            return self._fallback_summary(content, summary_type, focus)\n\n    def _call_llm(self, prompt: str) -&gt; str:\n        \"\"\"Make LLM API call using LiteLLM.\"\"\"\n        try:\n            response = self.client.completion(\n                model=self.config.model,\n                messages=[{\"role\": \"user\", \"content\": prompt}],\n                max_tokens=self.config.max_tokens,\n                temperature=self.config.temperature,\n                timeout=self.config.timeout\n            )\n            return response.choices[0].message.content\n\n        except Exception as e:\n            self.logger.error(f\"LiteLLM API call failed: {e}\")\n            raise\n\n    def _build_reasoning_prompt(self, context: str, question: str, agent_type: str) -&gt; str:\n        \"\"\"Build reasoning prompt for LLM.\"\"\"\n        # Check if this is a LLaMA model for special formatting\n        is_llama = any(llama_indicator in self.config.model.lower() \n                      for llama_indicator in ['llama', 'meta-llama'])\n\n        base_prompt = f\"\"\"You are a {agent_type} agent in a ReAct (Reasoning + Acting) framework analyzing a codebase. \n\nYour task is to reason about what action to take next based on the current context and goal.\n\nCONTEXT:\n{context}\n\nQUESTION/GOAL:\n{question}\n\nPlease provide your reasoning following this structure:\n1. REASONING: What should I do next and why?\n2. CONFIDENCE: How confident are you in this reasoning (0.0-1.0)?\n3. SUGGESTED_ACTIONS: List of 2-3 specific actions to take next\n4. CONTEXT_ANALYSIS: Key insights from the current context\n\nFormat your response as JSON with these keys: reasoning, confidence, suggested_actions, context_analysis.\n\nFocus on being systematic, thorough, and adaptive based on what you've learned so far.\"\"\"\n\n        if is_llama:\n            return f\"&lt;s&gt;[INST] {base_prompt} [/INST]\"\n        else:\n            return base_prompt\n\n    def _build_summary_prompt(self, content: str, summary_type: str, focus: str) -&gt; str:\n        \"\"\"Build summary prompt for LLM.\"\"\"\n        # Check if this is a LLaMA model for special formatting\n        is_llama = any(llama_indicator in self.config.model.lower() \n                      for llama_indicator in ['llama', 'meta-llama'])\n\n        base_prompt = f\"\"\"You are analyzing codebase content and need to generate a {summary_type} summary with focus on {focus}.\n\nCONTENT TO SUMMARIZE:\n{content}\n\nPlease provide a comprehensive summary following this structure:\n1. SUMMARY: Clear, concise summary of the key findings\n2. KEY_POINTS: List of 3-5 most important points\n3. CONFIDENCE: How confident are you in this summary (0.0-1.0)?\n4. CONTENT_ANALYSIS: Additional insights about the content\n\nFormat your response as JSON with these keys: summary, key_points, confidence, content_analysis.\n\nFocus on extracting the most valuable insights and presenting them clearly.\"\"\"\n\n        if is_llama:\n            return f\"&lt;s&gt;[INST] {base_prompt} [/INST]\"\n        else:\n            return base_prompt\n\n    def _parse_reasoning_response(self, response: str) -&gt; Dict[str, Any]:\n        \"\"\"Parse reasoning response from LLM.\"\"\"\n        try:\n            # Clean response\n            response = response.strip()\n\n            # Remove markdown code blocks if present\n            if response.startswith('```json'):\n                response = response[7:]\n            if response.endswith('```'):\n                response = response[:-3]\n\n            # Try to parse as JSON first\n            if response.strip().startswith('{'):\n                return json.loads(response)\n\n            # If not JSON, extract key information with more robust parsing\n            result = {}\n            lines = response.split('\\n')\n\n            for i, line in enumerate(lines):\n                line = line.strip()\n                if line.startswith('1. REASONING:') or line.startswith('REASONING:'):\n                    reasoning_text = line.split('REASONING:', 1)[1].strip()\n                    # Look for additional lines that might be part of reasoning\n                    for j in range(i+1, len(lines)):\n                        next_line = lines[j].strip()\n                        if next_line.startswith('2.') or next_line.startswith('CONFIDENCE:'):\n                            break\n                        reasoning_text += \" \" + next_line\n                    result['reasoning'] = reasoning_text\n\n                elif line.startswith('2. CONFIDENCE:') or line.startswith('CONFIDENCE:'):\n                    confidence_text = line.split('CONFIDENCE:', 1)[1].strip()\n                    try:\n                        # Extract number from text like \"0.8\" or \"80%\" or \"8/10\"\n                        import re\n                        numbers = re.findall(r'0\\.\\d+|\\d+%|\\d+/10', confidence_text)\n                        if numbers:\n                            conf_str = numbers[0]\n                            if '%' in conf_str:\n                                result['confidence'] = float(conf_str.replace('%', '')) / 100\n                            elif '/' in conf_str:\n                                parts = conf_str.split('/')\n                                result['confidence'] = float(parts[0]) / float(parts[1])\n                            else:\n                                result['confidence'] = float(conf_str)\n                    except ValueError:\n                        result['confidence'] = 0.8\n\n                elif line.startswith('3. SUGGESTED_ACTIONS:') or line.startswith('SUGGESTED_ACTIONS:'):\n                    actions_text = line.split('SUGGESTED_ACTIONS:', 1)[1].strip()\n                    # Parse actions from text\n                    actions = [a.strip() for a in actions_text.split(',')]\n                    # Clean up actions\n                    cleaned_actions = []\n                    for action in actions:\n                        action = action.strip('- ').strip()\n                        if action:\n                            cleaned_actions.append(action)\n                    result['suggested_actions'] = cleaned_actions\n\n            # Set defaults if not found\n            if 'reasoning' not in result:\n                result['reasoning'] = response\n            if 'confidence' not in result:\n                result['confidence'] = 0.8\n            if 'suggested_actions' not in result:\n                result['suggested_actions'] = ['read_file', 'search_files']\n\n            return result\n\n        except Exception as e:\n            self.logger.error(f\"Failed to parse reasoning response: {e}\")\n            return {\n                'reasoning': response, \n                'confidence': 0.5, \n                'suggested_actions': ['read_file'],\n                'parsing_error': str(e)\n            }\n\n    def _parse_summary_response(self, response: str) -&gt; Dict[str, Any]:\n        \"\"\"Parse summary response from LLM.\"\"\"\n        try:\n            # Clean response\n            response = response.strip()\n\n            # Remove markdown code blocks if present\n            if response.startswith('```json'):\n                response = response[7:]\n            if response.endswith('```'):\n                response = response[:-3]\n\n            # Try to parse as JSON first\n            if response.strip().startswith('{'):\n                return json.loads(response)\n\n            # If not JSON, extract key information\n            result = {}\n            lines = response.split('\\n')\n\n            for i, line in enumerate(lines):\n                line = line.strip()\n                if line.startswith('1. SUMMARY:') or line.startswith('SUMMARY:'):\n                    summary_text = line.split('SUMMARY:', 1)[1].strip()\n                    # Look for additional lines that might be part of summary\n                    for j in range(i+1, len(lines)):\n                        next_line = lines[j].strip()\n                        if next_line.startswith('2.') or next_line.startswith('KEY_POINTS:'):\n                            break\n                        summary_text += \" \" + next_line\n                    result['summary'] = summary_text\n\n                elif line.startswith('2. KEY_POINTS:') or line.startswith('KEY_POINTS:'):\n                    points_text = line.split('KEY_POINTS:', 1)[1].strip()\n                    # Parse key points\n                    points = []\n                    if points_text:\n                        points.append(points_text)\n                    # Look for additional bullet points\n                    for j in range(i+1, len(lines)):\n                        next_line = lines[j].strip()\n                        if next_line.startswith('3.') or next_line.startswith('CONFIDENCE:'):\n                            break\n                        if next_line.startswith('-') or next_line.startswith('\u2022'):\n                            points.append(next_line.strip('- \u2022').strip())\n                    result['key_points'] = points\n\n                elif line.startswith('3. CONFIDENCE:') or line.startswith('CONFIDENCE:'):\n                    confidence_text = line.split('CONFIDENCE:', 1)[1].strip()\n                    try:\n                        import re\n                        numbers = re.findall(r'0\\.\\d+|\\d+%|\\d+/10', confidence_text)\n                        if numbers:\n                            conf_str = numbers[0]\n                            if '%' in conf_str:\n                                result['confidence'] = float(conf_str.replace('%', '')) / 100\n                            elif '/' in conf_str:\n                                parts = conf_str.split('/')\n                                result['confidence'] = float(parts[0]) / float(parts[1])\n                            else:\n                                result['confidence'] = float(conf_str)\n                    except ValueError:\n                        result['confidence'] = 0.7\n\n            # Set defaults if not found\n            if 'summary' not in result:\n                result['summary'] = response\n            if 'key_points' not in result:\n                result['key_points'] = []\n            if 'confidence' not in result:\n                result['confidence'] = 0.7\n\n            return result\n\n        except Exception as e:\n            self.logger.error(f\"Failed to parse summary response: {e}\")\n            return {\n                'summary': response, \n                'key_points': [], \n                'confidence': 0.5,\n                'parsing_error': str(e)\n            }\n\n    def _fallback_reasoning(self, context: str, question: str, agent_type: str) -&gt; Dict[str, Any]:\n        \"\"\"Fallback reasoning when LLM is unavailable.\"\"\"\n        from .simple_llm import SimpleLLM\n        simple_llm = SimpleLLM()\n        result = simple_llm.reasoning(context, question, agent_type)\n        result['fallback'] = True\n        result['model_used'] = 'fallback'\n        return result\n\n    def _fallback_summary(self, content: str, summary_type: str, focus: str) -&gt; Dict[str, Any]:\n        \"\"\"Fallback summary when LLM is unavailable.\"\"\"\n        from .simple_llm import SimpleLLM\n        simple_llm = SimpleLLM()\n        result = simple_llm.summarize(content, summary_type, focus)\n        result['fallback'] = True\n        result['model_used'] = 'fallback'\n        return result\n\n    def get_supported_models(self) -&gt; Dict[str, List[str]]:\n        \"\"\"Get list of supported models by provider.\"\"\"\n        return {\n            'openai': [\n                'gpt-4',\n                'gpt-4-turbo',\n                'gpt-3.5-turbo',\n                'gpt-3.5-turbo-16k'\n            ],\n            'anthropic': [\n                'claude-3-opus-20240229',\n                'claude-3-sonnet-20240229', \n                'claude-3-haiku-20240307'\n            ],\n            'llama_together_ai': [\n                'together_ai/meta-llama/Llama-2-7b-chat-hf',\n                'together_ai/meta-llama/Llama-2-13b-chat-hf',\n                'together_ai/meta-llama/Llama-2-70b-chat-hf',\n                'together_ai/meta-llama/Code-Llama-7b-Python-hf',\n                'together_ai/meta-llama/Code-Llama-13b-Python-hf'\n            ],\n            'llama_replicate': [\n                'replicate/meta/llama-2-7b-chat',\n                'replicate/meta/llama-2-13b-chat',\n                'replicate/meta/llama-2-70b-chat',\n                'replicate/meta/code-llama-7b-python',\n                'replicate/meta/code-llama-13b-python'\n            ],\n            'llama_ollama': [\n                'ollama/llama2',\n                'ollama/llama2:7b',\n                'ollama/llama2:13b',\n                'ollama/codellama',\n                'ollama/codellama:7b'\n            ]\n        }\n</code></pre> <p>Configuration for LLM providers using LiteLLM.</p> Source code in <code>cf/llm/real_llm.py</code> <pre><code>@dataclass\nclass LLMConfig:\n    \"\"\"Configuration for LLM providers using LiteLLM.\"\"\"\n    model: str  # e.g., \"gpt-3.5-turbo\", \"claude-3-sonnet-20240229\", \"together_ai/meta-llama/Llama-2-7b-chat-hf\"\n    api_key: str = \"\"\n    api_base: str = \"\"  # For custom endpoints\n    max_tokens: int = 1000\n    temperature: float = 0.7\n    timeout: int = 30\n</code></pre>"},{"location":"api/llm/#cf.llm.real_llm.RealLLM.get_supported_models","title":"<code>get_supported_models()</code>","text":"<p>Get list of supported models by provider.</p> Source code in <code>cf/llm/real_llm.py</code> <pre><code>def get_supported_models(self) -&gt; Dict[str, List[str]]:\n    \"\"\"Get list of supported models by provider.\"\"\"\n    return {\n        'openai': [\n            'gpt-4',\n            'gpt-4-turbo',\n            'gpt-3.5-turbo',\n            'gpt-3.5-turbo-16k'\n        ],\n        'anthropic': [\n            'claude-3-opus-20240229',\n            'claude-3-sonnet-20240229', \n            'claude-3-haiku-20240307'\n        ],\n        'llama_together_ai': [\n            'together_ai/meta-llama/Llama-2-7b-chat-hf',\n            'together_ai/meta-llama/Llama-2-13b-chat-hf',\n            'together_ai/meta-llama/Llama-2-70b-chat-hf',\n            'together_ai/meta-llama/Code-Llama-7b-Python-hf',\n            'together_ai/meta-llama/Code-Llama-13b-Python-hf'\n        ],\n        'llama_replicate': [\n            'replicate/meta/llama-2-7b-chat',\n            'replicate/meta/llama-2-13b-chat',\n            'replicate/meta/llama-2-70b-chat',\n            'replicate/meta/code-llama-7b-python',\n            'replicate/meta/code-llama-13b-python'\n        ],\n        'llama_ollama': [\n            'ollama/llama2',\n            'ollama/llama2:7b',\n            'ollama/llama2:13b',\n            'ollama/codellama',\n            'ollama/codellama:7b'\n        ]\n    }\n</code></pre>"},{"location":"api/llm/#cf.llm.real_llm.RealLLM.reasoning","title":"<code>reasoning(context, question, agent_type='general')</code>","text":"<p>Generate reasoning response using LiteLLM.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>str</code> <p>Current context/state</p> required <code>question</code> <code>str</code> <p>Question to reason about</p> required <code>agent_type</code> <code>str</code> <p>Type of agent requesting reasoning</p> <code>'general'</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Reasoning response with suggested actions</p> Source code in <code>cf/llm/real_llm.py</code> <pre><code>def reasoning(self, context: str, question: str, agent_type: str = 'general') -&gt; Dict[str, Any]:\n    \"\"\"\n    Generate reasoning response using LiteLLM.\n\n    Args:\n        context: Current context/state\n        question: Question to reason about\n        agent_type: Type of agent requesting reasoning\n\n    Returns:\n        Reasoning response with suggested actions\n    \"\"\"\n    if not self.client:\n        return self._fallback_reasoning(context, question, agent_type)\n\n    try:\n        prompt = self._build_reasoning_prompt(context, question, agent_type)\n        response = self._call_llm(prompt)\n\n        # Parse the response\n        parsed_response = self._parse_reasoning_response(response)\n\n        return {\n            'reasoning': parsed_response.get('reasoning', response),\n            'confidence': parsed_response.get('confidence', 0.8),\n            'suggested_actions': parsed_response.get('suggested_actions', ['read_file', 'search_files']),\n            'context_analysis': parsed_response.get('context_analysis', {}),\n            'model_used': self.config.model,\n            'raw_response': response\n        }\n\n    except Exception as e:\n        self.logger.error(f\"LLM reasoning failed: {e}\")\n        return self._fallback_reasoning(context, question, agent_type)\n</code></pre>"},{"location":"api/llm/#cf.llm.real_llm.RealLLM.summarize","title":"<code>summarize(content, summary_type='general', focus='all')</code>","text":"<p>Generate summary using LiteLLM.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>Content to summarize</p> required <code>summary_type</code> <code>str</code> <p>Type of summary to generate</p> <code>'general'</code> <code>focus</code> <code>str</code> <p>Focus area for the summary</p> <code>'all'</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Summary response</p> Source code in <code>cf/llm/real_llm.py</code> <pre><code>def summarize(self, content: str, summary_type: str = 'general', focus: str = 'all') -&gt; Dict[str, Any]:\n    \"\"\"\n    Generate summary using LiteLLM.\n\n    Args:\n        content: Content to summarize\n        summary_type: Type of summary to generate\n        focus: Focus area for the summary\n\n    Returns:\n        Summary response\n    \"\"\"\n    if not self.client:\n        return self._fallback_summary(content, summary_type, focus)\n\n    try:\n        prompt = self._build_summary_prompt(content, summary_type, focus)\n        response = self._call_llm(prompt)\n\n        # Parse the response\n        parsed_response = self._parse_summary_response(response)\n\n        return {\n            'summary': parsed_response.get('summary', response),\n            'key_points': parsed_response.get('key_points', []),\n            'confidence': parsed_response.get('confidence', 0.7),\n            'focus': focus,\n            'content_analysis': parsed_response.get('content_analysis', {}),\n            'model_used': self.config.model,\n            'raw_response': response\n        }\n\n    except Exception as e:\n        self.logger.error(f\"LLM summarization failed: {e}\")\n        return self._fallback_summary(content, summary_type, focus)\n</code></pre>"},{"location":"api/llm/#overview","title":"Overview","text":"<p>The LLM integration supports multiple providers through LiteLLM:</p> <ul> <li>OpenAI: GPT-4, GPT-3.5-turbo, and other models</li> <li>Anthropic: Claude 3 Opus, Sonnet, and Haiku</li> <li>LLaMA: Via Together AI, Replicate, or Ollama</li> <li>Other Providers: 100+ models via LiteLLM</li> </ul>"},{"location":"api/llm/#basic-usage","title":"Basic Usage","text":""},{"location":"api/llm/#openai-integration","title":"OpenAI Integration","text":"<pre><code>from cf.llm.real_llm import RealLLM, LLMConfig\nimport os\n\n# Configure OpenAI\nos.environ['CF_LLM_MODEL'] = 'gpt-4'\nos.environ['CF_LLM_API_KEY'] = 'your-openai-api-key'\n\n# Initialize LLM\nllm = RealLLM()\n\n# Use for reasoning\nreasoning_result = llm.reasoning(\n    context=\"Current codebase analysis state\",\n    question=\"What should I examine next for security vulnerabilities?\",\n    agent_type=\"codebase\"\n)\n\nprint(f\"Reasoning: {reasoning_result['reasoning']}\")\nprint(f\"Confidence: {reasoning_result['confidence']}\")\nprint(f\"Suggested Actions: {reasoning_result['suggested_actions']}\")\n</code></pre>"},{"location":"api/llm/#anthropic-integration","title":"Anthropic Integration","text":"<pre><code># Configure Anthropic Claude\nos.environ['CF_LLM_MODEL'] = 'claude-3-sonnet-20240229'\nos.environ['CF_LLM_API_KEY'] = 'your-anthropic-api-key'\n\nllm = RealLLM()\n\n# Use for summarization\nsummary_result = llm.summarize(\n    content=\"Large codebase analysis results...\",\n    summary_type=\"comprehensive\",\n    focus=\"security patterns\"\n)\n\nprint(f\"Summary: {summary_result['summary']}\")\nprint(f\"Key Points: {summary_result['key_points']}\")\n</code></pre>"},{"location":"api/llm/#llama-integration","title":"LLaMA Integration","text":"<pre><code># Configure LLaMA via Together AI\nos.environ['CF_LLM_MODEL'] = 'together_ai/meta-llama/Llama-2-7b-chat-hf'\nos.environ['CF_LLM_API_KEY'] = 'your-together-ai-key'\n\nllm = RealLLM()\n\n# LLaMA models use special prompt formatting automatically\nresult = llm.reasoning(\n    context=\"Repository analysis context\",\n    question=\"Analyze the architectural patterns\",\n    agent_type=\"architecture\"\n)\n</code></pre>"},{"location":"api/llm/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"api/llm/#custom-llm-configuration","title":"Custom LLM Configuration","text":"<pre><code># Detailed configuration\nconfig = LLMConfig(\n    model=\"gpt-4\",\n    api_key=\"your-api-key\",\n    api_base=\"https://custom-endpoint.com/v1\",  # Optional custom endpoint\n    max_tokens=2000,\n    temperature=0.3,  # Lower for more focused analysis\n    timeout=60\n)\n\nllm = RealLLM(config)\n</code></pre>"},{"location":"api/llm/#environment-variable-configuration","title":"Environment Variable Configuration","text":"<pre><code># Set via environment variables\nimport os\n\n# Model selection\nos.environ['CF_LLM_MODEL'] = 'gpt-4'\nos.environ['CF_LLM_API_KEY'] = 'your-api-key'\n\n# Performance tuning\nos.environ['CF_LLM_MAX_TOKENS'] = '1500'\nos.environ['CF_LLM_TEMPERATURE'] = '0.2'\nos.environ['CF_LLM_TIMEOUT'] = '45'\n\n# Custom endpoint (optional)\nos.environ['CF_LLM_API_BASE'] = 'https://custom-api.com/v1'\n\nllm = RealLLM()  # Automatically loads from environment\n</code></pre>"},{"location":"api/llm/#supported-models","title":"Supported Models","text":""},{"location":"api/llm/#openai-models","title":"OpenAI Models","text":"<pre><code># Get available OpenAI models\nsupported_models = llm.get_supported_models()['openai']\nprint(\"OpenAI Models:\", supported_models)\n# ['gpt-4', 'gpt-4-turbo', 'gpt-3.5-turbo', 'gpt-3.5-turbo-16k']\n</code></pre>"},{"location":"api/llm/#anthropic-models","title":"Anthropic Models","text":"<pre><code># Claude models\nanthropic_models = llm.get_supported_models()['anthropic']\nprint(\"Anthropic Models:\", anthropic_models)\n# ['claude-3-opus-20240229', 'claude-3-sonnet-20240229', 'claude-3-haiku-20240307']\n</code></pre>"},{"location":"api/llm/#llama-models","title":"LLaMA Models","text":"<pre><code># LLaMA via different providers\ntogether_models = llm.get_supported_models()['llama_together_ai']\nreplicate_models = llm.get_supported_models()['llama_replicate']\nollama_models = llm.get_supported_models()['llama_ollama']\n</code></pre>"},{"location":"api/llm/#fallback-system","title":"Fallback System","text":""},{"location":"api/llm/#simple-llm-fallback","title":"Simple LLM Fallback","text":"<p>Simple LLM interface that provides mock responses for development.</p> <p>In production, this would be replaced with actual LLM API calls.</p> Source code in <code>cf/llm/simple_llm.py</code> <pre><code>class SimpleLLM:\n    \"\"\"\n    Simple LLM interface that provides mock responses for development.\n\n    In production, this would be replaced with actual LLM API calls.\n    \"\"\"\n\n    def __init__(self):\n        self.reasoning_templates = {\n            'documentation': [\n                \"Based on the documentation analysis, I should focus on {focus_area} to better understand {goal}.\",\n                \"The documentation shows {pattern}, which suggests I should investigate {next_action}.\",\n                \"From the current context, the most logical next step is to {action} because {reason}.\"\n            ],\n            'codebase': [\n                \"The code structure indicates {pattern}, so I should analyze {component} next.\",\n                \"Based on the {metric} complexity and {language} patterns, I should focus on {area}.\",\n                \"The codebase shows {insight}, which means I should investigate {next_focus}.\"\n            ],\n            'architecture': [\n                \"The architectural patterns suggest {pattern_type}, so I should analyze {component_type}.\",\n                \"Based on the system design, I should focus on {architectural_aspect} to understand {goal}.\",\n                \"The component relationships indicate {relationship}, suggesting I should examine {next_component}.\"\n            ]\n        }\n\n        self.summary_templates = {\n            'general': \"Analysis of {content_type} reveals {key_findings}. The main insights are: {insights}.\",\n            'cross_agent_synthesis': \"Combining insights from multiple agents: {synthesis}. Key correlations: {correlations}.\",\n            'final_comprehensive': \"Comprehensive analysis summary: {overview}. Critical findings: {critical_findings}.\"\n        }\n\n    def reasoning(self, context: str, question: str, agent_type: str = 'general') -&gt; Dict[str, Any]:\n        \"\"\"\n        Generate reasoning response for an agent.\n\n        Args:\n            context: Current context/state\n            question: Question to reason about\n            agent_type: Type of agent requesting reasoning\n\n        Returns:\n            Reasoning response with suggested actions\n        \"\"\"\n        # Extract key information from context\n        context_info = self._extract_context_info(context)\n\n        # Generate reasoning based on agent type\n        if agent_type in self.reasoning_templates:\n            template = random.choice(self.reasoning_templates[agent_type])\n            reasoning = template.format(\n                focus_area=context_info.get('focus_area', 'key components'),\n                goal=question,\n                pattern=context_info.get('pattern', 'interesting patterns'),\n                next_action=context_info.get('next_action', 'deeper analysis'),\n                action=context_info.get('action', 'explore further'),\n                reason=context_info.get('reason', 'it aligns with the goal'),\n                metric=context_info.get('metric', 'high'),\n                language=context_info.get('language', 'Python'),\n                area=context_info.get('area', 'core functionality'),\n                insight=context_info.get('insight', 'modular design'),\n                next_focus=context_info.get('next_focus', 'main components'),\n                pattern_type=context_info.get('pattern_type', 'layered architecture'),\n                component_type=context_info.get('component_type', 'service components'),\n                architectural_aspect=context_info.get('architectural_aspect', 'data flow'),\n                relationship=context_info.get('relationship', 'dependency patterns'),\n                next_component=context_info.get('next_component', 'core services')\n            )\n        else:\n            reasoning = f\"Based on the context and question '{question}', I should proceed with systematic analysis.\"\n\n        # Generate suggested actions\n        suggested_actions = self._generate_suggested_actions(context_info, agent_type)\n\n        return {\n            'reasoning': reasoning,\n            'confidence': random.uniform(0.7, 0.9),\n            'suggested_actions': suggested_actions,\n            'context_analysis': context_info\n        }\n\n    def summarize(self, content: str, summary_type: str = 'general', focus: str = 'all') -&gt; Dict[str, Any]:\n        \"\"\"\n        Generate summary from content.\n\n        Args:\n            content: Content to summarize\n            summary_type: Type of summary to generate\n            focus: Focus area for the summary\n\n        Returns:\n            Summary response\n        \"\"\"\n        # Extract key information from content\n        content_info = self._extract_content_info(content)\n\n        # Generate summary based on type\n        if summary_type in self.summary_templates:\n            template = self.summary_templates[summary_type]\n            summary = template.format(\n                content_type=content_info.get('content_type', 'analysis'),\n                key_findings=content_info.get('key_findings', 'multiple patterns and structures'),\n                insights=content_info.get('insights', 'system design principles'),\n                synthesis=content_info.get('synthesis', 'complementary findings across agents'),\n                correlations=content_info.get('correlations', 'consistent patterns'),\n                overview=content_info.get('overview', 'multi-faceted system analysis'),\n                critical_findings=content_info.get('critical_findings', 'architectural decisions')\n            )\n        else:\n            summary = f\"Summary of {summary_type}: {content_info.get('brief_summary', 'Key insights extracted from analysis.')}\"\n\n        # Generate key points\n        key_points = self._generate_key_points(content_info, focus)\n\n        return {\n            'summary': summary,\n            'key_points': key_points,\n            'confidence': random.uniform(0.6, 0.8),\n            'focus': focus,\n            'content_analysis': content_info\n        }\n\n    def _extract_context_info(self, context: str) -&gt; Dict[str, Any]:\n        \"\"\"Extract key information from context string.\"\"\"\n        context_lower = context.lower()\n\n        info = {\n            'focus_area': 'components',\n            'pattern': 'structured design',\n            'next_action': 'detailed analysis',\n            'action': 'investigate',\n            'reason': 'to understand the system better',\n            'metric': 'moderate',\n            'language': 'Python',\n            'area': 'core functionality',\n            'insight': 'modular architecture',\n            'next_focus': 'key components',\n            'pattern_type': 'layered',\n            'component_type': 'services',\n            'architectural_aspect': 'component relationships',\n            'relationship': 'dependencies',\n            'next_component': 'main services'\n        }\n\n        # Extract language information\n        if 'python' in context_lower:\n            info['language'] = 'Python'\n        elif 'javascript' in context_lower:\n            info['language'] = 'JavaScript'\n        elif 'java' in context_lower:\n            info['language'] = 'Java'\n\n        # Extract patterns\n        if 'api' in context_lower:\n            info['pattern'] = 'API design patterns'\n            info['focus_area'] = 'API endpoints'\n        elif 'database' in context_lower:\n            info['pattern'] = 'data access patterns'\n            info['focus_area'] = 'data models'\n        elif 'service' in context_lower:\n            info['pattern'] = 'service architecture'\n            info['focus_area'] = 'service boundaries'\n\n        return info\n\n    def _extract_content_info(self, content: str) -&gt; Dict[str, Any]:\n        \"\"\"Extract key information from content.\"\"\"\n        content_lower = content.lower()\n\n        info = {\n            'content_type': 'code analysis',\n            'key_findings': 'structured codebase with clear patterns',\n            'insights': 'well-organized architecture with good separation of concerns',\n            'synthesis': 'consistent findings across different analysis perspectives',\n            'correlations': 'alignment between documentation and implementation',\n            'overview': 'comprehensive system with multiple interconnected components',\n            'critical_findings': 'solid architectural foundation with room for optimization',\n            'brief_summary': 'Analysis reveals well-structured system with clear patterns.'\n        }\n\n        # Analyze content for specific patterns\n        if 'error' in content_lower:\n            info['key_findings'] = 'some issues encountered during analysis'\n            info['critical_findings'] = 'error handling needs attention'\n        elif 'documentation' in content_lower:\n            info['content_type'] = 'documentation analysis'\n            info['key_findings'] = 'comprehensive documentation with good coverage'\n        elif 'architecture' in content_lower:\n            info['content_type'] = 'architectural analysis'\n            info['key_findings'] = 'well-defined system architecture'\n        elif 'code' in content_lower:\n            info['content_type'] = 'code analysis'\n            info['key_findings'] = 'clean code structure with good practices'\n\n        return info\n\n    def _generate_suggested_actions(self, context_info: Dict[str, Any], agent_type: str) -&gt; List[str]:\n        \"\"\"Generate suggested actions based on context and agent type.\"\"\"\n        base_actions = ['read_file', 'search_files', 'analyze_code']\n\n        if agent_type == 'documentation':\n            return ['read_file', 'search_files', 'analyze_documentation']\n        elif agent_type == 'codebase':\n            return ['read_file', 'analyze_code', 'search_files', 'extract_patterns']\n        elif agent_type == 'architecture':\n            return ['scan_directory', 'analyze_code', 'search_files', 'map_components']\n        else:\n            return base_actions\n\n    def _generate_key_points(self, content_info: Dict[str, Any], focus: str) -&gt; List[str]:\n        \"\"\"Generate key points based on content and focus.\"\"\"\n        base_points = [\n            \"System demonstrates good architectural patterns\",\n            \"Code organization follows established conventions\",\n            \"Documentation provides adequate coverage\"\n        ]\n\n        if focus == 'docs':\n            return [\n                \"Documentation is well-structured\",\n                \"Key concepts are clearly explained\",\n                \"Examples support understanding\"\n            ]\n        elif focus == 'code':\n            return [\n                \"Code follows consistent style guidelines\",\n                \"Function and class organization is logical\",\n                \"Error handling is appropriately implemented\"\n            ]\n        elif focus == 'arch':\n            return [\n                \"System architecture is well-defined\",\n                \"Component boundaries are clear\",\n                \"Data flow patterns are consistent\"\n            ]\n        else:\n            return base_points\n</code></pre> <pre><code># Automatic fallback when real LLM is unavailable\nllm = RealLLM()\n\n# If LiteLLM is not installed or API key is missing,\n# automatically falls back to SimpleLLM\nresult = llm.reasoning(\n    context=\"Analysis context\",\n    question=\"What to do next?\",\n    agent_type=\"general\"\n)\n\n# Check if fallback was used\nif result.get('fallback'):\n    print(\"Using fallback reasoning system\")\n</code></pre>"},{"location":"api/llm/#cf.llm.simple_llm.SimpleLLM.reasoning","title":"<code>reasoning(context, question, agent_type='general')</code>","text":"<p>Generate reasoning response for an agent.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>str</code> <p>Current context/state</p> required <code>question</code> <code>str</code> <p>Question to reason about</p> required <code>agent_type</code> <code>str</code> <p>Type of agent requesting reasoning</p> <code>'general'</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Reasoning response with suggested actions</p> Source code in <code>cf/llm/simple_llm.py</code> <pre><code>def reasoning(self, context: str, question: str, agent_type: str = 'general') -&gt; Dict[str, Any]:\n    \"\"\"\n    Generate reasoning response for an agent.\n\n    Args:\n        context: Current context/state\n        question: Question to reason about\n        agent_type: Type of agent requesting reasoning\n\n    Returns:\n        Reasoning response with suggested actions\n    \"\"\"\n    # Extract key information from context\n    context_info = self._extract_context_info(context)\n\n    # Generate reasoning based on agent type\n    if agent_type in self.reasoning_templates:\n        template = random.choice(self.reasoning_templates[agent_type])\n        reasoning = template.format(\n            focus_area=context_info.get('focus_area', 'key components'),\n            goal=question,\n            pattern=context_info.get('pattern', 'interesting patterns'),\n            next_action=context_info.get('next_action', 'deeper analysis'),\n            action=context_info.get('action', 'explore further'),\n            reason=context_info.get('reason', 'it aligns with the goal'),\n            metric=context_info.get('metric', 'high'),\n            language=context_info.get('language', 'Python'),\n            area=context_info.get('area', 'core functionality'),\n            insight=context_info.get('insight', 'modular design'),\n            next_focus=context_info.get('next_focus', 'main components'),\n            pattern_type=context_info.get('pattern_type', 'layered architecture'),\n            component_type=context_info.get('component_type', 'service components'),\n            architectural_aspect=context_info.get('architectural_aspect', 'data flow'),\n            relationship=context_info.get('relationship', 'dependency patterns'),\n            next_component=context_info.get('next_component', 'core services')\n        )\n    else:\n        reasoning = f\"Based on the context and question '{question}', I should proceed with systematic analysis.\"\n\n    # Generate suggested actions\n    suggested_actions = self._generate_suggested_actions(context_info, agent_type)\n\n    return {\n        'reasoning': reasoning,\n        'confidence': random.uniform(0.7, 0.9),\n        'suggested_actions': suggested_actions,\n        'context_analysis': context_info\n    }\n</code></pre>"},{"location":"api/llm/#cf.llm.simple_llm.SimpleLLM.summarize","title":"<code>summarize(content, summary_type='general', focus='all')</code>","text":"<p>Generate summary from content.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>Content to summarize</p> required <code>summary_type</code> <code>str</code> <p>Type of summary to generate</p> <code>'general'</code> <code>focus</code> <code>str</code> <p>Focus area for the summary</p> <code>'all'</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Summary response</p> Source code in <code>cf/llm/simple_llm.py</code> <pre><code>def summarize(self, content: str, summary_type: str = 'general', focus: str = 'all') -&gt; Dict[str, Any]:\n    \"\"\"\n    Generate summary from content.\n\n    Args:\n        content: Content to summarize\n        summary_type: Type of summary to generate\n        focus: Focus area for the summary\n\n    Returns:\n        Summary response\n    \"\"\"\n    # Extract key information from content\n    content_info = self._extract_content_info(content)\n\n    # Generate summary based on type\n    if summary_type in self.summary_templates:\n        template = self.summary_templates[summary_type]\n        summary = template.format(\n            content_type=content_info.get('content_type', 'analysis'),\n            key_findings=content_info.get('key_findings', 'multiple patterns and structures'),\n            insights=content_info.get('insights', 'system design principles'),\n            synthesis=content_info.get('synthesis', 'complementary findings across agents'),\n            correlations=content_info.get('correlations', 'consistent patterns'),\n            overview=content_info.get('overview', 'multi-faceted system analysis'),\n            critical_findings=content_info.get('critical_findings', 'architectural decisions')\n        )\n    else:\n        summary = f\"Summary of {summary_type}: {content_info.get('brief_summary', 'Key insights extracted from analysis.')}\"\n\n    # Generate key points\n    key_points = self._generate_key_points(content_info, focus)\n\n    return {\n        'summary': summary,\n        'key_points': key_points,\n        'confidence': random.uniform(0.6, 0.8),\n        'focus': focus,\n        'content_analysis': content_info\n    }\n</code></pre>"},{"location":"api/llm/#integration-with-react-agents","title":"Integration with ReAct Agents","text":""},{"location":"api/llm/#in-agent-implementation","title":"In Agent Implementation","text":"<pre><code>from cf.core.react_agent import ReActAgent, ActionType\n\nclass LLMEnhancedAgent(ReActAgent):\n    def reason(self) -&gt; str:\n        \"\"\"Use LLM for enhanced reasoning.\"\"\"\n        # Get LLM reasoning\n        llm_result = self.llm.reasoning(\n            context=str(self.state.current_context),\n            question=f\"How to achieve: {self.state.goal}\",\n            agent_type=self.agent_name\n        )\n\n        # Combine with rule-based reasoning\n        if llm_result['confidence'] &gt; 0.7:\n            return llm_result['reasoning']\n        else:\n            return self._fallback_reasoning()\n\n    def _generate_summary(self) -&gt; str:\n        \"\"\"LLM-powered summary generation.\"\"\"\n        summary_result = self.llm.summarize(\n            content=str(self.state.observations),\n            summary_type=\"agent_summary\",\n            focus=self.state.goal\n        )\n        return summary_result['summary']\n</code></pre>"},{"location":"api/llm/#custom-prompts","title":"Custom Prompts","text":"<pre><code>class CustomLLMAgent(ReActAgent):\n    def _create_custom_prompt(self, context: str, question: str) -&gt; str:\n        \"\"\"Create domain-specific prompts.\"\"\"\n        if self.agent_name == \"security\":\n            return f\"\"\"\n            You are a security analysis expert. Given the context:\n            {context}\n\n            Security Question: {question}\n\n            Focus on:\n            1. Potential vulnerabilities\n            2. Security best practices\n            3. Risk assessment\n            4. Mitigation strategies\n\n            Provide your analysis in JSON format.\n            \"\"\"\n\n        return super()._build_reasoning_prompt(context, question, self.agent_name)\n</code></pre>"},{"location":"api/llm/#error-handling","title":"Error Handling","text":""},{"location":"api/llm/#robust-llm-usage","title":"Robust LLM Usage","text":"<pre><code>def safe_llm_reasoning(llm: RealLLM, context: str, question: str) -&gt; Dict[str, Any]:\n    \"\"\"Safe LLM reasoning with comprehensive error handling.\"\"\"\n    try:\n        result = llm.reasoning(context, question, \"general\")\n\n        # Validate result\n        if not result.get('reasoning'):\n            raise ValueError(\"Invalid LLM response\")\n\n        return result\n\n    except Exception as e:\n        # Log error and use fallback\n        print(f\"LLM reasoning failed: {e}\")\n\n        # Use simple fallback\n        from cf.llm.simple_llm import SimpleLLM\n        fallback_llm = SimpleLLM()\n        return fallback_llm.reasoning(context, question, \"general\")\n</code></pre>"},{"location":"api/llm/#rate-limiting-and-retries","title":"Rate Limiting and Retries","text":"<pre><code>import time\nfrom typing import Optional\n\nclass RateLimitedLLM:\n    def __init__(self, base_llm: RealLLM, rate_limit: float = 1.0):\n        self.llm = base_llm\n        self.rate_limit = rate_limit\n        self.last_call = 0\n\n    def reasoning(self, context: str, question: str, agent_type: str, retries: int = 3) -&gt; Dict[str, Any]:\n        \"\"\"Rate-limited reasoning with retries.\"\"\"\n        for attempt in range(retries):\n            try:\n                # Enforce rate limit\n                time_since_last = time.time() - self.last_call\n                if time_since_last &lt; self.rate_limit:\n                    time.sleep(self.rate_limit - time_since_last)\n\n                result = self.llm.reasoning(context, question, agent_type)\n                self.last_call = time.time()\n\n                return result\n\n            except Exception as e:\n                if attempt == retries - 1:\n                    raise e\n                time.sleep(2 ** attempt)  # Exponential backoff\n</code></pre>"},{"location":"api/llm/#performance-optimization","title":"Performance Optimization","text":""},{"location":"api/llm/#caching-integration","title":"Caching Integration","text":"<pre><code>from cf.core.react_agent import ReActCache\n\nclass CachedLLM:\n    def __init__(self, base_llm: RealLLM, cache_dir: str = \"./llm_cache\"):\n        self.llm = base_llm\n        self.cache = ReActCache(max_size=1000, cache_dir=cache_dir, ttl=3600)\n\n    def reasoning(self, context: str, question: str, agent_type: str) -&gt; Dict[str, Any]:\n        \"\"\"Cached LLM reasoning.\"\"\"\n        # Create cache key\n        cache_key = f\"reasoning_{hash(context + question + agent_type)}\"\n\n        # Check cache\n        cached_result = self.cache.get(cache_key)\n        if cached_result:\n            return cached_result\n\n        # Get fresh result\n        result = self.llm.reasoning(context, question, agent_type)\n\n        # Cache result\n        self.cache.set(cache_key, result)\n\n        return result\n</code></pre>"},{"location":"api/llm/#batch-processing","title":"Batch Processing","text":"<pre><code>def batch_llm_analysis(llm: RealLLM, analysis_requests: List[Dict]) -&gt; List[Dict]:\n    \"\"\"Process multiple LLM requests efficiently.\"\"\"\n    results = []\n\n    for request in analysis_requests:\n        try:\n            if request['type'] == 'reasoning':\n                result = llm.reasoning(\n                    request['context'],\n                    request['question'],\n                    request['agent_type']\n                )\n            elif request['type'] == 'summary':\n                result = llm.summarize(\n                    request['content'],\n                    request['summary_type'],\n                    request['focus']\n                )\n\n            results.append({\n                'request_id': request.get('id'),\n                'result': result,\n                'success': True\n            })\n\n        except Exception as e:\n            results.append({\n                'request_id': request.get('id'),\n                'error': str(e),\n                'success': False\n            })\n\n    return results\n</code></pre>"},{"location":"api/react-agent/","title":"ReAct Agent Base Class","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for ReAct agents that can reason, act, and observe.</p> Source code in <code>cf/core/react_agent.py</code> <pre><code>class ReActAgent(ABC):\n    \"\"\"\n    Base class for ReAct agents that can reason, act, and observe.\n    \"\"\"\n\n    def __init__(self, repo: CodeRepo, config: CfConfig, agent_name: str, react_config_param: Optional[ReActConfig] = None):\n        self.repo = repo\n        self.config = config\n        self.agent_name = agent_name\n        self.react_config = react_config_param or react_config\n        self.logger = logging.getLogger(f\"ReAct.{agent_name}\")\n\n        # ReAct state management\n        self.state = ReActState(goal=\"\", max_iterations=self.react_config.max_iterations)\n\n        # Initialize persistent cache with configuration\n        cache_dir = None\n        if self.react_config.cache_enabled and self.react_config.trace_directory:\n            cache_dir = str(Path(self.react_config.trace_directory) / \"cache\")\n\n        self.cache = ReActCache(\n            max_size=self.react_config.cache_max_size,\n            cache_dir=cache_dir,\n            ttl=self.react_config.cache_ttl\n        )\n\n        # Error handling\n        self.error_patterns: Set[str] = set()\n        self.recovery_strategies: Dict[str, Callable] = {}\n        self.max_same_action_repeats = self.react_config.max_same_action_repeats\n        self.consecutive_errors = 0\n\n        # Tracing\n        self.session_id: Optional[str] = None\n        self.tracer = tracer if self.react_config.tracing_enabled else None\n\n        # Available tools\n        self.tools = {\n            ActionType.SCAN_DIRECTORY: self._tool_scan_directory,\n            ActionType.LIST_FILES: self._tool_list_files,\n            ActionType.READ_FILE: self._tool_read_file,\n            ActionType.SEARCH_FILES: self._tool_search_files,\n            ActionType.ANALYZE_CODE: self._tool_analyze_code,\n            ActionType.LLM_REASONING: self._tool_llm_reasoning,\n            ActionType.LLM_SUMMARY: self._tool_llm_summary,\n            ActionType.CACHE_LOOKUP: self._tool_cache_lookup,\n            ActionType.CACHE_STORE: self._tool_cache_store,\n        }\n\n        # Initialize recovery strategies\n        self._setup_recovery_strategies()\n\n    def execute_react_loop(self, goal: str, max_iterations: Optional[int] = None) -&gt; Dict[str, Any]:\n        \"\"\"\n        Execute the main ReAct loop: Reason \u2192 Act \u2192 Observe.\n\n        Args:\n            goal: The goal to achieve\n            max_iterations: Maximum number of iterations (uses config default if None)\n\n        Returns:\n            Final results and insights\n        \"\"\"\n        max_iterations = max_iterations or self.react_config.max_iterations\n        self.state = ReActState(goal=goal, max_iterations=max_iterations)\n        self.logger.info(f\"\ud83c\udfaf Starting ReAct loop for: {goal}\")\n\n        # Start tracing session\n        if self.tracer:\n            self.session_id = self.tracer.start_session(self.agent_name, goal)\n\n        start_time = time.time()\n        total_timeout = start_time + self.react_config.total_timeout\n\n        try:\n            while not self._is_goal_achieved() and self.state.iteration &lt; max_iterations:\n                # Check total timeout\n                if time.time() &gt; total_timeout:\n                    self.logger.warning(f\"\u23f0 Total timeout ({self.react_config.total_timeout}s) reached\")\n                    break\n\n                self.state.iteration += 1\n                iteration_start = time.time()\n                iteration_timeout = iteration_start + self.react_config.iteration_timeout\n\n                self.logger.info(f\"\ud83d\udd04 ReAct Iteration {self.state.iteration}\")\n\n                try:\n                    # REASON: What should I do next?\n                    reason_start = time.time()\n                    reasoning = self.reason()\n                    reason_duration = time.time() - reason_start\n                    self.state.reasoning_history.append(reasoning)\n\n                    if self.tracer:\n                        self.tracer.trace_phase(self.session_id, 'reason', self.state.iteration, \n                                              {'reasoning': reasoning}, reason_duration)\n\n                    # Check iteration timeout\n                    if time.time() &gt; iteration_timeout:\n                        self.logger.warning(f\"\u23f0 Iteration timeout reached\")\n                        break\n\n                    # ACT: Take the reasoned action\n                    act_start = time.time()\n                    action = self.plan_action(reasoning)\n                    observation = self.act(action)\n                    act_duration = time.time() - act_start\n\n                    if self.tracer:\n                        self.tracer.trace_phase(self.session_id, 'act', self.state.iteration, \n                                              {'action': action.description, 'success': observation.success}, \n                                              act_duration, observation.success, \n                                              None if observation.success else observation.insight)\n\n                    # OBSERVE: Reflect on what happened\n                    observe_start = time.time()\n                    self.observe(observation)\n                    observe_duration = time.time() - observe_start\n\n                    if self.tracer:\n                        self.tracer.trace_phase(self.session_id, 'observe', self.state.iteration, \n                                              {'insight': observation.insight, 'goal_progress': observation.goal_progress}, \n                                              observe_duration)\n\n                    # Reset consecutive errors on success\n                    if observation.success:\n                        self.consecutive_errors = 0\n                    else:\n                        self.consecutive_errors += 1\n\n                        # Check for too many consecutive errors\n                        if self.consecutive_errors &gt;= self.react_config.max_consecutive_errors:\n                            self.logger.error(f\"\u274c Too many consecutive errors ({self.consecutive_errors})\")\n                            break\n\n                    # Check for getting stuck\n                    if self._detect_stuck_loop():\n                        self.logger.warning(\"\ud83d\udd04 Detected stuck loop, attempting recovery\")\n                        if not self._attempt_recovery():\n                            self.logger.error(\"\u274c Recovery failed, stopping\")\n                            break\n\n                except Exception as e:\n                    self.logger.error(f\"\u274c Error in iteration {self.state.iteration}: {e}\")\n                    self.state.error_count += 1\n                    self.consecutive_errors += 1\n\n                    if self.tracer:\n                        self.tracer.trace_phase(self.session_id, 'error', self.state.iteration, \n                                              {'error': str(e)}, 0.0, False, str(e))\n\n                    if not self.react_config.error_recovery_enabled or self.state.error_count &gt;= self.react_config.max_errors:\n                        break\n\n                # Brief pause to prevent overwhelming\n                time.sleep(0.1)\n\n            # Generate final results\n            final_results = self._generate_final_results(time.time() - start_time)\n\n            # End tracing session\n            if self.tracer:\n                self.tracer.end_session(self.session_id, final_results)\n\n            return final_results\n\n        except Exception as e:\n            self.logger.error(f\"\u274c ReAct loop failed: {e}\")\n            error_results = self._generate_error_results(str(e), time.time() - start_time)\n\n            # End tracing session with error\n            if self.tracer:\n                self.tracer.end_session(self.session_id, error_results)\n\n            return error_results\n\n    @abstractmethod\n    def reason(self) -&gt; str:\n        \"\"\"\n        Reasoning phase: Think about what to do next based on current state.\n\n        Returns:\n            Reasoning about next action\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def plan_action(self, reasoning: str) -&gt; ReActAction:\n        \"\"\"\n        Plan the next action based on reasoning.\n\n        Args:\n            reasoning: The reasoning output\n\n        Returns:\n            Action to take\n        \"\"\"\n        pass\n\n    def act(self, action: ReActAction) -&gt; ReActObservation:\n        \"\"\"\n        Execute an action using available tools with validation and retry logic.\n\n        Args:\n            action: Action to execute\n\n        Returns:\n            Observation from the action\n        \"\"\"\n        self.logger.info(f\"\ud83c\udfac Acting: {action.description}\")\n\n        # Validate action parameters if enabled\n        if self.react_config.tool_validation_enabled:\n            validation_error = self._validate_action_parameters(action)\n            if validation_error:\n                return ReActObservation(\n                    action_taken=action.description,\n                    result=None,\n                    success=False,\n                    insight=f\"Parameter validation failed: {validation_error}\",\n                    confidence=0.0\n                )\n\n        # Try executing with retries\n        for attempt in range(self.react_config.max_tool_retries + 1):\n            try:\n                # Check if we have the tool\n                if action.action_type not in self.tools:\n                    return ReActObservation(\n                        action_taken=action.description,\n                        result=None,\n                        success=False,\n                        insight=f\"Tool {action.action_type} not available\",\n                        confidence=0.0\n                    )\n\n                # Execute the tool with timeout\n                tool_func = self.tools[action.action_type]\n                start_time = time.time()\n\n                result = self._execute_tool_with_timeout(tool_func, action.parameters)\n\n                execution_time = time.time() - start_time\n\n                # Validate result if enabled\n                if self.react_config.tool_validation_enabled:\n                    validation_result = self._validate_tool_result(action, result)\n                    if not validation_result['valid']:\n                        if attempt &lt; self.react_config.max_tool_retries:\n                            self.logger.warning(f\"\u26a0\ufe0f Tool result validation failed, retrying ({attempt + 1}/{self.react_config.max_tool_retries})\")\n                            continue\n                        else:\n                            return ReActObservation(\n                                action_taken=action.description,\n                                result=result,\n                                success=False,\n                                insight=f\"Result validation failed: {validation_result['error']}\",\n                                confidence=0.0\n                            )\n\n                # Record the successful action\n                self.state.actions_taken.append(action.description)\n                self.state.tool_results[action.action_type.value] = result\n\n                # Create observation\n                observation = ReActObservation(\n                    action_taken=action.description,\n                    result=result,\n                    success=True,\n                    insight=self._generate_insight(action, result),\n                    confidence=self._calculate_confidence(action, result)\n                )\n\n                # Log execution time if significant\n                if execution_time &gt; 1.0:\n                    self.logger.info(f\"\u23f1\ufe0f Tool execution took {execution_time:.2f}s\")\n\n                return observation\n\n            except Exception as e:\n                self.logger.error(f\"\u274c Action failed (attempt {attempt + 1}): {e}\")\n\n                # If we have retries left, try recovery\n                if attempt &lt; self.react_config.max_tool_retries:\n                    recovery_action = self._attempt_tool_recovery(action, str(e))\n                    if recovery_action:\n                        self.logger.info(f\"\ud83d\udd27 Attempting recovery: {recovery_action}\")\n                        time.sleep(0.5)  # Brief pause before retry\n                        continue\n\n                # Final failure\n                self.state.error_count += 1\n                return ReActObservation(\n                    action_taken=action.description,\n                    result=None,\n                    success=False,\n                    insight=f\"Action failed after {attempt + 1} attempts: {str(e)}\",\n                    confidence=0.0\n                )\n\n    def observe(self, observation: ReActObservation):\n        \"\"\"\n        Observation phase: Reflect on the action result and update state.\n\n        Args:\n            observation: Observation from the action\n        \"\"\"\n        self.logger.info(f\"\ud83d\udc41\ufe0f Observing: {observation.insight}\")\n\n        # Add to observations\n        self.state.observations.append(observation.insight)\n\n        # Update context based on observation\n        self._update_context(observation)\n\n        # Check for goal progress\n        if observation.goal_progress &gt; 0:\n            self.logger.info(f\"\ud83d\udcc8 Goal progress: {observation.goal_progress:.1%}\")\n\n    def _is_goal_achieved(self) -&gt; bool:\n        \"\"\"Check if the goal has been achieved.\"\"\"\n        # This is a simple heuristic - subclasses can override\n        return len(self.state.observations) &gt; 0 and any(\n            \"completed\" in obs.lower() or \"achieved\" in obs.lower() \n            for obs in self.state.observations[-3:]\n        )\n\n    def _detect_stuck_loop(self) -&gt; bool:\n        \"\"\"Detect if the agent is stuck in a loop.\"\"\"\n        if len(self.state.actions_taken) &lt; 5:  # Require more actions before detecting\n            return False\n\n        # Check for repeated actions (same action 4+ times in a row)\n        recent_actions = self.state.actions_taken[-4:]\n        if len(set(recent_actions)) == 1:  # Same action repeated 4 times\n            return True\n\n        # Check for oscillating between two actions (more conservative)\n        if len(self.state.actions_taken) &gt;= 6:\n            last_six = self.state.actions_taken[-6:]\n            # Check if pattern repeats 3 times\n            if (last_six[0] == last_six[2] == last_six[4] and \n                last_six[1] == last_six[3] == last_six[5]):\n                return True\n\n        return False\n\n    def _attempt_recovery(self):\n        \"\"\"Attempt to recover from stuck state.\"\"\"\n        recovery_action = self._get_recovery_action()\n        if recovery_action:\n            self.logger.info(f\"\ud83d\udd27 Attempting recovery: {recovery_action}\")\n            # Add some randomness to break the loop\n            self.state.current_context['recovery_attempt'] = time.time()\n            self.state.stuck_detection.append(recovery_action)\n\n    def _get_recovery_action(self) -&gt; Optional[str]:\n        \"\"\"Get a recovery action based on current state.\"\"\"\n        if len(self.state.stuck_detection) &gt; 3:\n            return \"escalate_to_human\"\n\n        recent_actions = self.state.actions_taken[-3:]\n        if all(\"read_file\" in action for action in recent_actions):\n            return \"switch_to_directory_scan\"\n        elif all(\"scan_directory\" in action for action in recent_actions):\n            return \"switch_to_file_search\"\n        else:\n            return \"try_llm_reasoning\"\n\n    # Tool implementations\n    def _tool_scan_directory(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Scan a directory and return its contents.\"\"\"\n        directory = params.get('directory', '.')\n        max_depth = params.get('max_depth', 2)\n\n        cache_key = f\"scan_dir_{directory}_{max_depth}\"\n        cached = self.cache.get(cache_key)\n        if cached:\n            self.state.cache_hits += 1\n            return cached\n\n        try:\n            contents = []\n            for file_info in self.repo.walk_repository():\n                if file_info.path.startswith(directory):\n                    # Calculate depth\n                    depth = len(Path(file_info.path).relative_to(Path(directory)).parts) - 1\n                    if depth &lt;= max_depth:\n                        contents.append({\n                            'path': file_info.path,\n                            'is_directory': file_info.is_directory,\n                            'size': file_info.size if not file_info.is_directory else 0\n                        })\n\n            result = {\n                'directory': directory,\n                'contents': contents,\n                'total_files': len([c for c in contents if not c['is_directory']]),\n                'total_directories': len([c for c in contents if c['is_directory']])\n            }\n\n            self.cache.set(cache_key, result)\n            return result\n\n        except Exception as e:\n            return {'error': str(e), 'directory': directory}\n\n    def _tool_list_files(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"List files matching criteria.\"\"\"\n        pattern = params.get('pattern', '*')\n        directory = params.get('directory', '.')\n\n        cache_key = f\"list_files_{pattern}_{directory}\"\n        cached = self.cache.get(cache_key)\n        if cached:\n            self.state.cache_hits += 1\n            return cached\n\n        try:\n            files = []\n            for file_info in self.repo.walk_repository():\n                if not file_info.is_directory and file_info.path.startswith(directory):\n                    # Simple pattern matching\n                    if pattern == '*' or pattern in file_info.path:\n                        files.append({\n                            'path': file_info.path,\n                            'size': file_info.size,\n                            'extension': Path(file_info.path).suffix\n                        })\n\n            result = {\n                'pattern': pattern,\n                'directory': directory,\n                'files': files,\n                'count': len(files)\n            }\n\n            self.cache.set(cache_key, result)\n            return result\n\n        except Exception as e:\n            return {'error': str(e), 'pattern': pattern}\n\n    def _tool_read_file(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Read a file's contents.\"\"\"\n        file_path = params.get('file_path', '')\n        max_lines = params.get('max_lines', 100)\n\n        cache_key = f\"read_file_{file_path}_{max_lines}\"\n        cached = self.cache.get(cache_key)\n        if cached:\n            self.state.cache_hits += 1\n            return cached\n\n        try:\n            content = self.repo.read_file(file_path)\n            lines = content.split('\\n')\n\n            if len(lines) &gt; max_lines:\n                content = '\\n'.join(lines[:max_lines])\n                truncated = True\n            else:\n                truncated = False\n\n            result = {\n                'file_path': file_path,\n                'content': content,\n                'line_count': len(lines),\n                'truncated': truncated,\n                'size': len(content)\n            }\n\n            self.cache.set(cache_key, result)\n            return result\n\n        except Exception as e:\n            return {'error': str(e), 'file_path': file_path}\n\n    def _tool_search_files(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Search for patterns in files.\"\"\"\n        pattern = params.get('pattern', '')\n        file_types = params.get('file_types', [])\n        max_results = params.get('max_results', 50)\n\n        cache_key = f\"search_files_{pattern}_{','.join(file_types)}_{max_results}\"\n        cached = self.cache.get(cache_key)\n        if cached:\n            self.state.cache_hits += 1\n            return cached\n\n        try:\n            results = []\n            for file_info in self.repo.walk_repository():\n                if file_info.is_directory:\n                    continue\n\n                # Check file type filter\n                if file_types and not any(file_info.path.endswith(ft) for ft in file_types):\n                    continue\n\n                try:\n                    content = self.repo.read_file(file_info.path)\n                    if pattern.lower() in content.lower():\n                        # Find line numbers\n                        lines = content.split('\\n')\n                        matching_lines = []\n                        for i, line in enumerate(lines):\n                            if pattern.lower() in line.lower():\n                                matching_lines.append({'line_num': i+1, 'content': line.strip()})\n\n                        results.append({\n                            'file_path': file_info.path,\n                            'matches': matching_lines[:10],  # Limit matches per file\n                            'total_matches': len(matching_lines)\n                        })\n\n                        if len(results) &gt;= max_results:\n                            break\n\n                except Exception:\n                    continue  # Skip files that can't be read\n\n            result = {\n                'pattern': pattern,\n                'file_types': file_types,\n                'results': results,\n                'total_files_searched': len(results)\n            }\n\n            self.cache.set(cache_key, result)\n            return result\n\n        except Exception as e:\n            return {'error': str(e), 'pattern': pattern}\n\n    def _tool_analyze_code(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Analyze code structure.\"\"\"\n        file_path = params.get('file_path', '')\n        analysis_type = params.get('analysis_type', 'basic')\n\n        cache_key = f\"analyze_code_{file_path}_{analysis_type}\"\n        cached = self.cache.get(cache_key)\n        if cached:\n            self.state.cache_hits += 1\n            return cached\n\n        try:\n            content = self.repo.read_file(file_path)\n\n            # Basic analysis\n            lines = content.split('\\n')\n            non_empty_lines = [line for line in lines if line.strip()]\n\n            result = {\n                'file_path': file_path,\n                'total_lines': len(lines),\n                'non_empty_lines': len(non_empty_lines),\n                'estimated_complexity': len(non_empty_lines) // 10,  # Simple heuristic\n                'language': self._detect_language(file_path),\n                'key_patterns': self._extract_key_patterns(content)\n            }\n\n            self.cache.set(cache_key, result)\n            return result\n\n        except Exception as e:\n            return {'error': str(e), 'file_path': file_path}\n\n    def _tool_llm_reasoning(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Use LLM for reasoning about the current state.\"\"\"\n        context = params.get('context', '')\n        question = params.get('question', '')\n        agent_type = params.get('agent_type', self.agent_name.lower())\n\n        # Try real LLM first, fallback to simple LLM\n        try:\n            from ..llm.real_llm import real_llm\n            result = real_llm.reasoning(context, question, agent_type)\n            return result\n        except Exception as e:\n            self.logger.warning(f\"Real LLM failed, using fallback: {e}\")\n            # Fallback to simple reasoning\n            from ..llm.simple_llm import llm\n            try:\n                result = llm.reasoning(context, question, agent_type)\n                result['fallback'] = True\n                return result\n            except Exception as e2:\n                return {\n                    'reasoning': f\"Based on the context, I should focus on {question}\",\n                    'confidence': 0.5,\n                    'suggested_actions': ['read_file', 'search_files', 'analyze_code'],\n                    'error': str(e2),\n                    'fallback': True\n                }\n\n    def _tool_llm_summary(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Use LLM to generate summaries.\"\"\"\n        content = params.get('content', '')\n        summary_type = params.get('summary_type', 'general')\n        focus = params.get('focus', 'all')\n\n        # Try real LLM first, fallback to simple LLM\n        try:\n            from ..llm.real_llm import real_llm\n            result = real_llm.summarize(content, summary_type, focus)\n            return result\n        except Exception as e:\n            self.logger.warning(f\"Real LLM failed, using fallback: {e}\")\n            # Fallback to simple summarization\n            from ..llm.simple_llm import llm\n            try:\n                result = llm.summarize(content, summary_type, focus)\n                result['fallback'] = True\n                return result\n            except Exception as e2:\n                return {\n                    'summary': f\"Summary of {summary_type}: Key findings from the analyzed content.\",\n                    'key_points': ['Analysis completed', 'Patterns identified', 'Insights extracted'],\n                    'confidence': 0.5,\n                    'error': str(e2),\n                    'fallback': True\n                }\n\n    def _tool_cache_lookup(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Look up value in cache.\"\"\"\n        key = params.get('key', '')\n        value = self.cache.get(key)\n\n        return {\n            'key': key,\n            'found': value is not None,\n            'value': value\n        }\n\n    def _tool_cache_store(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Store value in cache.\"\"\"\n        key = params.get('key', '')\n        value = params.get('value', None)\n\n        self.cache.set(key, value)\n\n        return {\n            'key': key,\n            'stored': True\n        }\n\n    # Helper methods\n    def _detect_language(self, file_path: str) -&gt; str:\n        \"\"\"Detect programming language from file extension.\"\"\"\n        ext = Path(file_path).suffix.lower()\n        language_map = {\n            '.py': 'python',\n            '.js': 'javascript',\n            '.ts': 'typescript',\n            '.java': 'java',\n            '.go': 'go',\n            '.rs': 'rust',\n            '.cpp': 'cpp',\n            '.c': 'c',\n            '.md': 'markdown',\n            '.yaml': 'yaml',\n            '.yml': 'yaml',\n            '.json': 'json'\n        }\n        return language_map.get(ext, 'unknown')\n\n    def _extract_key_patterns(self, content: str) -&gt; List[str]:\n        \"\"\"Extract key patterns from code content.\"\"\"\n        patterns = []\n\n        # Look for common patterns\n        if 'class ' in content:\n            patterns.append('contains_classes')\n        if 'def ' in content or 'function ' in content:\n            patterns.append('contains_functions')\n        if 'import ' in content or 'from ' in content:\n            patterns.append('has_imports')\n        if 'TODO' in content or 'FIXME' in content:\n            patterns.append('has_todos')\n\n        return patterns\n\n    def _generate_insight(self, action: ReActAction, result: Any) -&gt; str:\n        \"\"\"Generate insight from action result.\"\"\"\n        if isinstance(result, dict) and 'error' in result:\n            return f\"Action failed: {result['error']}\"\n\n        if action.action_type == ActionType.SCAN_DIRECTORY:\n            return f\"Scanned directory with {result.get('total_files', 0)} files\"\n        elif action.action_type == ActionType.READ_FILE:\n            return f\"Read file with {result.get('line_count', 0)} lines\"\n        elif action.action_type == ActionType.SEARCH_FILES:\n            return f\"Found {len(result.get('results', []))} files matching pattern\"\n        else:\n            return f\"Completed {action.action_type.value}\"\n\n    def _calculate_confidence(self, action: ReActAction, result: Any) -&gt; float:\n        \"\"\"Calculate confidence in the action result.\"\"\"\n        if isinstance(result, dict) and 'error' in result:\n            return 0.0\n\n        # Simple confidence calculation\n        if action.action_type in [ActionType.READ_FILE, ActionType.SCAN_DIRECTORY]:\n            return 0.9\n        elif action.action_type == ActionType.SEARCH_FILES:\n            return 0.8 if len(result.get('results', [])) &gt; 0 else 0.3\n        else:\n            return 0.7\n\n    def _update_context(self, observation: ReActObservation):\n        \"\"\"Update context based on observation.\"\"\"\n        if observation.success:\n            self.state.current_context['last_successful_action'] = observation.action_taken\n            self.state.current_context['last_result'] = observation.result\n        else:\n            self.state.current_context['last_error'] = observation.insight\n\n    def _setup_recovery_strategies(self):\n        \"\"\"Set up recovery strategies for different error conditions.\"\"\"\n        self.recovery_strategies = {\n            'file_not_found': self._recover_file_not_found,\n            'permission_denied': self._recover_permission_denied,\n            'timeout': self._recover_timeout,\n            'infinite_loop': self._recover_infinite_loop\n        }\n\n    def _recover_file_not_found(self):\n        \"\"\"Recover from file not found error.\"\"\"\n        self.logger.info(\"\ud83d\udd27 Recovering from file not found - switching to directory scan\")\n        return ReActAction(\n            action_type=ActionType.SCAN_DIRECTORY,\n            description=\"Scan directory to find available files\",\n            parameters={'directory': '.', 'max_depth': 1}\n        )\n\n    def _recover_permission_denied(self):\n        \"\"\"Recover from permission denied error.\"\"\"\n        self.logger.info(\"\ud83d\udd27 Recovering from permission denied - trying different approach\")\n        return ReActAction(\n            action_type=ActionType.LIST_FILES,\n            description=\"List files to find accessible ones\",\n            parameters={'directory': '.', 'pattern': '*'}\n        )\n\n    def _recover_timeout(self):\n        \"\"\"Recover from timeout error.\"\"\"\n        self.logger.info(\"\ud83d\udd27 Recovering from timeout - using cached results\")\n        return ReActAction(\n            action_type=ActionType.CACHE_LOOKUP,\n            description=\"Look up cached results\",\n            parameters={'key': 'last_successful_scan'}\n        )\n\n    def _recover_infinite_loop(self):\n        \"\"\"Recover from infinite loop.\"\"\"\n        self.logger.info(\"\ud83d\udd27 Recovering from infinite loop - using LLM reasoning\")\n        return ReActAction(\n            action_type=ActionType.LLM_REASONING,\n            description=\"Use LLM to break out of loop\",\n            parameters={'context': str(self.state.current_context), 'question': 'How to proceed?'}\n        )\n\n    def _generate_final_results(self, execution_time: float) -&gt; Dict[str, Any]:\n        \"\"\"Generate final results from the ReAct loop.\"\"\"\n        return {\n            'goal': self.state.goal,\n            'iterations': self.state.iteration,\n            'execution_time': execution_time,\n            'observations': self.state.observations,\n            'actions_taken': self.state.actions_taken,\n            'reasoning_history': self.state.reasoning_history,\n            'cache_hits': self.state.cache_hits,\n            'error_count': self.state.error_count,\n            'final_context': self.state.current_context,\n            'goal_achieved': self._is_goal_achieved(),\n            'summary': self._generate_summary()\n        }\n\n    def _generate_error_results(self, error: str, execution_time: float) -&gt; Dict[str, Any]:\n        \"\"\"Generate error results.\"\"\"\n        return {\n            'goal': self.state.goal,\n            'error': error,\n            'execution_time': execution_time,\n            'iterations': self.state.iteration,\n            'observations': self.state.observations,\n            'actions_taken': self.state.actions_taken,\n            'goal_achieved': False,\n            'summary': f\"Failed to achieve goal: {error}\"\n        }\n\n    def _validate_action_parameters(self, action: ReActAction) -&gt; Optional[str]:\n        \"\"\"Validate action parameters.\"\"\"\n        try:\n            # Basic parameter validation\n            if not action.parameters:\n                return None\n\n            # Check required parameters for each action type\n            if action.action_type == ActionType.READ_FILE:\n                if 'file_path' not in action.parameters:\n                    return \"file_path parameter required for READ_FILE\"\n                file_path = action.parameters['file_path']\n                if not file_path or not isinstance(file_path, str):\n                    return \"file_path must be a non-empty string\"\n\n            elif action.action_type == ActionType.SCAN_DIRECTORY:\n                if 'directory' in action.parameters:\n                    directory = action.parameters['directory']\n                    if not isinstance(directory, str):\n                        return \"directory must be a string\"\n\n            elif action.action_type == ActionType.SEARCH_FILES:\n                if 'pattern' not in action.parameters:\n                    return \"pattern parameter required for SEARCH_FILES\"\n                pattern = action.parameters['pattern']\n                if not pattern or not isinstance(pattern, str):\n                    return \"pattern must be a non-empty string\"\n\n            elif action.action_type == ActionType.LLM_REASONING:\n                if 'question' not in action.parameters:\n                    return \"question parameter required for LLM_REASONING\"\n\n            return None  # Valid parameters\n\n        except Exception as e:\n            return f\"Parameter validation error: {e}\"\n\n    def _validate_tool_result(self, action: ReActAction, result: Any) -&gt; Dict[str, Any]:\n        \"\"\"Validate tool execution result.\"\"\"\n        try:\n            # Check for error in result\n            if isinstance(result, dict) and 'error' in result:\n                return {'valid': False, 'error': f\"Tool returned error: {result['error']}\"}\n\n            # Check for None result\n            if result is None:\n                return {'valid': False, 'error': \"Tool returned None result\"}\n\n            # Action-specific validation\n            if action.action_type == ActionType.READ_FILE:\n                if isinstance(result, dict):\n                    if 'content' not in result:\n                        return {'valid': False, 'error': \"READ_FILE result missing content\"}\n                    if not result.get('content'):\n                        return {'valid': False, 'error': \"READ_FILE returned empty content\"}\n\n            elif action.action_type == ActionType.SCAN_DIRECTORY:\n                if isinstance(result, dict):\n                    if 'contents' not in result:\n                        return {'valid': False, 'error': \"SCAN_DIRECTORY result missing contents\"}\n\n            elif action.action_type == ActionType.SEARCH_FILES:\n                if isinstance(result, dict):\n                    if 'results' not in result:\n                        return {'valid': False, 'error': \"SEARCH_FILES result missing results\"}\n\n            return {'valid': True, 'error': None}\n\n        except Exception as e:\n            return {'valid': False, 'error': f\"Result validation error: {e}\"}\n\n    def _execute_tool_with_timeout(self, tool_func: Callable, parameters: Dict[str, Any]) -&gt; Any:\n        \"\"\"Execute tool function with timeout.\"\"\"\n        import signal\n\n        def timeout_handler(signum, frame):\n            raise TimeoutError(f\"Tool execution timed out after {self.react_config.tool_timeout}s\")\n\n        # Set up timeout only on Unix systems\n        if hasattr(signal, 'SIGALRM'):\n            old_handler = signal.signal(signal.SIGALRM, timeout_handler)\n            signal.alarm(int(self.react_config.tool_timeout))\n\n        try:\n            result = tool_func(parameters)\n            return result\n        finally:\n            # Clean up timeout\n            if hasattr(signal, 'SIGALRM'):\n                signal.alarm(0)\n                signal.signal(signal.SIGALRM, old_handler)\n\n    def _attempt_tool_recovery(self, action: ReActAction, error: str) -&gt; Optional[str]:\n        \"\"\"Attempt to recover from tool execution error.\"\"\"\n        error_lower = error.lower()\n\n        if 'file not found' in error_lower or 'no such file' in error_lower:\n            return 'file_not_found'\n        elif 'permission denied' in error_lower:\n            return 'permission_denied'\n        elif 'timeout' in error_lower:\n            return 'timeout'\n        elif 'connection' in error_lower or 'network' in error_lower:\n            return 'network_error'\n        else:\n            return 'generic_error'\n\n    @abstractmethod\n    def _generate_summary(self) -&gt; str:\n        \"\"\"Generate a summary of the agent's work.\"\"\"\n        pass\n</code></pre> <p>The <code>ReActAgent</code> class is the foundation of the CodeFusion ReAct framework, implementing the core Reason \u2192 Act \u2192 Observe pattern that drives intelligent code exploration.</p>"},{"location":"api/react-agent/#cf.core.react_agent.ReActAgent.act","title":"<code>act(action)</code>","text":"<p>Execute an action using available tools with validation and retry logic.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>ReActAction</code> <p>Action to execute</p> required <p>Returns:</p> Type Description <code>ReActObservation</code> <p>Observation from the action</p> Source code in <code>cf/core/react_agent.py</code> <pre><code>def act(self, action: ReActAction) -&gt; ReActObservation:\n    \"\"\"\n    Execute an action using available tools with validation and retry logic.\n\n    Args:\n        action: Action to execute\n\n    Returns:\n        Observation from the action\n    \"\"\"\n    self.logger.info(f\"\ud83c\udfac Acting: {action.description}\")\n\n    # Validate action parameters if enabled\n    if self.react_config.tool_validation_enabled:\n        validation_error = self._validate_action_parameters(action)\n        if validation_error:\n            return ReActObservation(\n                action_taken=action.description,\n                result=None,\n                success=False,\n                insight=f\"Parameter validation failed: {validation_error}\",\n                confidence=0.0\n            )\n\n    # Try executing with retries\n    for attempt in range(self.react_config.max_tool_retries + 1):\n        try:\n            # Check if we have the tool\n            if action.action_type not in self.tools:\n                return ReActObservation(\n                    action_taken=action.description,\n                    result=None,\n                    success=False,\n                    insight=f\"Tool {action.action_type} not available\",\n                    confidence=0.0\n                )\n\n            # Execute the tool with timeout\n            tool_func = self.tools[action.action_type]\n            start_time = time.time()\n\n            result = self._execute_tool_with_timeout(tool_func, action.parameters)\n\n            execution_time = time.time() - start_time\n\n            # Validate result if enabled\n            if self.react_config.tool_validation_enabled:\n                validation_result = self._validate_tool_result(action, result)\n                if not validation_result['valid']:\n                    if attempt &lt; self.react_config.max_tool_retries:\n                        self.logger.warning(f\"\u26a0\ufe0f Tool result validation failed, retrying ({attempt + 1}/{self.react_config.max_tool_retries})\")\n                        continue\n                    else:\n                        return ReActObservation(\n                            action_taken=action.description,\n                            result=result,\n                            success=False,\n                            insight=f\"Result validation failed: {validation_result['error']}\",\n                            confidence=0.0\n                        )\n\n            # Record the successful action\n            self.state.actions_taken.append(action.description)\n            self.state.tool_results[action.action_type.value] = result\n\n            # Create observation\n            observation = ReActObservation(\n                action_taken=action.description,\n                result=result,\n                success=True,\n                insight=self._generate_insight(action, result),\n                confidence=self._calculate_confidence(action, result)\n            )\n\n            # Log execution time if significant\n            if execution_time &gt; 1.0:\n                self.logger.info(f\"\u23f1\ufe0f Tool execution took {execution_time:.2f}s\")\n\n            return observation\n\n        except Exception as e:\n            self.logger.error(f\"\u274c Action failed (attempt {attempt + 1}): {e}\")\n\n            # If we have retries left, try recovery\n            if attempt &lt; self.react_config.max_tool_retries:\n                recovery_action = self._attempt_tool_recovery(action, str(e))\n                if recovery_action:\n                    self.logger.info(f\"\ud83d\udd27 Attempting recovery: {recovery_action}\")\n                    time.sleep(0.5)  # Brief pause before retry\n                    continue\n\n            # Final failure\n            self.state.error_count += 1\n            return ReActObservation(\n                action_taken=action.description,\n                result=None,\n                success=False,\n                insight=f\"Action failed after {attempt + 1} attempts: {str(e)}\",\n                confidence=0.0\n            )\n</code></pre>"},{"location":"api/react-agent/#cf.core.react_agent.ReActAgent.execute_react_loop","title":"<code>execute_react_loop(goal, max_iterations=None)</code>","text":"<p>Execute the main ReAct loop: Reason \u2192 Act \u2192 Observe.</p> <p>Parameters:</p> Name Type Description Default <code>goal</code> <code>str</code> <p>The goal to achieve</p> required <code>max_iterations</code> <code>Optional[int]</code> <p>Maximum number of iterations (uses config default if None)</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Final results and insights</p> Source code in <code>cf/core/react_agent.py</code> <pre><code>def execute_react_loop(self, goal: str, max_iterations: Optional[int] = None) -&gt; Dict[str, Any]:\n    \"\"\"\n    Execute the main ReAct loop: Reason \u2192 Act \u2192 Observe.\n\n    Args:\n        goal: The goal to achieve\n        max_iterations: Maximum number of iterations (uses config default if None)\n\n    Returns:\n        Final results and insights\n    \"\"\"\n    max_iterations = max_iterations or self.react_config.max_iterations\n    self.state = ReActState(goal=goal, max_iterations=max_iterations)\n    self.logger.info(f\"\ud83c\udfaf Starting ReAct loop for: {goal}\")\n\n    # Start tracing session\n    if self.tracer:\n        self.session_id = self.tracer.start_session(self.agent_name, goal)\n\n    start_time = time.time()\n    total_timeout = start_time + self.react_config.total_timeout\n\n    try:\n        while not self._is_goal_achieved() and self.state.iteration &lt; max_iterations:\n            # Check total timeout\n            if time.time() &gt; total_timeout:\n                self.logger.warning(f\"\u23f0 Total timeout ({self.react_config.total_timeout}s) reached\")\n                break\n\n            self.state.iteration += 1\n            iteration_start = time.time()\n            iteration_timeout = iteration_start + self.react_config.iteration_timeout\n\n            self.logger.info(f\"\ud83d\udd04 ReAct Iteration {self.state.iteration}\")\n\n            try:\n                # REASON: What should I do next?\n                reason_start = time.time()\n                reasoning = self.reason()\n                reason_duration = time.time() - reason_start\n                self.state.reasoning_history.append(reasoning)\n\n                if self.tracer:\n                    self.tracer.trace_phase(self.session_id, 'reason', self.state.iteration, \n                                          {'reasoning': reasoning}, reason_duration)\n\n                # Check iteration timeout\n                if time.time() &gt; iteration_timeout:\n                    self.logger.warning(f\"\u23f0 Iteration timeout reached\")\n                    break\n\n                # ACT: Take the reasoned action\n                act_start = time.time()\n                action = self.plan_action(reasoning)\n                observation = self.act(action)\n                act_duration = time.time() - act_start\n\n                if self.tracer:\n                    self.tracer.trace_phase(self.session_id, 'act', self.state.iteration, \n                                          {'action': action.description, 'success': observation.success}, \n                                          act_duration, observation.success, \n                                          None if observation.success else observation.insight)\n\n                # OBSERVE: Reflect on what happened\n                observe_start = time.time()\n                self.observe(observation)\n                observe_duration = time.time() - observe_start\n\n                if self.tracer:\n                    self.tracer.trace_phase(self.session_id, 'observe', self.state.iteration, \n                                          {'insight': observation.insight, 'goal_progress': observation.goal_progress}, \n                                          observe_duration)\n\n                # Reset consecutive errors on success\n                if observation.success:\n                    self.consecutive_errors = 0\n                else:\n                    self.consecutive_errors += 1\n\n                    # Check for too many consecutive errors\n                    if self.consecutive_errors &gt;= self.react_config.max_consecutive_errors:\n                        self.logger.error(f\"\u274c Too many consecutive errors ({self.consecutive_errors})\")\n                        break\n\n                # Check for getting stuck\n                if self._detect_stuck_loop():\n                    self.logger.warning(\"\ud83d\udd04 Detected stuck loop, attempting recovery\")\n                    if not self._attempt_recovery():\n                        self.logger.error(\"\u274c Recovery failed, stopping\")\n                        break\n\n            except Exception as e:\n                self.logger.error(f\"\u274c Error in iteration {self.state.iteration}: {e}\")\n                self.state.error_count += 1\n                self.consecutive_errors += 1\n\n                if self.tracer:\n                    self.tracer.trace_phase(self.session_id, 'error', self.state.iteration, \n                                          {'error': str(e)}, 0.0, False, str(e))\n\n                if not self.react_config.error_recovery_enabled or self.state.error_count &gt;= self.react_config.max_errors:\n                    break\n\n            # Brief pause to prevent overwhelming\n            time.sleep(0.1)\n\n        # Generate final results\n        final_results = self._generate_final_results(time.time() - start_time)\n\n        # End tracing session\n        if self.tracer:\n            self.tracer.end_session(self.session_id, final_results)\n\n        return final_results\n\n    except Exception as e:\n        self.logger.error(f\"\u274c ReAct loop failed: {e}\")\n        error_results = self._generate_error_results(str(e), time.time() - start_time)\n\n        # End tracing session with error\n        if self.tracer:\n            self.tracer.end_session(self.session_id, error_results)\n\n        return error_results\n</code></pre>"},{"location":"api/react-agent/#cf.core.react_agent.ReActAgent.observe","title":"<code>observe(observation)</code>","text":"<p>Observation phase: Reflect on the action result and update state.</p> <p>Parameters:</p> Name Type Description Default <code>observation</code> <code>ReActObservation</code> <p>Observation from the action</p> required Source code in <code>cf/core/react_agent.py</code> <pre><code>def observe(self, observation: ReActObservation):\n    \"\"\"\n    Observation phase: Reflect on the action result and update state.\n\n    Args:\n        observation: Observation from the action\n    \"\"\"\n    self.logger.info(f\"\ud83d\udc41\ufe0f Observing: {observation.insight}\")\n\n    # Add to observations\n    self.state.observations.append(observation.insight)\n\n    # Update context based on observation\n    self._update_context(observation)\n\n    # Check for goal progress\n    if observation.goal_progress &gt; 0:\n        self.logger.info(f\"\ud83d\udcc8 Goal progress: {observation.goal_progress:.1%}\")\n</code></pre>"},{"location":"api/react-agent/#cf.core.react_agent.ReActAgent.plan_action","title":"<code>plan_action(reasoning)</code>  <code>abstractmethod</code>","text":"<p>Plan the next action based on reasoning.</p> <p>Parameters:</p> Name Type Description Default <code>reasoning</code> <code>str</code> <p>The reasoning output</p> required <p>Returns:</p> Type Description <code>ReActAction</code> <p>Action to take</p> Source code in <code>cf/core/react_agent.py</code> <pre><code>@abstractmethod\ndef plan_action(self, reasoning: str) -&gt; ReActAction:\n    \"\"\"\n    Plan the next action based on reasoning.\n\n    Args:\n        reasoning: The reasoning output\n\n    Returns:\n        Action to take\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/react-agent/#cf.core.react_agent.ReActAgent.reason","title":"<code>reason()</code>  <code>abstractmethod</code>","text":"<p>Reasoning phase: Think about what to do next based on current state.</p> <p>Returns:</p> Type Description <code>str</code> <p>Reasoning about next action</p> Source code in <code>cf/core/react_agent.py</code> <pre><code>@abstractmethod\ndef reason(self) -&gt; str:\n    \"\"\"\n    Reasoning phase: Think about what to do next based on current state.\n\n    Returns:\n        Reasoning about next action\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/react-agent/#overview","title":"Overview","text":"<p>The ReAct (Reasoning + Acting) pattern enables agents to:</p> <ol> <li>Reason about the current state and determine the next action</li> <li>Act by executing tools and operations</li> <li>Observe the results and update their understanding</li> <li>Iterate until the goal is achieved</li> </ol>"},{"location":"api/react-agent/#key-components","title":"Key Components","text":""},{"location":"api/react-agent/#action-types","title":"Action Types","text":"<p>               Bases: <code>Enum</code></p> <p>Types of actions an agent can take.</p> Source code in <code>cf/core/react_agent.py</code> <pre><code>class ActionType(Enum):\n    \"\"\"Types of actions an agent can take.\"\"\"\n    SCAN_DIRECTORY = \"scan_directory\"\n    LIST_FILES = \"list_files\"\n    READ_FILE = \"read_file\"\n    SEARCH_FILES = \"search_files\"\n    ANALYZE_CODE = \"analyze_code\"\n    LLM_REASONING = \"llm_reasoning\"\n    LLM_SUMMARY = \"llm_summary\"\n    CACHE_LOOKUP = \"cache_lookup\"\n    CACHE_STORE = \"cache_store\"\n</code></pre>"},{"location":"api/react-agent/#state-management","title":"State Management","text":"<p>Current state of the ReAct loop.</p> Source code in <code>cf/core/react_agent.py</code> <pre><code>@dataclass\nclass ReActState:\n    \"\"\"Current state of the ReAct loop.\"\"\"\n    goal: str\n    current_context: Dict[str, Any] = field(default_factory=dict)\n    observations: List[str] = field(default_factory=list)\n    actions_taken: List[str] = field(default_factory=list)\n    iteration: int = 0\n    max_iterations: int = 20\n    reasoning_history: List[str] = field(default_factory=list)\n    tool_results: Dict[str, Any] = field(default_factory=dict)\n    cache_hits: int = 0\n    error_count: int = 0\n    stuck_detection: List[str] = field(default_factory=list)\n</code></pre>"},{"location":"api/react-agent/#actions-and-observations","title":"Actions and Observations","text":"<p>An action to be taken by the agent.</p> Source code in <code>cf/core/react_agent.py</code> <pre><code>@dataclass\nclass ReActAction:\n    \"\"\"An action to be taken by the agent.\"\"\"\n    action_type: ActionType\n    description: str\n    parameters: Dict[str, Any] = field(default_factory=dict)\n    expected_outcome: str = \"\"\n    tool_name: str = \"\"\n</code></pre> <p>Observation from an action.</p> Source code in <code>cf/core/react_agent.py</code> <pre><code>@dataclass\nclass ReActObservation:\n    \"\"\"Observation from an action.\"\"\"\n    action_taken: str\n    result: Any\n    success: bool\n    insight: str\n    confidence: float = 0.0\n    suggests_next_action: Optional[str] = None\n    goal_progress: float = 0.0  # 0.0 to 1.0\n</code></pre>"},{"location":"api/react-agent/#caching-system","title":"Caching System","text":"<p>Caching system for ReAct agents with optional persistence.</p> Source code in <code>cf/core/react_agent.py</code> <pre><code>class ReActCache:\n    \"\"\"Caching system for ReAct agents with optional persistence.\"\"\"\n\n    def __init__(self, max_size: int = 1000, cache_dir: Optional[str] = None, ttl: int = 3600):\n        self.cache: Dict[str, Dict[str, Any]] = {}  # key -&gt; {value, timestamp, access_time}\n        self.max_size = max_size\n        self.ttl = ttl  # time to live in seconds\n        self.cache_dir = Path(cache_dir) if cache_dir else None\n\n        # Create cache directory if specified\n        if self.cache_dir:\n            self.cache_dir.mkdir(exist_ok=True)\n            self._load_persistent_cache()\n\n    def get(self, key: str) -&gt; Optional[Any]:\n        \"\"\"Get cached value if not expired.\"\"\"\n        if key in self.cache:\n            cache_entry = self.cache[key]\n            current_time = time.time()\n\n            # Check if expired\n            if current_time - cache_entry['timestamp'] &gt; self.ttl:\n                del self.cache[key]\n                return None\n\n            # Update access time\n            cache_entry['access_time'] = current_time\n            return cache_entry['value']\n\n        return None\n\n    def set(self, key: str, value: Any):\n        \"\"\"Set cached value.\"\"\"\n        current_time = time.time()\n\n        # Remove expired entries\n        self._cleanup_expired()\n\n        # Remove LRU if at capacity\n        if len(self.cache) &gt;= self.max_size:\n            self._evict_lru()\n\n        self.cache[key] = {\n            'value': value,\n            'timestamp': current_time,\n            'access_time': current_time\n        }\n\n        # Persist if cache directory is set\n        if self.cache_dir:\n            self._persist_entry(key, self.cache[key])\n\n    def clear(self):\n        \"\"\"Clear all cached values.\"\"\"\n        self.cache.clear()\n        if self.cache_dir:\n            # Clear persistent cache files\n            for cache_file in self.cache_dir.glob(\"*.json\"):\n                cache_file.unlink()\n\n    def _cleanup_expired(self):\n        \"\"\"Remove expired cache entries.\"\"\"\n        current_time = time.time()\n        expired_keys = []\n\n        for key, entry in self.cache.items():\n            if current_time - entry['timestamp'] &gt; self.ttl:\n                expired_keys.append(key)\n\n        for key in expired_keys:\n            del self.cache[key]\n            if self.cache_dir:\n                cache_file = self.cache_dir / f\"{self._hash_key(key)}.json\"\n                if cache_file.exists():\n                    cache_file.unlink()\n\n    def _evict_lru(self):\n        \"\"\"Evict least recently used entry.\"\"\"\n        if not self.cache:\n            return\n\n        lru_key = min(self.cache.keys(), key=lambda k: self.cache[k]['access_time'])\n        del self.cache[lru_key]\n\n        if self.cache_dir:\n            cache_file = self.cache_dir / f\"{self._hash_key(lru_key)}.json\"\n            if cache_file.exists():\n                cache_file.unlink()\n\n    def _load_persistent_cache(self):\n        \"\"\"Load cache from persistent storage.\"\"\"\n        if not self.cache_dir.exists():\n            return\n\n        current_time = time.time()\n\n        for cache_file in self.cache_dir.glob(\"*.json\"):\n            try:\n                with open(cache_file, 'r') as f:\n                    cache_entry = json.load(f)\n\n                # Check if expired\n                if current_time - cache_entry['timestamp'] &gt; self.ttl:\n                    cache_file.unlink()\n                    continue\n\n                # Reconstruct key from filename (this is a simplified approach)\n                key = cache_file.stem\n                self.cache[key] = cache_entry\n\n            except Exception as e:\n                # Remove corrupted cache files\n                cache_file.unlink()\n\n    def _persist_entry(self, key: str, entry: Dict[str, Any]):\n        \"\"\"Persist a cache entry to disk.\"\"\"\n        try:\n            cache_file = self.cache_dir / f\"{self._hash_key(key)}.json\"\n            with open(cache_file, 'w') as f:\n                json.dump(entry, f, default=str)\n        except Exception:\n            # Silently fail persistence - cache still works in memory\n            pass\n\n    def _hash_key(self, key: str) -&gt; str:\n        \"\"\"Create a safe filename from cache key.\"\"\"\n        import hashlib\n        return hashlib.md5(key.encode()).hexdigest()\n</code></pre>"},{"location":"api/react-agent/#cf.core.react_agent.ReActCache.clear","title":"<code>clear()</code>","text":"<p>Clear all cached values.</p> Source code in <code>cf/core/react_agent.py</code> <pre><code>def clear(self):\n    \"\"\"Clear all cached values.\"\"\"\n    self.cache.clear()\n    if self.cache_dir:\n        # Clear persistent cache files\n        for cache_file in self.cache_dir.glob(\"*.json\"):\n            cache_file.unlink()\n</code></pre>"},{"location":"api/react-agent/#cf.core.react_agent.ReActCache.get","title":"<code>get(key)</code>","text":"<p>Get cached value if not expired.</p> Source code in <code>cf/core/react_agent.py</code> <pre><code>def get(self, key: str) -&gt; Optional[Any]:\n    \"\"\"Get cached value if not expired.\"\"\"\n    if key in self.cache:\n        cache_entry = self.cache[key]\n        current_time = time.time()\n\n        # Check if expired\n        if current_time - cache_entry['timestamp'] &gt; self.ttl:\n            del self.cache[key]\n            return None\n\n        # Update access time\n        cache_entry['access_time'] = current_time\n        return cache_entry['value']\n\n    return None\n</code></pre>"},{"location":"api/react-agent/#cf.core.react_agent.ReActCache.set","title":"<code>set(key, value)</code>","text":"<p>Set cached value.</p> Source code in <code>cf/core/react_agent.py</code> <pre><code>def set(self, key: str, value: Any):\n    \"\"\"Set cached value.\"\"\"\n    current_time = time.time()\n\n    # Remove expired entries\n    self._cleanup_expired()\n\n    # Remove LRU if at capacity\n    if len(self.cache) &gt;= self.max_size:\n        self._evict_lru()\n\n    self.cache[key] = {\n        'value': value,\n        'timestamp': current_time,\n        'access_time': current_time\n    }\n\n    # Persist if cache directory is set\n    if self.cache_dir:\n        self._persist_entry(key, self.cache[key])\n</code></pre>"},{"location":"api/react-agent/#usage-examples","title":"Usage Examples","text":""},{"location":"api/react-agent/#basic-agent-implementation","title":"Basic Agent Implementation","text":"<pre><code>from cf.core.react_agent import ReActAgent, ReActAction, ActionType\n\nclass MyCustomAgent(ReActAgent):\n    def reason(self) -&gt; str:\n        \"\"\"Implement domain-specific reasoning logic.\"\"\"\n        if self.state.iteration == 1:\n            return \"Starting analysis by scanning the repository structure\"\n\n        if not self.state.observations:\n            return \"Need to gather more information about the codebase\"\n\n        return \"Continue with detailed examination based on findings\"\n\n    def plan_action(self, reasoning: str) -&gt; ReActAction:\n        \"\"\"Plan the next action based on reasoning.\"\"\"\n        if \"scanning\" in reasoning.lower():\n            return ReActAction(\n                action_type=ActionType.SCAN_DIRECTORY,\n                description=\"Scan repository structure\",\n                parameters={'directory': '.', 'max_depth': 3},\n                expected_outcome=\"Understand project layout\"\n            )\n\n        return ReActAction(\n            action_type=ActionType.READ_FILE,\n            description=\"Read main configuration file\",\n            parameters={'file_path': 'config.py'},\n            expected_outcome=\"Understand project configuration\"\n        )\n\n    def _generate_summary(self) -&gt; str:\n        \"\"\"Generate analysis summary.\"\"\"\n        return f\"Custom analysis completed in {self.state.iteration} iterations\"\n\n# Usage\nagent = MyCustomAgent(repo, config, \"MyAgent\")\nresults = agent.execute_react_loop(\"Analyze project structure\")\n</code></pre>"},{"location":"api/react-agent/#advanced-customization","title":"Advanced Customization","text":"<pre><code>class AdvancedAgent(ReActAgent):\n    def __init__(self, repo, config, agent_name):\n        super().__init__(repo, config, agent_name)\n        self.domain_knowledge = {}\n        self.analysis_patterns = []\n\n    def observe(self, observation):\n        \"\"\"Enhanced observation with domain-specific processing.\"\"\"\n        super().observe(observation)\n\n        # Custom observation processing\n        if observation.success:\n            self._extract_domain_patterns(observation.result)\n            self._update_knowledge_base(observation)\n\n    def _extract_domain_patterns(self, result):\n        \"\"\"Extract domain-specific patterns from results.\"\"\"\n        # Custom pattern extraction logic\n        pass\n\n    def _update_knowledge_base(self, observation):\n        \"\"\"Update internal knowledge base.\"\"\"\n        # Custom knowledge management\n        pass\n</code></pre>"},{"location":"api/react-agent/#integration-with-tools","title":"Integration with Tools","text":"<p>The ReAct agent integrates with the tool ecosystem:</p> <pre><code># Tools are automatically available via ActionType\naction = ReActAction(\n    action_type=ActionType.SEARCH_FILES,\n    description=\"Search for authentication patterns\",\n    parameters={\n        'pattern': 'auth',\n        'file_types': ['.py', '.js'],\n        'max_results': 10\n    }\n)\n</code></pre>"},{"location":"api/react-agent/#error-handling-and-recovery","title":"Error Handling and Recovery","text":"<pre><code>class RobustAgent(ReActAgent):\n    def act(self, action: ReActAction) -&gt; ReActObservation:\n        \"\"\"Act with enhanced error handling.\"\"\"\n        try:\n            return super().act(action)\n        except Exception as e:\n            # Custom error recovery\n            self.logger.warning(f\"Action failed: {e}, attempting recovery\")\n            return self._recover_from_error(action, e)\n\n    def _recover_from_error(self, action, error):\n        \"\"\"Implement custom error recovery.\"\"\"\n        return ReActObservation(\n            action_taken=action.description,\n            result={\"error\": str(error)},\n            success=False,\n            insight=\"Error encountered, adjusting strategy\",\n            confidence=0.0\n        )\n</code></pre>"},{"location":"api/react-agent/#performance-monitoring","title":"Performance Monitoring","text":"<pre><code># Access performance metrics\nagent = MyCustomAgent(repo, config, \"MyAgent\")\nresults = agent.execute_react_loop(\"Analysis goal\")\n\n# Get metrics\nprint(f\"Iterations: {agent.state.iteration}\")\nprint(f\"Cache hits: {agent.state.cache_hits}\")\nprint(f\"Errors: {agent.state.error_count}\")\nprint(f\"Goal progress: {results.get('goal_achieved', False)}\")\n</code></pre>"},{"location":"api/react-agent/#configuration-options","title":"Configuration Options","text":"<pre><code>from cf.core.react_config import ReActConfig\n\n# Custom configuration\ncustom_config = ReActConfig(\n    max_iterations=30,\n    iteration_timeout=45.0,\n    total_timeout=900.0,\n    cache_enabled=True,\n    cache_max_size=2000,\n    error_recovery_enabled=True\n)\n\nagent = MyCustomAgent(repo, config, \"MyAgent\", react_config=custom_config)\n</code></pre>"},{"location":"api/supervisor-agent/","title":"ReAct Supervisor Agent","text":"<p>               Bases: <code>ReActAgent</code></p> <p>Supervisor agent that uses ReAct pattern to orchestrate other ReAct agents.</p> <p>ReAct Loop: 1. Reason: Determine which agents to activate and what questions to ask 2. Act: Delegate tasks to specialized agents and gather their insights 3. Observe: Synthesize results and determine if goal is achieved</p> Source code in <code>cf/agents/react_supervisor_agent.py</code> <pre><code>class ReActSupervisorAgent(ReActAgent):\n    \"\"\"\n    Supervisor agent that uses ReAct pattern to orchestrate other ReAct agents.\n\n    ReAct Loop:\n    1. Reason: Determine which agents to activate and what questions to ask\n    2. Act: Delegate tasks to specialized agents and gather their insights\n    3. Observe: Synthesize results and determine if goal is achieved\n    \"\"\"\n\n    def __init__(self, repo: CodeRepo, config: CfConfig):\n        super().__init__(repo, config, \"SupervisorAgent\")\n\n        # Initialize specialized ReAct agents\n        self.agents = {\n            'documentation': ReActDocumentationAgent(repo, config),\n            'codebase': ReActCodebaseAgent(repo, config),\n            'architecture': ReActArchitectureAgent(repo, config)\n        }\n\n        # Agent coordination state\n        self.agent_results = {}\n        self.cross_agent_insights = []\n        self.synthesis_results = {}\n        self.focus_areas = []\n\n        # Agent priorities based on goal\n        self.agent_priorities = {\n            'documentation': ['doc', 'readme', 'guide', 'manual', 'help'],\n            'codebase': ['code', 'function', 'class', 'implementation', 'logic'],\n            'architecture': ['architecture', 'design', 'pattern', 'component', 'system']\n        }\n\n    def explore_repository(self, goal: str = \"comprehensive analysis\", focus: str = \"all\") -&gt; Dict[str, Any]:\n        \"\"\"\n        Main entry point for repository exploration using ReAct pattern.\n\n        Args:\n            goal: Primary exploration goal\n            focus: Focus area ('all', 'docs', 'code', 'arch')\n\n        Returns:\n            Comprehensive analysis results from orchestrated agents\n        \"\"\"\n        exploration_goal = f\"Orchestrate agents to {goal} with focus on {focus}\"\n        return self.execute_react_loop(exploration_goal, max_iterations=12)\n\n    def reason(self) -&gt; str:\n        \"\"\"\n        Reasoning phase: Determine which agents to activate and what to ask them.\n\n        Returns:\n            Reasoning about next coordination action\n        \"\"\"\n        current_context = self.state.current_context\n        iteration = self.state.iteration\n        goal = self.state.goal\n\n        # Parse focus from goal\n        focus = self._extract_focus_from_goal(goal)\n\n        # First iteration: Plan agent activation strategy\n        if iteration == 1:\n            return f\"I need to coordinate multiple agents to achieve the goal: {goal}. I should determine which agents to activate based on the focus and start with the most relevant ones.\"\n\n        # Early iterations: Activate agents based on focus\n        if iteration &lt;= 3:\n            active_agents = list(self.agent_results.keys())\n\n            if focus == \"all\":\n                if not active_agents:\n                    return \"I should start by activating all three agents (documentation, codebase, architecture) to get comprehensive coverage.\"\n                elif len(active_agents) &lt; 3:\n                    missing_agents = set(self.agents.keys()) - set(active_agents)\n                    return f\"I have activated {len(active_agents)} agents. I should now activate the remaining agents: {', '.join(missing_agents)}\"\n\n            elif focus == \"docs\":\n                if 'documentation' not in active_agents:\n                    return \"The focus is on documentation. I should primarily activate the documentation agent.\"\n                elif 'architecture' not in active_agents:\n                    return \"Documentation analysis is running. I should also activate the architecture agent to understand system design from docs.\"\n\n            elif focus == \"code\":\n                if 'codebase' not in active_agents:\n                    return \"The focus is on code. I should primarily activate the codebase agent.\"\n                elif 'architecture' not in active_agents:\n                    return \"Codebase analysis is running. I should also activate the architecture agent to understand code structure.\"\n\n            elif focus == \"arch\":\n                if 'architecture' not in active_agents:\n                    return \"The focus is on architecture. I should primarily activate the architecture agent.\"\n                elif 'documentation' not in active_agents:\n                    return \"Architecture analysis is running. I should also activate the documentation agent to find design docs.\"\n\n        # Middle iterations: Monitor agents and guide their analysis\n        if iteration &lt;= 6:\n            # Check if we need to provide more specific guidance to agents\n            if self.agent_results:\n                incomplete_agents = []\n                for agent_name, result in self.agent_results.items():\n                    if not result.get('goal_achieved', False):\n                        incomplete_agents.append(agent_name)\n\n                if incomplete_agents:\n                    return f\"Agents {', '.join(incomplete_agents)} haven't achieved their goals yet. I should provide more specific guidance or wait for them to complete.\"\n\n            return \"I should continue monitoring agent progress and start preparing for result synthesis.\"\n\n        # Later iterations: Synthesis and cross-agent insights\n        if iteration &lt;= 9:\n            if len(self.agent_results) &gt;= 2:\n                return \"I have results from multiple agents. I should synthesize their findings to generate cross-agent insights and comprehensive understanding.\"\n            else:\n                return \"I need more agent results before I can perform meaningful synthesis.\"\n\n        # Final iterations: Generate comprehensive results\n        if iteration &lt;= 12:\n            return \"I should generate the final comprehensive analysis by combining all agent results and insights.\"\n\n        # Default reasoning\n        return \"I should continue coordinating agents and synthesizing their results to achieve the exploration goal.\"\n\n    def plan_action(self, reasoning: str) -&gt; ReActAction:\n        \"\"\"\n        Plan the next action based on reasoning.\n\n        Args:\n            reasoning: The reasoning output\n\n        Returns:\n            Action to take\n        \"\"\"\n        iteration = self.state.iteration\n        goal = self.state.goal\n        focus = self._extract_focus_from_goal(goal)\n\n        # Early iterations: Agent activation\n        if iteration &lt;= 3:\n            # Determine which agent to activate\n            active_agents = list(self.agent_results.keys())\n\n            if focus == \"all\":\n                if 'documentation' not in active_agents:\n                    return ReActAction(\n                        action_type=ActionType.LLM_REASONING,\n                        description=\"Activate documentation agent for comprehensive doc analysis\",\n                        parameters={\n                            'context': f\"Goal: {goal}, Focus: {focus}\",\n                            'question': \"What specific documentation aspects should be analyzed?\",\n                            'agent_to_activate': 'documentation'\n                        },\n                        expected_outcome=\"Get documentation analysis results\"\n                    )\n                elif 'codebase' not in active_agents:\n                    return ReActAction(\n                        action_type=ActionType.LLM_REASONING,\n                        description=\"Activate codebase agent for code analysis\",\n                        parameters={\n                            'context': f\"Goal: {goal}, Focus: {focus}\",\n                            'question': \"What specific code aspects should be analyzed?\",\n                            'agent_to_activate': 'codebase'\n                        },\n                        expected_outcome=\"Get codebase analysis results\"\n                    )\n                elif 'architecture' not in active_agents:\n                    return ReActAction(\n                        action_type=ActionType.LLM_REASONING,\n                        description=\"Activate architecture agent for architectural analysis\",\n                        parameters={\n                            'context': f\"Goal: {goal}, Focus: {focus}\",\n                            'question': \"What specific architectural aspects should be analyzed?\",\n                            'agent_to_activate': 'architecture'\n                        },\n                        expected_outcome=\"Get architecture analysis results\"\n                    )\n\n            elif focus == \"docs\":\n                if 'documentation' not in active_agents:\n                    return ReActAction(\n                        action_type=ActionType.LLM_REASONING,\n                        description=\"Activate documentation agent for focused doc analysis\",\n                        parameters={\n                            'context': f\"Goal: {goal}, Focus: {focus}\",\n                            'question': \"What documentation should be analyzed for this goal?\",\n                            'agent_to_activate': 'documentation'\n                        },\n                        expected_outcome=\"Get focused documentation analysis\"\n                    )\n                elif 'architecture' not in active_agents:\n                    return ReActAction(\n                        action_type=ActionType.LLM_REASONING,\n                        description=\"Activate architecture agent to understand system design\",\n                        parameters={\n                            'context': f\"Goal: {goal}, Focus: {focus}\",\n                            'question': \"What architectural aspects can be understood from documentation?\",\n                            'agent_to_activate': 'architecture'\n                        },\n                        expected_outcome=\"Get architecture insights from documentation\"\n                    )\n\n            elif focus == \"code\":\n                if 'codebase' not in active_agents:\n                    return ReActAction(\n                        action_type=ActionType.LLM_REASONING,\n                        description=\"Activate codebase agent for focused code analysis\",\n                        parameters={\n                            'context': f\"Goal: {goal}, Focus: {focus}\",\n                            'question': \"What code aspects should be analyzed for this goal?\",\n                            'agent_to_activate': 'codebase'\n                        },\n                        expected_outcome=\"Get focused codebase analysis\"\n                    )\n                elif 'architecture' not in active_agents:\n                    return ReActAction(\n                        action_type=ActionType.LLM_REASONING,\n                        description=\"Activate architecture agent to understand code structure\",\n                        parameters={\n                            'context': f\"Goal: {goal}, Focus: {focus}\",\n                            'question': \"What architectural patterns can be found in the code?\",\n                            'agent_to_activate': 'architecture'\n                        },\n                        expected_outcome=\"Get architecture insights from code\"\n                    )\n\n            elif focus == \"arch\":\n                if 'architecture' not in active_agents:\n                    return ReActAction(\n                        action_type=ActionType.LLM_REASONING,\n                        description=\"Activate architecture agent for focused architectural analysis\",\n                        parameters={\n                            'context': f\"Goal: {goal}, Focus: {focus}\",\n                            'question': \"What architectural aspects should be analyzed for this goal?\",\n                            'agent_to_activate': 'architecture'\n                        },\n                        expected_outcome=\"Get focused architecture analysis\"\n                    )\n                elif 'documentation' not in active_agents:\n                    return ReActAction(\n                        action_type=ActionType.LLM_REASONING,\n                        description=\"Activate documentation agent to find design docs\",\n                        parameters={\n                            'context': f\"Goal: {goal}, Focus: {focus}\",\n                            'question': \"What documentation supports architectural understanding?\",\n                            'agent_to_activate': 'documentation'\n                        },\n                        expected_outcome=\"Get documentation supporting architecture\"\n                    )\n\n        # Middle iterations: Synthesis and cross-agent insights\n        if iteration &lt;= 9 and len(self.agent_results) &gt;= 2:\n            return ReActAction(\n                action_type=ActionType.LLM_SUMMARY,\n                description=\"Synthesize results from multiple agents\",\n                parameters={\n                    'content': str(self.agent_results),\n                    'summary_type': 'cross_agent_synthesis',\n                    'focus': focus\n                },\n                expected_outcome=\"Generate cross-agent insights and comprehensive understanding\"\n            )\n\n        # Final iterations: Generate comprehensive results\n        return ReActAction(\n            action_type=ActionType.LLM_SUMMARY,\n            description=\"Generate final comprehensive analysis\",\n            parameters={\n                'content': str(self.agent_results),\n                'summary_type': 'final_comprehensive',\n                'focus': focus\n            },\n            expected_outcome=\"Generate final comprehensive analysis results\"\n        )\n\n    def act(self, action: ReActAction) -&gt; ReActObservation:\n        \"\"\"\n        Execute coordination actions including activating agents.\n\n        Args:\n            action: Action to execute\n\n        Returns:\n            Observation from the action\n        \"\"\"\n        # Check if this is an agent activation action\n        if action.parameters.get('agent_to_activate'):\n            agent_name = action.parameters['agent_to_activate']\n            result = self._activate_agent(agent_name, action.parameters)\n\n            # Convert result to ReActObservation\n            success = result.get('goal_achieved', False) if isinstance(result, dict) else False\n            return ReActObservation(\n                action_taken=action.description,\n                result=result,\n                success=success,\n                insight=f\"Activated {agent_name} agent: {'Success' if success else 'Partial completion'}\",\n                confidence=0.8 if success else 0.5,\n                goal_progress=0.3 if success else 0.1\n            )\n\n        # Otherwise, use the parent act method\n        return super().act(action)\n\n    def _activate_agent(self, agent_name: str, parameters: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"\n        Activate a specific agent with given parameters.\n\n        Args:\n            agent_name: Name of the agent to activate\n            parameters: Parameters for the agent\n\n        Returns:\n            Agent execution results\n        \"\"\"\n        if agent_name not in self.agents:\n            return {'error': f'Agent {agent_name} not found'}\n\n        agent = self.agents[agent_name]\n        context = parameters.get('context', '')\n        question = parameters.get('question', '')\n\n        self.logger.info(f\"\ud83c\udfaf Activating {agent_name} agent with question: {question}\")\n\n        try:\n            # Execute the agent's main method\n            if agent_name == 'documentation':\n                result = agent.scan_documentation(question)\n            elif agent_name == 'codebase':\n                result = agent.analyze_codebase(question)\n            elif agent_name == 'architecture':\n                result = agent.map_architecture(question)\n            else:\n                result = {'error': f'Unknown agent method for {agent_name}'}\n\n            # Store the result\n            self.agent_results[agent_name] = result\n\n            self.logger.info(f\"\u2705 {agent_name} agent completed analysis\")\n            return result\n\n        except Exception as e:\n            error_result = {'error': str(e), 'agent': agent_name}\n            self.agent_results[agent_name] = error_result\n            self.logger.error(f\"\u274c {agent_name} agent failed: {e}\")\n            return error_result\n\n    def observe(self, observation):\n        \"\"\"\n        Enhanced observation phase for supervisor coordination.\n\n        Args:\n            observation: Observation from the action\n        \"\"\"\n        super().observe(observation)\n\n        # Process coordination-specific observations\n        if observation.success and observation.result:\n            result = observation.result\n\n            # If this was an agent activation\n            if isinstance(result, dict) and result.get('summary'):\n                # Extract insights from agent results\n                self._extract_cross_agent_insights()\n\n            # If this was a synthesis action\n            elif isinstance(result, dict) and result.get('summary'):\n                self.synthesis_results['latest_synthesis'] = result\n\n    def _extract_cross_agent_insights(self):\n        \"\"\"Extract insights that span multiple agents.\"\"\"\n        if len(self.agent_results) &lt; 2:\n            return\n\n        # Compare documentation and code findings\n        if 'documentation' in self.agent_results and 'codebase' in self.agent_results:\n            doc_results = self.agent_results['documentation']\n            code_results = self.agent_results['codebase']\n\n            # Look for consistency between documentation and code\n            if doc_results.get('summary') and code_results.get('summary'):\n                insight = SupervisorInsight(\n                    insight_type='documentation_code_consistency',\n                    content='Analyzed consistency between documentation and code implementation',\n                    confidence=0.7,\n                    contributing_agents=['documentation', 'codebase'],\n                    evidence=[doc_results.get('summary', ''), code_results.get('summary', '')]\n                )\n                self.cross_agent_insights.append(insight)\n\n        # Compare architecture and code findings\n        if 'architecture' in self.agent_results and 'codebase' in self.agent_results:\n            arch_results = self.agent_results['architecture']\n            code_results = self.agent_results['codebase']\n\n            if arch_results.get('summary') and code_results.get('summary'):\n                insight = SupervisorInsight(\n                    insight_type='architecture_code_alignment',\n                    content='Analyzed alignment between architectural design and code structure',\n                    confidence=0.8,\n                    contributing_agents=['architecture', 'codebase'],\n                    evidence=[arch_results.get('summary', ''), code_results.get('summary', '')]\n                )\n                self.cross_agent_insights.append(insight)\n\n    def _extract_focus_from_goal(self, goal: str) -&gt; str:\n        \"\"\"Extract focus area from goal.\"\"\"\n        goal_lower = goal.lower()\n\n        if 'docs' in goal_lower or 'documentation' in goal_lower:\n            return 'docs'\n        elif 'code' in goal_lower or 'implementation' in goal_lower:\n            return 'code'\n        elif 'arch' in goal_lower or 'architecture' in goal_lower:\n            return 'arch'\n        else:\n            return 'all'\n\n    def _generate_summary(self) -&gt; str:\n        \"\"\"Generate a comprehensive summary of supervisor coordination.\"\"\"\n        summary = f\"Supervisor Coordination Summary:\\\\n\"\n        summary += f\"\u2022 Coordinated {len(self.agent_results)} agents\\\\n\"\n        summary += f\"\u2022 Generated {len(self.cross_agent_insights)} cross-agent insights\\\\n\"\n\n        # Agent results summary\n        for agent_name, result in self.agent_results.items():\n            if result.get('goal_achieved'):\n                summary += f\"\u2022 {agent_name.title()} agent: Successfully completed analysis\\\\n\"\n            elif result.get('error'):\n                summary += f\"\u2022 {agent_name.title()} agent: Failed with error\\\\n\"\n            else:\n                summary += f\"\u2022 {agent_name.title()} agent: Partially completed\\\\n\"\n\n        # Cross-agent insights\n        if self.cross_agent_insights:\n            insight_types = [insight.insight_type for insight in self.cross_agent_insights]\n            summary += f\"\u2022 Cross-agent insights: {', '.join(set(insight_types))}\\\\n\"\n\n        # Cache performance\n        total_cache_hits = sum(\n            result.get('cache_hits', 0) for result in self.agent_results.values()\n            if isinstance(result, dict)\n        )\n        if total_cache_hits &gt; 0:\n            summary += f\"\u2022 Total cache hits: {total_cache_hits}\\\\n\"\n\n        # Error summary\n        total_errors = sum(\n            result.get('error_count', 0) for result in self.agent_results.values()\n            if isinstance(result, dict)\n        )\n        if total_errors &gt; 0:\n            summary += f\"\u2022 Total errors: {total_errors}\\\\n\"\n\n        return summary\n\n    def get_agent_results(self) -&gt; Dict[str, Any]:\n        \"\"\"Get results from all activated agents.\"\"\"\n        return self.agent_results\n\n    def get_cross_agent_insights(self) -&gt; List[SupervisorInsight]:\n        \"\"\"Get insights that span multiple agents.\"\"\"\n        return self.cross_agent_insights\n\n    def get_synthesis_results(self) -&gt; Dict[str, Any]:\n        \"\"\"Get synthesis results.\"\"\"\n        return self.synthesis_results\n\n    def generate_comprehensive_report(self) -&gt; Dict[str, Any]:\n        \"\"\"Generate a comprehensive report from all agents.\"\"\"\n        report = {\n            'goal': self.state.goal,\n            'execution_time': 0,  # Will be updated by caller\n            'agent_results': self.agent_results,\n            'cross_agent_insights': [insight.__dict__ for insight in self.cross_agent_insights],\n            'synthesis_results': self.synthesis_results,\n            'summary': self._generate_summary()\n        }\n\n        # Add agent-specific insights\n        for agent_name, result in self.agent_results.items():\n            if isinstance(result, dict) and result.get('summary'):\n                report[f'{agent_name}_summary'] = result['summary']\n\n        return report\n</code></pre> <p>The <code>ReActSupervisorAgent</code> orchestrates multiple specialized ReAct agents to perform comprehensive codebase analysis through intelligent coordination and cross-agent synthesis.</p>"},{"location":"api/supervisor-agent/#cf.agents.react_supervisor_agent.ReActSupervisorAgent.act","title":"<code>act(action)</code>","text":"<p>Execute coordination actions including activating agents.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>ReActAction</code> <p>Action to execute</p> required <p>Returns:</p> Type Description <code>ReActObservation</code> <p>Observation from the action</p> Source code in <code>cf/agents/react_supervisor_agent.py</code> <pre><code>def act(self, action: ReActAction) -&gt; ReActObservation:\n    \"\"\"\n    Execute coordination actions including activating agents.\n\n    Args:\n        action: Action to execute\n\n    Returns:\n        Observation from the action\n    \"\"\"\n    # Check if this is an agent activation action\n    if action.parameters.get('agent_to_activate'):\n        agent_name = action.parameters['agent_to_activate']\n        result = self._activate_agent(agent_name, action.parameters)\n\n        # Convert result to ReActObservation\n        success = result.get('goal_achieved', False) if isinstance(result, dict) else False\n        return ReActObservation(\n            action_taken=action.description,\n            result=result,\n            success=success,\n            insight=f\"Activated {agent_name} agent: {'Success' if success else 'Partial completion'}\",\n            confidence=0.8 if success else 0.5,\n            goal_progress=0.3 if success else 0.1\n        )\n\n    # Otherwise, use the parent act method\n    return super().act(action)\n</code></pre>"},{"location":"api/supervisor-agent/#cf.agents.react_supervisor_agent.ReActSupervisorAgent.explore_repository","title":"<code>explore_repository(goal='comprehensive analysis', focus='all')</code>","text":"<p>Main entry point for repository exploration using ReAct pattern.</p> <p>Parameters:</p> Name Type Description Default <code>goal</code> <code>str</code> <p>Primary exploration goal</p> <code>'comprehensive analysis'</code> <code>focus</code> <code>str</code> <p>Focus area ('all', 'docs', 'code', 'arch')</p> <code>'all'</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Comprehensive analysis results from orchestrated agents</p> Source code in <code>cf/agents/react_supervisor_agent.py</code> <pre><code>def explore_repository(self, goal: str = \"comprehensive analysis\", focus: str = \"all\") -&gt; Dict[str, Any]:\n    \"\"\"\n    Main entry point for repository exploration using ReAct pattern.\n\n    Args:\n        goal: Primary exploration goal\n        focus: Focus area ('all', 'docs', 'code', 'arch')\n\n    Returns:\n        Comprehensive analysis results from orchestrated agents\n    \"\"\"\n    exploration_goal = f\"Orchestrate agents to {goal} with focus on {focus}\"\n    return self.execute_react_loop(exploration_goal, max_iterations=12)\n</code></pre>"},{"location":"api/supervisor-agent/#cf.agents.react_supervisor_agent.ReActSupervisorAgent.generate_comprehensive_report","title":"<code>generate_comprehensive_report()</code>","text":"<p>Generate a comprehensive report from all agents.</p> Source code in <code>cf/agents/react_supervisor_agent.py</code> <pre><code>def generate_comprehensive_report(self) -&gt; Dict[str, Any]:\n    \"\"\"Generate a comprehensive report from all agents.\"\"\"\n    report = {\n        'goal': self.state.goal,\n        'execution_time': 0,  # Will be updated by caller\n        'agent_results': self.agent_results,\n        'cross_agent_insights': [insight.__dict__ for insight in self.cross_agent_insights],\n        'synthesis_results': self.synthesis_results,\n        'summary': self._generate_summary()\n    }\n\n    # Add agent-specific insights\n    for agent_name, result in self.agent_results.items():\n        if isinstance(result, dict) and result.get('summary'):\n            report[f'{agent_name}_summary'] = result['summary']\n\n    return report\n</code></pre>"},{"location":"api/supervisor-agent/#cf.agents.react_supervisor_agent.ReActSupervisorAgent.get_agent_results","title":"<code>get_agent_results()</code>","text":"<p>Get results from all activated agents.</p> Source code in <code>cf/agents/react_supervisor_agent.py</code> <pre><code>def get_agent_results(self) -&gt; Dict[str, Any]:\n    \"\"\"Get results from all activated agents.\"\"\"\n    return self.agent_results\n</code></pre>"},{"location":"api/supervisor-agent/#cf.agents.react_supervisor_agent.ReActSupervisorAgent.get_cross_agent_insights","title":"<code>get_cross_agent_insights()</code>","text":"<p>Get insights that span multiple agents.</p> Source code in <code>cf/agents/react_supervisor_agent.py</code> <pre><code>def get_cross_agent_insights(self) -&gt; List[SupervisorInsight]:\n    \"\"\"Get insights that span multiple agents.\"\"\"\n    return self.cross_agent_insights\n</code></pre>"},{"location":"api/supervisor-agent/#cf.agents.react_supervisor_agent.ReActSupervisorAgent.get_synthesis_results","title":"<code>get_synthesis_results()</code>","text":"<p>Get synthesis results.</p> Source code in <code>cf/agents/react_supervisor_agent.py</code> <pre><code>def get_synthesis_results(self) -&gt; Dict[str, Any]:\n    \"\"\"Get synthesis results.\"\"\"\n    return self.synthesis_results\n</code></pre>"},{"location":"api/supervisor-agent/#cf.agents.react_supervisor_agent.ReActSupervisorAgent.observe","title":"<code>observe(observation)</code>","text":"<p>Enhanced observation phase for supervisor coordination.</p> <p>Parameters:</p> Name Type Description Default <code>observation</code> <p>Observation from the action</p> required Source code in <code>cf/agents/react_supervisor_agent.py</code> <pre><code>def observe(self, observation):\n    \"\"\"\n    Enhanced observation phase for supervisor coordination.\n\n    Args:\n        observation: Observation from the action\n    \"\"\"\n    super().observe(observation)\n\n    # Process coordination-specific observations\n    if observation.success and observation.result:\n        result = observation.result\n\n        # If this was an agent activation\n        if isinstance(result, dict) and result.get('summary'):\n            # Extract insights from agent results\n            self._extract_cross_agent_insights()\n\n        # If this was a synthesis action\n        elif isinstance(result, dict) and result.get('summary'):\n            self.synthesis_results['latest_synthesis'] = result\n</code></pre>"},{"location":"api/supervisor-agent/#cf.agents.react_supervisor_agent.ReActSupervisorAgent.plan_action","title":"<code>plan_action(reasoning)</code>","text":"<p>Plan the next action based on reasoning.</p> <p>Parameters:</p> Name Type Description Default <code>reasoning</code> <code>str</code> <p>The reasoning output</p> required <p>Returns:</p> Type Description <code>ReActAction</code> <p>Action to take</p> Source code in <code>cf/agents/react_supervisor_agent.py</code> <pre><code>def plan_action(self, reasoning: str) -&gt; ReActAction:\n    \"\"\"\n    Plan the next action based on reasoning.\n\n    Args:\n        reasoning: The reasoning output\n\n    Returns:\n        Action to take\n    \"\"\"\n    iteration = self.state.iteration\n    goal = self.state.goal\n    focus = self._extract_focus_from_goal(goal)\n\n    # Early iterations: Agent activation\n    if iteration &lt;= 3:\n        # Determine which agent to activate\n        active_agents = list(self.agent_results.keys())\n\n        if focus == \"all\":\n            if 'documentation' not in active_agents:\n                return ReActAction(\n                    action_type=ActionType.LLM_REASONING,\n                    description=\"Activate documentation agent for comprehensive doc analysis\",\n                    parameters={\n                        'context': f\"Goal: {goal}, Focus: {focus}\",\n                        'question': \"What specific documentation aspects should be analyzed?\",\n                        'agent_to_activate': 'documentation'\n                    },\n                    expected_outcome=\"Get documentation analysis results\"\n                )\n            elif 'codebase' not in active_agents:\n                return ReActAction(\n                    action_type=ActionType.LLM_REASONING,\n                    description=\"Activate codebase agent for code analysis\",\n                    parameters={\n                        'context': f\"Goal: {goal}, Focus: {focus}\",\n                        'question': \"What specific code aspects should be analyzed?\",\n                        'agent_to_activate': 'codebase'\n                    },\n                    expected_outcome=\"Get codebase analysis results\"\n                )\n            elif 'architecture' not in active_agents:\n                return ReActAction(\n                    action_type=ActionType.LLM_REASONING,\n                    description=\"Activate architecture agent for architectural analysis\",\n                    parameters={\n                        'context': f\"Goal: {goal}, Focus: {focus}\",\n                        'question': \"What specific architectural aspects should be analyzed?\",\n                        'agent_to_activate': 'architecture'\n                    },\n                    expected_outcome=\"Get architecture analysis results\"\n                )\n\n        elif focus == \"docs\":\n            if 'documentation' not in active_agents:\n                return ReActAction(\n                    action_type=ActionType.LLM_REASONING,\n                    description=\"Activate documentation agent for focused doc analysis\",\n                    parameters={\n                        'context': f\"Goal: {goal}, Focus: {focus}\",\n                        'question': \"What documentation should be analyzed for this goal?\",\n                        'agent_to_activate': 'documentation'\n                    },\n                    expected_outcome=\"Get focused documentation analysis\"\n                )\n            elif 'architecture' not in active_agents:\n                return ReActAction(\n                    action_type=ActionType.LLM_REASONING,\n                    description=\"Activate architecture agent to understand system design\",\n                    parameters={\n                        'context': f\"Goal: {goal}, Focus: {focus}\",\n                        'question': \"What architectural aspects can be understood from documentation?\",\n                        'agent_to_activate': 'architecture'\n                    },\n                    expected_outcome=\"Get architecture insights from documentation\"\n                )\n\n        elif focus == \"code\":\n            if 'codebase' not in active_agents:\n                return ReActAction(\n                    action_type=ActionType.LLM_REASONING,\n                    description=\"Activate codebase agent for focused code analysis\",\n                    parameters={\n                        'context': f\"Goal: {goal}, Focus: {focus}\",\n                        'question': \"What code aspects should be analyzed for this goal?\",\n                        'agent_to_activate': 'codebase'\n                    },\n                    expected_outcome=\"Get focused codebase analysis\"\n                )\n            elif 'architecture' not in active_agents:\n                return ReActAction(\n                    action_type=ActionType.LLM_REASONING,\n                    description=\"Activate architecture agent to understand code structure\",\n                    parameters={\n                        'context': f\"Goal: {goal}, Focus: {focus}\",\n                        'question': \"What architectural patterns can be found in the code?\",\n                        'agent_to_activate': 'architecture'\n                    },\n                    expected_outcome=\"Get architecture insights from code\"\n                )\n\n        elif focus == \"arch\":\n            if 'architecture' not in active_agents:\n                return ReActAction(\n                    action_type=ActionType.LLM_REASONING,\n                    description=\"Activate architecture agent for focused architectural analysis\",\n                    parameters={\n                        'context': f\"Goal: {goal}, Focus: {focus}\",\n                        'question': \"What architectural aspects should be analyzed for this goal?\",\n                        'agent_to_activate': 'architecture'\n                    },\n                    expected_outcome=\"Get focused architecture analysis\"\n                )\n            elif 'documentation' not in active_agents:\n                return ReActAction(\n                    action_type=ActionType.LLM_REASONING,\n                    description=\"Activate documentation agent to find design docs\",\n                    parameters={\n                        'context': f\"Goal: {goal}, Focus: {focus}\",\n                        'question': \"What documentation supports architectural understanding?\",\n                        'agent_to_activate': 'documentation'\n                    },\n                    expected_outcome=\"Get documentation supporting architecture\"\n                )\n\n    # Middle iterations: Synthesis and cross-agent insights\n    if iteration &lt;= 9 and len(self.agent_results) &gt;= 2:\n        return ReActAction(\n            action_type=ActionType.LLM_SUMMARY,\n            description=\"Synthesize results from multiple agents\",\n            parameters={\n                'content': str(self.agent_results),\n                'summary_type': 'cross_agent_synthesis',\n                'focus': focus\n            },\n            expected_outcome=\"Generate cross-agent insights and comprehensive understanding\"\n        )\n\n    # Final iterations: Generate comprehensive results\n    return ReActAction(\n        action_type=ActionType.LLM_SUMMARY,\n        description=\"Generate final comprehensive analysis\",\n        parameters={\n            'content': str(self.agent_results),\n            'summary_type': 'final_comprehensive',\n            'focus': focus\n        },\n        expected_outcome=\"Generate final comprehensive analysis results\"\n    )\n</code></pre>"},{"location":"api/supervisor-agent/#cf.agents.react_supervisor_agent.ReActSupervisorAgent.reason","title":"<code>reason()</code>","text":"<p>Reasoning phase: Determine which agents to activate and what to ask them.</p> <p>Returns:</p> Type Description <code>str</code> <p>Reasoning about next coordination action</p> Source code in <code>cf/agents/react_supervisor_agent.py</code> <pre><code>def reason(self) -&gt; str:\n    \"\"\"\n    Reasoning phase: Determine which agents to activate and what to ask them.\n\n    Returns:\n        Reasoning about next coordination action\n    \"\"\"\n    current_context = self.state.current_context\n    iteration = self.state.iteration\n    goal = self.state.goal\n\n    # Parse focus from goal\n    focus = self._extract_focus_from_goal(goal)\n\n    # First iteration: Plan agent activation strategy\n    if iteration == 1:\n        return f\"I need to coordinate multiple agents to achieve the goal: {goal}. I should determine which agents to activate based on the focus and start with the most relevant ones.\"\n\n    # Early iterations: Activate agents based on focus\n    if iteration &lt;= 3:\n        active_agents = list(self.agent_results.keys())\n\n        if focus == \"all\":\n            if not active_agents:\n                return \"I should start by activating all three agents (documentation, codebase, architecture) to get comprehensive coverage.\"\n            elif len(active_agents) &lt; 3:\n                missing_agents = set(self.agents.keys()) - set(active_agents)\n                return f\"I have activated {len(active_agents)} agents. I should now activate the remaining agents: {', '.join(missing_agents)}\"\n\n        elif focus == \"docs\":\n            if 'documentation' not in active_agents:\n                return \"The focus is on documentation. I should primarily activate the documentation agent.\"\n            elif 'architecture' not in active_agents:\n                return \"Documentation analysis is running. I should also activate the architecture agent to understand system design from docs.\"\n\n        elif focus == \"code\":\n            if 'codebase' not in active_agents:\n                return \"The focus is on code. I should primarily activate the codebase agent.\"\n            elif 'architecture' not in active_agents:\n                return \"Codebase analysis is running. I should also activate the architecture agent to understand code structure.\"\n\n        elif focus == \"arch\":\n            if 'architecture' not in active_agents:\n                return \"The focus is on architecture. I should primarily activate the architecture agent.\"\n            elif 'documentation' not in active_agents:\n                return \"Architecture analysis is running. I should also activate the documentation agent to find design docs.\"\n\n    # Middle iterations: Monitor agents and guide their analysis\n    if iteration &lt;= 6:\n        # Check if we need to provide more specific guidance to agents\n        if self.agent_results:\n            incomplete_agents = []\n            for agent_name, result in self.agent_results.items():\n                if not result.get('goal_achieved', False):\n                    incomplete_agents.append(agent_name)\n\n            if incomplete_agents:\n                return f\"Agents {', '.join(incomplete_agents)} haven't achieved their goals yet. I should provide more specific guidance or wait for them to complete.\"\n\n        return \"I should continue monitoring agent progress and start preparing for result synthesis.\"\n\n    # Later iterations: Synthesis and cross-agent insights\n    if iteration &lt;= 9:\n        if len(self.agent_results) &gt;= 2:\n            return \"I have results from multiple agents. I should synthesize their findings to generate cross-agent insights and comprehensive understanding.\"\n        else:\n            return \"I need more agent results before I can perform meaningful synthesis.\"\n\n    # Final iterations: Generate comprehensive results\n    if iteration &lt;= 12:\n        return \"I should generate the final comprehensive analysis by combining all agent results and insights.\"\n\n    # Default reasoning\n    return \"I should continue coordinating agents and synthesizing their results to achieve the exploration goal.\"\n</code></pre>"},{"location":"api/supervisor-agent/#overview","title":"Overview","text":"<p>The Supervisor Agent implements a hierarchical ReAct pattern:</p> <ol> <li>Reasons about which agents to activate based on the analysis goal</li> <li>Acts by delegating tasks to specialized agents</li> <li>Observes results from multiple agents</li> <li>Synthesizes cross-agent insights for comprehensive understanding</li> </ol>"},{"location":"api/supervisor-agent/#specialized-agents","title":"Specialized Agents","text":"<p>The supervisor coordinates these specialized agents:</p> <ul> <li>Documentation Agent: Analyzes README files, guides, and documentation</li> <li>Codebase Agent: Examines source code, functions, and patterns  </li> <li>Architecture Agent: Studies system design and architectural patterns</li> </ul>"},{"location":"api/supervisor-agent/#usage-examples","title":"Usage Examples","text":""},{"location":"api/supervisor-agent/#basic-multi-agent-analysis","title":"Basic Multi-Agent Analysis","text":"<pre><code>from cf.agents.react_supervisor_agent import ReActSupervisorAgent\nfrom cf.aci.repo import LocalCodeRepo\nfrom cf.config import CfConfig\n\n# Initialize supervisor\nrepo = LocalCodeRepo(\"/path/to/repository\")\nconfig = CfConfig()\nsupervisor = ReActSupervisorAgent(repo, config)\n\n# Comprehensive analysis\nresults = supervisor.explore_repository(\n    goal=\"understand authentication system\",\n    focus=\"all\"\n)\n\n# Access individual agent results\nagent_results = supervisor.get_agent_results()\ndoc_results = agent_results.get('documentation')\ncode_results = agent_results.get('codebase')\narch_results = agent_results.get('architecture')\n\nprint(f\"Documentation findings: {doc_results.get('summary')}\")\nprint(f\"Code analysis: {code_results.get('summary')}\")\nprint(f\"Architecture insights: {arch_results.get('summary')}\")\n</code></pre>"},{"location":"api/supervisor-agent/#focused-analysis","title":"Focused Analysis","text":"<pre><code># Documentation-focused analysis\ndoc_results = supervisor.explore_repository(\n    goal=\"analyze API documentation quality\",\n    focus=\"docs\"\n)\n\n# Architecture-focused analysis\narch_results = supervisor.explore_repository(\n    goal=\"understand system design patterns\",\n    focus=\"arch\"\n)\n\n# Code-focused analysis\ncode_results = supervisor.explore_repository(\n    goal=\"identify security vulnerabilities\",\n    focus=\"code\"\n)\n</code></pre>"},{"location":"api/supervisor-agent/#cross-agent-insights","title":"Cross-Agent Insights","text":"<pre><code># Run comprehensive analysis\nresults = supervisor.explore_repository(\n    goal=\"security audit\",\n    focus=\"all\"\n)\n\n# Get cross-agent insights\ninsights = supervisor.get_cross_agent_insights()\n\nfor insight in insights:\n    print(f\"Insight Type: {insight.insight_type}\")\n    print(f\"Content: {insight.content}\")\n    print(f\"Confidence: {insight.confidence}\")\n    print(f\"Contributing Agents: {insight.contributing_agents}\")\n    print(f\"Evidence: {insight.evidence}\")\n    print(\"---\")\n</code></pre>"},{"location":"api/supervisor-agent/#comprehensive-reporting","title":"Comprehensive Reporting","text":"<pre><code># Generate detailed report\nreport = supervisor.generate_comprehensive_report()\n\nprint(f\"Goal: {report['goal']}\")\nprint(f\"Execution Time: {report['execution_time']}\")\nprint(f\"Summary: {report['summary']}\")\n\n# Agent-specific summaries\nfor agent_name in ['documentation', 'codebase', 'architecture']:\n    summary_key = f\"{agent_name}_summary\"\n    if summary_key in report:\n        print(f\"{agent_name.title()} Summary: {report[summary_key]}\")\n\n# Cross-agent insights\nfor insight in report['cross_agent_insights']:\n    print(f\"Cross-Agent Insight: {insight['insight_type']}\")\n</code></pre>"},{"location":"api/supervisor-agent/#agent-coordination-patterns","title":"Agent Coordination Patterns","text":""},{"location":"api/supervisor-agent/#sequential-activation","title":"Sequential Activation","text":"<pre><code>class CustomSupervisor(ReActSupervisorAgent):\n    def plan_action(self, reasoning: str) -&gt; ReActAction:\n        \"\"\"Custom agent activation strategy.\"\"\"\n        active_agents = list(self.agent_results.keys())\n\n        # Custom activation logic\n        if not active_agents:\n            return self._activate_primary_agent()\n        elif len(active_agents) == 1:\n            return self._activate_secondary_agent()\n        else:\n            return self._synthesize_results()\n\n    def _activate_primary_agent(self):\n        \"\"\"Activate primary agent based on goal.\"\"\"\n        if 'security' in self.state.goal.lower():\n            return self._create_activation_action('codebase', 'security analysis')\n        elif 'design' in self.state.goal.lower():\n            return self._create_activation_action('architecture', 'design analysis')\n        else:\n            return self._create_activation_action('documentation', 'overview analysis')\n</code></pre>"},{"location":"api/supervisor-agent/#parallel-coordination","title":"Parallel Coordination","text":"<pre><code># The supervisor can coordinate agents in parallel workflows\nsupervisor = ReActSupervisorAgent(repo, config)\n\n# Start comprehensive analysis that activates multiple agents\nresults = supervisor.explore_repository(\n    goal=\"complete system analysis\", \n    focus=\"all\"\n)\n\n# Agents work in parallel, supervisor synthesizes results\nsynthesis = supervisor.get_synthesis_results()\n</code></pre>"},{"location":"api/supervisor-agent/#performance-optimization","title":"Performance Optimization","text":"<pre><code># Access performance metrics\nresults = supervisor.explore_repository(goal=\"analysis\", focus=\"all\")\n\n# Get detailed performance data\nagent_results = supervisor.get_agent_results()\n\ntotal_cache_hits = sum(\n    result.get('cache_hits', 0) \n    for result in agent_results.values()\n    if isinstance(result, dict)\n)\n\ntotal_errors = sum(\n    result.get('error_count', 0)\n    for result in agent_results.values() \n    if isinstance(result, dict)\n)\n\nprint(f\"Total Cache Hits: {total_cache_hits}\")\nprint(f\"Total Errors: {total_errors}\")\nprint(f\"Success Rate: {(len(agent_results) - total_errors) / len(agent_results) * 100:.1f}%\")\n</code></pre>"},{"location":"api/supervisor-agent/#advanced-configuration","title":"Advanced Configuration","text":"<pre><code>from cf.core.react_config import ReActConfig\n\n# Custom configuration for supervisor\nsupervisor_config = ReActConfig(\n    max_iterations=25,  # Allow more iterations for coordination\n    iteration_timeout=60.0,  # Longer timeout for agent coordination\n    total_timeout=1200.0,  # Extended total timeout\n    cache_enabled=True,\n    error_recovery_enabled=True\n)\n\nsupervisor = ReActSupervisorAgent(\n    repo, \n    config, \n    react_config=supervisor_config\n)\n</code></pre>"},{"location":"api/supervisor-agent/#error-handling-and-recovery","title":"Error Handling and Recovery","text":"<pre><code>class RobustSupervisor(ReActSupervisorAgent):\n    def _activate_agent(self, agent_name: str, parameters: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Enhanced agent activation with error handling.\"\"\"\n        try:\n            return super()._activate_agent(agent_name, parameters)\n        except Exception as e:\n            self.logger.error(f\"Agent {agent_name} activation failed: {e}\")\n\n            # Attempt recovery with alternative agent\n            if agent_name == 'codebase':\n                return self._activate_agent('documentation', parameters)\n            elif agent_name == 'architecture':\n                return self._activate_agent('codebase', parameters)\n            else:\n                return {'error': f'All agents failed: {e}', 'recovery_attempted': True}\n</code></pre>"},{"location":"api/supervisor-agent/#integration-examples","title":"Integration Examples","text":""},{"location":"api/supervisor-agent/#with-custom-analysis-pipeline","title":"With Custom Analysis Pipeline","text":"<pre><code>def comprehensive_security_audit(repo_path: str) -&gt; Dict[str, Any]:\n    \"\"\"Complete security audit using supervisor coordination.\"\"\"\n    repo = LocalCodeRepo(repo_path)\n    config = CfConfig()\n    supervisor = ReActSupervisorAgent(repo, config)\n\n    # Phase 1: Documentation security review\n    doc_security = supervisor.explore_repository(\n        goal=\"security documentation and policies\",\n        focus=\"docs\"\n    )\n\n    # Phase 2: Code security analysis\n    code_security = supervisor.explore_repository(\n        goal=\"security vulnerabilities and patterns\",\n        focus=\"code\"\n    )\n\n    # Phase 3: Architecture security assessment\n    arch_security = supervisor.explore_repository(\n        goal=\"security architecture and design\",\n        focus=\"arch\"\n    )\n\n    # Generate comprehensive security report\n    return supervisor.generate_comprehensive_report()\n</code></pre>"},{"location":"api/supervisor-agent/#with-performance-monitoring","title":"With Performance Monitoring","text":"<pre><code>import time\n\ndef monitored_analysis(repo_path: str, goal: str) -&gt; Dict[str, Any]:\n    \"\"\"Analysis with detailed performance monitoring.\"\"\"\n    start_time = time.time()\n\n    supervisor = ReActSupervisorAgent(LocalCodeRepo(repo_path), CfConfig())\n    results = supervisor.explore_repository(goal=goal, focus=\"all\")\n\n    end_time = time.time()\n\n    # Add performance metrics to results\n    results['performance_metrics'] = {\n        'total_execution_time': end_time - start_time,\n        'agents_activated': len(supervisor.get_agent_results()),\n        'cross_agent_insights': len(supervisor.get_cross_agent_insights()),\n        'cache_efficiency': calculate_cache_efficiency(supervisor),\n        'error_rate': calculate_error_rate(supervisor)\n    }\n\n    return results\n</code></pre>"},{"location":"api/tools/","title":"Tools Ecosystem","text":"<p>Advanced Tools for comprehensive code exploration and analysis.</p> <p>This module provides an extended toolkit for agents to perform sophisticated analysis including architecture diagrams, documentation parsing, and more.</p> <p>The CodeFusion ReAct framework provides a comprehensive set of 8 specialized tools for code exploration and analysis.</p>"},{"location":"api/tools/#cf.tools.advanced_tools.AdvancedExplorationTools","title":"<code>AdvancedExplorationTools</code>","text":"<p>Advanced tools for comprehensive code exploration and analysis.</p> <p>Provides sophisticated analysis capabilities including: - Architecture diagram parsing - Documentation analysis - Dependency graph generation - Code pattern recognition - Test coverage analysis - Performance profiling - Security analysis</p> Source code in <code>cf/tools/advanced_tools.py</code> <pre><code>class AdvancedExplorationTools:\n    \"\"\"\n    Advanced tools for comprehensive code exploration and analysis.\n\n    Provides sophisticated analysis capabilities including:\n    - Architecture diagram parsing\n    - Documentation analysis\n    - Dependency graph generation\n    - Code pattern recognition\n    - Test coverage analysis\n    - Performance profiling\n    - Security analysis\n    \"\"\"\n\n    def __init__(self, repo: CodeRepo, config: CfConfig):\n        self.repo = repo\n        self.config = config\n\n        # Diagram parsers\n        self.diagram_parsers = {\n            'mermaid': self._parse_mermaid_diagram,\n            'plantuml': self._parse_plantuml_diagram,\n            'graphviz': self._parse_graphviz_diagram,\n            'drawio': self._parse_drawio_diagram\n        }\n\n        # Documentation analyzers\n        self.doc_analyzers = {\n            'markdown': self._analyze_markdown_doc,\n            'rst': self._analyze_rst_doc,\n            'asciidoc': self._analyze_asciidoc_doc,\n            'sphinx': self._analyze_sphinx_doc\n        }\n\n        # Code analyzers\n        self.code_analyzers = {\n            'python': self._analyze_python_advanced,\n            'javascript': self._analyze_javascript_advanced,\n            'typescript': self._analyze_typescript_advanced,\n            'java': self._analyze_java_advanced,\n            'go': self._analyze_go_advanced\n        }\n\n        # Pattern matchers\n        self.pattern_matchers = {\n            'design_patterns': self._detect_design_patterns,\n            'anti_patterns': self._detect_anti_patterns,\n            'security_patterns': self._detect_security_patterns,\n            'performance_patterns': self._detect_performance_patterns\n        }\n\n    def analyze_architecture_diagrams(self, path: str = \"\") -&gt; AnalysisResult:\n        \"\"\"\n        Analyze architecture diagrams in the repository.\n\n        Args:\n            path: Optional path to focus analysis on\n\n        Returns:\n            Analysis result containing diagram information\n        \"\"\"\n        import time\n        start_time = time.time()\n\n        try:\n            diagrams = []\n\n            # Find diagram files\n            diagram_files = self._find_diagram_files(path)\n\n            # Parse each diagram\n            for file_path in diagram_files:\n                try:\n                    content = self.repo.read_file(file_path)\n                    diagram_type = self._detect_diagram_type(file_path, content)\n\n                    if diagram_type in self.diagram_parsers:\n                        diagram_info = self.diagram_parsers[diagram_type](file_path, content)\n                        if diagram_info:\n                            diagrams.append(diagram_info)\n\n                except Exception as e:\n                    print(f\"\u26a0\ufe0f  Error parsing diagram {file_path}: {e}\")\n\n            # Also look for embedded diagrams in documentation\n            embedded_diagrams = self._find_embedded_diagrams()\n            diagrams.extend(embedded_diagrams)\n\n            execution_time = time.time() - start_time\n\n            return AnalysisResult(\n                tool_name=\"architecture_diagram_analyzer\",\n                success=True,\n                data={\n                    'diagrams': [d.__dict__ for d in diagrams],\n                    'total_diagrams': len(diagrams),\n                    'diagram_types': list(set(d.diagram_type for d in diagrams)),\n                    'architecture_insights': self._extract_architecture_insights(diagrams)\n                },\n                execution_time=execution_time,\n                metadata={'files_analyzed': len(diagram_files)}\n            )\n\n        except Exception as e:\n            return AnalysisResult(\n                tool_name=\"architecture_diagram_analyzer\",\n                success=False,\n                data={},\n                execution_time=time.time() - start_time,\n                error_message=str(e)\n            )\n\n    def parse_documentation(self, formats: List[str] = None) -&gt; AnalysisResult:\n        \"\"\"\n        Parse and analyze documentation across multiple formats.\n\n        Args:\n            formats: List of documentation formats to analyze\n\n        Returns:\n            Analysis result containing documentation structure\n        \"\"\"\n        import time\n        start_time = time.time()\n\n        if formats is None:\n            formats = ['markdown', 'rst', 'asciidoc']\n\n        try:\n            documentation = []\n\n            # Find documentation files\n            doc_files = self._find_documentation_files(formats)\n\n            # Analyze each documentation file\n            for file_path in doc_files:\n                try:\n                    content = self.repo.read_file(file_path)\n                    doc_format = self._detect_doc_format(file_path)\n\n                    if doc_format in self.doc_analyzers:\n                        doc_structure = self.doc_analyzers[doc_format](file_path, content)\n                        if doc_structure:\n                            documentation.append(doc_structure)\n\n                except Exception as e:\n                    print(f\"\u26a0\ufe0f  Error parsing documentation {file_path}: {e}\")\n\n            # Generate documentation insights\n            insights = self._generate_documentation_insights(documentation)\n\n            execution_time = time.time() - start_time\n\n            return AnalysisResult(\n                tool_name=\"documentation_parser\",\n                success=True,\n                data={\n                    'documentation': [d.__dict__ for d in documentation],\n                    'total_docs': len(documentation),\n                    'doc_types': list(set(d.doc_type for d in documentation)),\n                    'insights': insights,\n                    'coverage_analysis': self._analyze_documentation_coverage(documentation)\n                },\n                execution_time=execution_time,\n                metadata={'files_analyzed': len(doc_files)}\n            )\n\n        except Exception as e:\n            return AnalysisResult(\n                tool_name=\"documentation_parser\",\n                success=False,\n                data={},\n                execution_time=time.time() - start_time,\n                error_message=str(e)\n            )\n\n    def extract_code_patterns(self, language: str = \"python\") -&gt; AnalysisResult:\n        \"\"\"\n        Extract advanced code patterns from the codebase.\n\n        Args:\n            language: Programming language to analyze\n\n        Returns:\n            Analysis result containing code patterns\n        \"\"\"\n        import time\n        start_time = time.time()\n\n        try:\n            patterns = {\n                'design_patterns': [],\n                'anti_patterns': [],\n                'security_patterns': [],\n                'performance_patterns': []\n            }\n\n            # Find code files for the specified language\n            code_files = self._find_code_files_by_language(language)\n\n            # Analyze each file for patterns\n            for file_path in code_files:\n                try:\n                    content = self.repo.read_file(file_path)\n\n                    # Run pattern detection\n                    for pattern_type, detector in self.pattern_matchers.items():\n                        detected_patterns = detector(file_path, content, language)\n                        patterns[pattern_type].extend(detected_patterns)\n\n                except Exception as e:\n                    print(f\"\u26a0\ufe0f  Error analyzing patterns in {file_path}: {e}\")\n\n            # Generate pattern insights\n            insights = self._generate_pattern_insights(patterns)\n\n            execution_time = time.time() - start_time\n\n            return AnalysisResult(\n                tool_name=\"code_pattern_extractor\",\n                success=True,\n                data={\n                    'patterns': patterns,\n                    'insights': insights,\n                    'pattern_summary': self._summarize_patterns(patterns)\n                },\n                execution_time=execution_time,\n                metadata={'files_analyzed': len(code_files), 'language': language}\n            )\n\n        except Exception as e:\n            return AnalysisResult(\n                tool_name=\"code_pattern_extractor\",\n                success=False,\n                data={},\n                execution_time=time.time() - start_time,\n                error_message=str(e)\n            )\n\n    def build_dependency_graph(self, include_external: bool = True) -&gt; AnalysisResult:\n        \"\"\"\n        Build comprehensive dependency graph.\n\n        Args:\n            include_external: Whether to include external dependencies\n\n        Returns:\n            Analysis result containing dependency graph\n        \"\"\"\n        import time\n        start_time = time.time()\n\n        try:\n            dependencies = {\n                'internal': [],\n                'external': [],\n                'graph': {},\n                'cycles': [],\n                'metrics': {}\n            }\n\n            # Analyze internal dependencies\n            internal_deps = self._analyze_internal_dependencies()\n            dependencies['internal'] = internal_deps\n\n            # Analyze external dependencies if requested\n            if include_external:\n                external_deps = self._analyze_external_dependencies()\n                dependencies['external'] = external_deps\n\n            # Build dependency graph\n            graph = self._build_dependency_graph_structure(internal_deps, external_deps if include_external else [])\n            dependencies['graph'] = graph\n\n            # Detect dependency cycles\n            cycles = self._detect_dependency_cycles(graph)\n            dependencies['cycles'] = cycles\n\n            # Calculate dependency metrics\n            metrics = self._calculate_dependency_metrics(graph)\n            dependencies['metrics'] = metrics\n\n            execution_time = time.time() - start_time\n\n            return AnalysisResult(\n                tool_name=\"dependency_graph_builder\",\n                success=True,\n                data=dependencies,\n                execution_time=execution_time,\n                metadata={'include_external': include_external}\n            )\n\n        except Exception as e:\n            return AnalysisResult(\n                tool_name=\"dependency_graph_builder\",\n                success=False,\n                data={},\n                execution_time=time.time() - start_time,\n                error_message=str(e)\n            )\n\n    def analyze_test_coverage(self, test_framework: str = \"auto\") -&gt; AnalysisResult:\n        \"\"\"\n        Analyze test coverage and testing patterns.\n\n        Args:\n            test_framework: Test framework to analyze ('auto', 'pytest', 'jest', etc.)\n\n        Returns:\n            Analysis result containing test coverage information\n        \"\"\"\n        import time\n        start_time = time.time()\n\n        try:\n            coverage_data = {\n                'test_files': [],\n                'coverage_metrics': {},\n                'testing_patterns': [],\n                'recommendations': []\n            }\n\n            # Find test files\n            test_files = self._find_test_files()\n            coverage_data['test_files'] = test_files\n\n            # Analyze test coverage\n            if test_framework == \"auto\":\n                test_framework = self._detect_test_framework()\n\n            if test_framework:\n                coverage_metrics = self._analyze_test_coverage_metrics(test_framework)\n                coverage_data['coverage_metrics'] = coverage_metrics\n\n            # Analyze testing patterns\n            testing_patterns = self._analyze_testing_patterns(test_files)\n            coverage_data['testing_patterns'] = testing_patterns\n\n            # Generate recommendations\n            recommendations = self._generate_testing_recommendations(coverage_data)\n            coverage_data['recommendations'] = recommendations\n\n            execution_time = time.time() - start_time\n\n            return AnalysisResult(\n                tool_name=\"test_coverage_analyzer\",\n                success=True,\n                data=coverage_data,\n                execution_time=execution_time,\n                metadata={'test_framework': test_framework, 'test_files_count': len(test_files)}\n            )\n\n        except Exception as e:\n            return AnalysisResult(\n                tool_name=\"test_coverage_analyzer\",\n                success=False,\n                data={},\n                execution_time=time.time() - start_time,\n                error_message=str(e)\n            )\n\n    def profile_performance(self, entry_points: List[str] = None) -&gt; AnalysisResult:\n        \"\"\"\n        Profile performance characteristics of the codebase.\n\n        Args:\n            entry_points: List of entry points to analyze\n\n        Returns:\n            Analysis result containing performance profile\n        \"\"\"\n        import time\n        start_time = time.time()\n\n        try:\n            performance_data = {\n                'hotspots': [],\n                'complexity_metrics': {},\n                'performance_patterns': [],\n                'optimization_suggestions': []\n            }\n\n            # Find performance hotspots\n            hotspots = self._identify_performance_hotspots(entry_points)\n            performance_data['hotspots'] = hotspots\n\n            # Calculate complexity metrics\n            complexity_metrics = self._calculate_complexity_metrics()\n            performance_data['complexity_metrics'] = complexity_metrics\n\n            # Analyze performance patterns\n            performance_patterns = self._analyze_performance_patterns()\n            performance_data['performance_patterns'] = performance_patterns\n\n            # Generate optimization suggestions\n            optimization_suggestions = self._generate_optimization_suggestions(performance_data)\n            performance_data['optimization_suggestions'] = optimization_suggestions\n\n            execution_time = time.time() - start_time\n\n            return AnalysisResult(\n                tool_name=\"performance_profiler\",\n                success=True,\n                data=performance_data,\n                execution_time=execution_time,\n                metadata={'entry_points': entry_points}\n            )\n\n        except Exception as e:\n            return AnalysisResult(\n                tool_name=\"performance_profiler\",\n                success=False,\n                data={},\n                execution_time=time.time() - start_time,\n                error_message=str(e)\n            )\n\n    def analyze_security(self, security_frameworks: List[str] = None) -&gt; AnalysisResult:\n        \"\"\"\n        Analyze security patterns and vulnerabilities.\n\n        Args:\n            security_frameworks: List of security frameworks to consider\n\n        Returns:\n            Analysis result containing security analysis\n        \"\"\"\n        import time\n        start_time = time.time()\n\n        try:\n            security_data = {\n                'vulnerabilities': [],\n                'security_patterns': [],\n                'authentication_analysis': {},\n                'authorization_analysis': {},\n                'recommendations': []\n            }\n\n            # Scan for common vulnerabilities\n            vulnerabilities = self._scan_vulnerabilities()\n            security_data['vulnerabilities'] = vulnerabilities\n\n            # Analyze security patterns\n            security_patterns = self._analyze_security_patterns()\n            security_data['security_patterns'] = security_patterns\n\n            # Analyze authentication mechanisms\n            auth_analysis = self._analyze_authentication()\n            security_data['authentication_analysis'] = auth_analysis\n\n            # Analyze authorization patterns\n            authz_analysis = self._analyze_authorization()\n            security_data['authorization_analysis'] = authz_analysis\n\n            # Generate security recommendations\n            recommendations = self._generate_security_recommendations(security_data)\n            security_data['recommendations'] = recommendations\n\n            execution_time = time.time() - start_time\n\n            return AnalysisResult(\n                tool_name=\"security_analyzer\",\n                success=True,\n                data=security_data,\n                execution_time=execution_time,\n                metadata={'security_frameworks': security_frameworks}\n            )\n\n        except Exception as e:\n            return AnalysisResult(\n                tool_name=\"security_analyzer\",\n                success=False,\n                data={},\n                execution_time=time.time() - start_time,\n                error_message=str(e)\n            )\n\n    # Helper methods for diagram analysis\n    def _find_diagram_files(self, path: str = \"\") -&gt; List[str]:\n        \"\"\"Find diagram files in the repository.\"\"\"\n        diagram_extensions = ['.mmd', '.mermaid', '.puml', '.plantuml', '.dot', '.gv', '.drawio']\n        diagram_files = []\n\n        for file_info in self.repo.walk_repository():\n            if file_info.is_directory:\n                continue\n\n            file_path = file_info.path\n            if path and not file_path.startswith(path):\n                continue\n\n            file_ext = Path(file_path).suffix.lower()\n            if file_ext in diagram_extensions:\n                diagram_files.append(file_path)\n\n        return diagram_files\n\n    def _detect_diagram_type(self, file_path: str, content: str) -&gt; str:\n        \"\"\"Detect the type of diagram from file path and content.\"\"\"\n        file_ext = Path(file_path).suffix.lower()\n\n        if file_ext in ['.mmd', '.mermaid']:\n            return 'mermaid'\n        elif file_ext in ['.puml', '.plantuml']:\n            return 'plantuml'\n        elif file_ext in ['.dot', '.gv']:\n            return 'graphviz'\n        elif file_ext == '.drawio':\n            return 'drawio'\n\n        # Check content for diagram markers\n        content_lower = content.lower()\n        if 'graph' in content_lower and 'mermaid' in content_lower:\n            return 'mermaid'\n        elif '@startuml' in content_lower:\n            return 'plantuml'\n        elif 'digraph' in content_lower or 'graph' in content_lower:\n            return 'graphviz'\n\n        return 'unknown'\n\n    def _parse_mermaid_diagram(self, file_path: str, content: str) -&gt; Optional[DiagramInfo]:\n        \"\"\"Parse Mermaid diagram.\"\"\"\n        try:\n            # Extract components and relationships from Mermaid syntax\n            components = []\n            relationships = []\n            title = Path(file_path).stem\n\n            # Look for nodes (simplified parsing)\n            node_pattern = r'(\\w+)\\[([^\\]]+)\\]'\n            for match in re.finditer(node_pattern, content):\n                components.append(match.group(2))\n\n            # Look for relationships\n            relationship_pattern = r'(\\w+)\\s*--[-&gt;]*\\s*(\\w+)'\n            for match in re.finditer(relationship_pattern, content):\n                relationships.append(f\"{match.group(1)} -&gt; {match.group(2)}\")\n\n            return DiagramInfo(\n                file_path=file_path,\n                diagram_type='mermaid',\n                title=title,\n                content=content,\n                components=components,\n                relationships=relationships\n            )\n\n        except Exception as e:\n            print(f\"\u26a0\ufe0f  Error parsing Mermaid diagram: {e}\")\n            return None\n\n    def _parse_plantuml_diagram(self, file_path: str, content: str) -&gt; Optional[DiagramInfo]:\n        \"\"\"Parse PlantUML diagram.\"\"\"\n        try:\n            components = []\n            relationships = []\n            title = Path(file_path).stem\n\n            # Look for classes/components\n            class_pattern = r'class\\s+(\\w+)'\n            for match in re.finditer(class_pattern, content):\n                components.append(match.group(1))\n\n            # Look for relationships\n            relationship_pattern = r'(\\w+)\\s*--[-&gt;]*\\s*(\\w+)'\n            for match in re.finditer(relationship_pattern, content):\n                relationships.append(f\"{match.group(1)} -&gt; {match.group(2)}\")\n\n            return DiagramInfo(\n                file_path=file_path,\n                diagram_type='plantuml',\n                title=title,\n                content=content,\n                components=components,\n                relationships=relationships\n            )\n\n        except Exception as e:\n            print(f\"\u26a0\ufe0f  Error parsing PlantUML diagram: {e}\")\n            return None\n\n    def _parse_graphviz_diagram(self, file_path: str, content: str) -&gt; Optional[DiagramInfo]:\n        \"\"\"Parse Graphviz diagram.\"\"\"\n        try:\n            components = []\n            relationships = []\n            title = Path(file_path).stem\n\n            # Look for nodes\n            node_pattern = r'(\\w+)\\s*\\[.*?\\]'\n            for match in re.finditer(node_pattern, content):\n                components.append(match.group(1))\n\n            # Look for edges\n            edge_pattern = r'(\\w+)\\s*-&gt;\\s*(\\w+)'\n            for match in re.finditer(edge_pattern, content):\n                relationships.append(f\"{match.group(1)} -&gt; {match.group(2)}\")\n\n            return DiagramInfo(\n                file_path=file_path,\n                diagram_type='graphviz',\n                title=title,\n                content=content,\n                components=components,\n                relationships=relationships\n            )\n\n        except Exception as e:\n            print(f\"\u26a0\ufe0f  Error parsing Graphviz diagram: {e}\")\n            return None\n\n    def _parse_drawio_diagram(self, file_path: str, content: str) -&gt; Optional[DiagramInfo]:\n        \"\"\"Parse Draw.io diagram.\"\"\"\n        try:\n            # Draw.io files are XML-based, need XML parsing\n            # This is a simplified implementation\n            components = []\n            relationships = []\n            title = Path(file_path).stem\n\n            # Look for text elements (simplified)\n            text_pattern = r'&lt;text[^&gt;]*&gt;([^&lt;]+)&lt;/text&gt;'\n            for match in re.finditer(text_pattern, content):\n                components.append(match.group(1))\n\n            return DiagramInfo(\n                file_path=file_path,\n                diagram_type='drawio',\n                title=title,\n                content=content,\n                components=components,\n                relationships=relationships\n            )\n\n        except Exception as e:\n            print(f\"\u26a0\ufe0f  Error parsing Draw.io diagram: {e}\")\n            return None\n\n    def _find_embedded_diagrams(self) -&gt; List[DiagramInfo]:\n        \"\"\"Find diagrams embedded in documentation.\"\"\"\n        embedded_diagrams = []\n\n        # Look for code blocks with diagram syntax in markdown files\n        for file_info in self.repo.walk_repository():\n            if file_info.is_directory or not file_info.path.endswith('.md'):\n                continue\n\n            try:\n                content = self.repo.read_file(file_info.path)\n\n                # Look for mermaid code blocks\n                mermaid_pattern = r'```mermaid\\s*(.*?)```'\n                for match in re.finditer(mermaid_pattern, content, re.DOTALL):\n                    diagram_content = match.group(1)\n                    diagram_info = self._parse_mermaid_diagram(file_info.path, diagram_content)\n                    if diagram_info:\n                        embedded_diagrams.append(diagram_info)\n\n                # Look for plantuml code blocks\n                plantuml_pattern = r'```plantuml\\s*(.*?)```'\n                for match in re.finditer(plantuml_pattern, content, re.DOTALL):\n                    diagram_content = match.group(1)\n                    diagram_info = self._parse_plantuml_diagram(file_info.path, diagram_content)\n                    if diagram_info:\n                        embedded_diagrams.append(diagram_info)\n\n            except Exception as e:\n                print(f\"\u26a0\ufe0f  Error looking for embedded diagrams in {file_info.path}: {e}\")\n\n        return embedded_diagrams\n\n    def _extract_architecture_insights(self, diagrams: List[DiagramInfo]) -&gt; Dict[str, Any]:\n        \"\"\"Extract architecture insights from diagrams.\"\"\"\n        insights = {\n            'total_components': 0,\n            'total_relationships': 0,\n            'component_frequency': defaultdict(int),\n            'relationship_patterns': [],\n            'architectural_styles': []\n        }\n\n        all_components = []\n        all_relationships = []\n\n        for diagram in diagrams:\n            all_components.extend(diagram.components)\n            all_relationships.extend(diagram.relationships)\n\n        insights['total_components'] = len(set(all_components))\n        insights['total_relationships'] = len(all_relationships)\n\n        # Count component frequency\n        for component in all_components:\n            insights['component_frequency'][component] += 1\n\n        # Convert to regular dict for JSON serialization\n        insights['component_frequency'] = dict(insights['component_frequency'])\n\n        # Analyze relationship patterns\n        relationship_types = set()\n        for rel in all_relationships:\n            if '-&gt;' in rel:\n                relationship_types.add('directed')\n            elif '--' in rel:\n                relationship_types.add('undirected')\n\n        insights['relationship_patterns'] = list(relationship_types)\n\n        # Detect architectural styles (simplified)\n        if len(diagrams) &gt; 0:\n            if any('layer' in d.title.lower() for d in diagrams):\n                insights['architectural_styles'].append('layered')\n            if any('service' in d.title.lower() for d in diagrams):\n                insights['architectural_styles'].append('service-oriented')\n\n        return insights\n\n    # Helper methods for documentation analysis\n    def _find_documentation_files(self, formats: List[str]) -&gt; List[str]:\n        \"\"\"Find documentation files in the repository.\"\"\"\n        doc_extensions = {\n            'markdown': ['.md', '.markdown'],\n            'rst': ['.rst', '.rest'],\n            'asciidoc': ['.adoc', '.asciidoc'],\n            'sphinx': ['.rst', '.md']\n        }\n\n        doc_files = []\n        target_extensions = []\n\n        for fmt in formats:\n            if fmt in doc_extensions:\n                target_extensions.extend(doc_extensions[fmt])\n\n        for file_info in self.repo.walk_repository():\n            if file_info.is_directory:\n                continue\n\n            file_ext = Path(file_info.path).suffix.lower()\n            if file_ext in target_extensions:\n                doc_files.append(file_info.path)\n\n        return doc_files\n\n    def _detect_doc_format(self, file_path: str) -&gt; str:\n        \"\"\"Detect documentation format from file path.\"\"\"\n        file_ext = Path(file_path).suffix.lower()\n\n        if file_ext in ['.md', '.markdown']:\n            return 'markdown'\n        elif file_ext in ['.rst', '.rest']:\n            return 'rst'\n        elif file_ext in ['.adoc', '.asciidoc']:\n            return 'asciidoc'\n\n        return 'unknown'\n\n    def _analyze_markdown_doc(self, file_path: str, content: str) -&gt; Optional[DocumentationStructure]:\n        \"\"\"Analyze Markdown documentation.\"\"\"\n        try:\n            sections = []\n            code_examples = []\n            links = []\n\n            # Extract sections (headers)\n            header_pattern = r'^(#{1,6})\\s+(.+)$'\n            for match in re.finditer(header_pattern, content, re.MULTILINE):\n                sections.append(match.group(2))\n\n            # Extract code examples\n            code_pattern = r'```[\\w]*\\s*(.*?)```'\n            for match in re.finditer(code_pattern, content, re.DOTALL):\n                code_examples.append(match.group(1).strip())\n\n            # Extract links\n            link_pattern = r'\\[([^\\]]+)\\]\\(([^)]+)\\)'\n            for match in re.finditer(link_pattern, content):\n                links.append(match.group(2))\n\n            # Determine document type\n            doc_type = self._classify_doc_type(file_path, content)\n\n            return DocumentationStructure(\n                file_path=file_path,\n                doc_type=doc_type,\n                sections=sections,\n                code_examples=code_examples,\n                links=links,\n                metadata={'format': 'markdown', 'word_count': len(content.split())}\n            )\n\n        except Exception as e:\n            print(f\"\u26a0\ufe0f  Error analyzing Markdown doc: {e}\")\n            return None\n\n    def _analyze_rst_doc(self, file_path: str, content: str) -&gt; Optional[DocumentationStructure]:\n        \"\"\"Analyze reStructuredText documentation.\"\"\"\n        try:\n            sections = []\n            code_examples = []\n            links = []\n\n            # Extract sections (simplified RST parsing)\n            section_pattern = r'^(.+)\\n[=\\-~`#\"^+*]{3,}$'\n            for match in re.finditer(section_pattern, content, re.MULTILINE):\n                sections.append(match.group(1))\n\n            # Extract code blocks\n            code_pattern = r'.. code-block::\\s*\\w*\\s*(.*?)(?=\\n\\S|\\Z)'\n            for match in re.finditer(code_pattern, content, re.DOTALL):\n                code_examples.append(match.group(1).strip())\n\n            # Extract links\n            link_pattern = r'`([^`]+) &lt;([^&gt;]+)&gt;`_'\n            for match in re.finditer(link_pattern, content):\n                links.append(match.group(2))\n\n            doc_type = self._classify_doc_type(file_path, content)\n\n            return DocumentationStructure(\n                file_path=file_path,\n                doc_type=doc_type,\n                sections=sections,\n                code_examples=code_examples,\n                links=links,\n                metadata={'format': 'rst', 'word_count': len(content.split())}\n            )\n\n        except Exception as e:\n            print(f\"\u26a0\ufe0f  Error analyzing RST doc: {e}\")\n            return None\n\n    def _analyze_asciidoc_doc(self, file_path: str, content: str) -&gt; Optional[DocumentationStructure]:\n        \"\"\"Analyze AsciiDoc documentation.\"\"\"\n        try:\n            sections = []\n            code_examples = []\n            links = []\n\n            # Extract sections\n            section_pattern = r'^={1,6}\\s+(.+)$'\n            for match in re.finditer(section_pattern, content, re.MULTILINE):\n                sections.append(match.group(1))\n\n            # Extract code blocks\n            code_pattern = r'\\[source,.*?\\]\\s*----\\s*(.*?)----'\n            for match in re.finditer(code_pattern, content, re.DOTALL):\n                code_examples.append(match.group(1).strip())\n\n            # Extract links\n            link_pattern = r'link:([^[]+)\\[([^\\]]+)\\]'\n            for match in re.finditer(link_pattern, content):\n                links.append(match.group(1))\n\n            doc_type = self._classify_doc_type(file_path, content)\n\n            return DocumentationStructure(\n                file_path=file_path,\n                doc_type=doc_type,\n                sections=sections,\n                code_examples=code_examples,\n                links=links,\n                metadata={'format': 'asciidoc', 'word_count': len(content.split())}\n            )\n\n        except Exception as e:\n            print(f\"\u26a0\ufe0f  Error analyzing AsciiDoc doc: {e}\")\n            return None\n\n    def _analyze_sphinx_doc(self, file_path: str, content: str) -&gt; Optional[DocumentationStructure]:\n        \"\"\"Analyze Sphinx documentation.\"\"\"\n        # For now, treat as RST with Sphinx-specific directives\n        return self._analyze_rst_doc(file_path, content)\n\n    def _classify_doc_type(self, file_path: str, content: str) -&gt; str:\n        \"\"\"Classify documentation type.\"\"\"\n        file_name = Path(file_path).name.lower()\n        content_lower = content.lower()\n\n        if 'readme' in file_name:\n            return 'readme'\n        elif 'api' in file_name or 'api' in content_lower:\n            return 'api'\n        elif 'architecture' in file_name or 'architecture' in content_lower:\n            return 'architecture'\n        elif 'tutorial' in file_name or 'tutorial' in content_lower:\n            return 'tutorial'\n        elif 'guide' in file_name or 'guide' in content_lower:\n            return 'guide'\n        elif 'install' in file_name or 'installation' in content_lower:\n            return 'installation'\n        else:\n            return 'general'\n\n    def _generate_documentation_insights(self, documentation: List[DocumentationStructure]) -&gt; Dict[str, Any]:\n        \"\"\"Generate insights from documentation analysis.\"\"\"\n        insights = {\n            'total_sections': 0,\n            'total_code_examples': 0,\n            'total_links': 0,\n            'doc_type_distribution': defaultdict(int),\n            'common_topics': [],\n            'link_analysis': {}\n        }\n\n        all_sections = []\n        all_links = []\n\n        for doc in documentation:\n            all_sections.extend(doc.sections)\n            all_links.extend(doc.links)\n            insights['total_code_examples'] += len(doc.code_examples)\n            insights['doc_type_distribution'][doc.doc_type] += 1\n\n        insights['total_sections'] = len(all_sections)\n        insights['total_links'] = len(all_links)\n\n        # Convert to regular dict\n        insights['doc_type_distribution'] = dict(insights['doc_type_distribution'])\n\n        # Analyze common topics (simplified)\n        section_words = ' '.join(all_sections).lower().split()\n        word_freq = defaultdict(int)\n        for word in section_words:\n            if len(word) &gt; 3:  # Filter short words\n                word_freq[word] += 1\n\n        insights['common_topics'] = sorted(word_freq.items(), key=lambda x: x[1], reverse=True)[:10]\n\n        # Analyze links\n        external_links = [link for link in all_links if link.startswith('http')]\n        internal_links = [link for link in all_links if not link.startswith('http')]\n\n        insights['link_analysis'] = {\n            'external_links': len(external_links),\n            'internal_links': len(internal_links),\n            'total_links': len(all_links)\n        }\n\n        return insights\n\n    def _analyze_documentation_coverage(self, documentation: List[DocumentationStructure]) -&gt; Dict[str, Any]:\n        \"\"\"Analyze documentation coverage.\"\"\"\n        coverage = {\n            'covered_areas': [],\n            'missing_areas': [],\n            'coverage_score': 0.0\n        }\n\n        # Expected documentation areas\n        expected_areas = ['readme', 'api', 'architecture', 'installation', 'tutorial', 'guide']\n\n        # Check which areas are covered\n        doc_types = set(doc.doc_type for doc in documentation)\n        covered_areas = [area for area in expected_areas if area in doc_types]\n        missing_areas = [area for area in expected_areas if area not in doc_types]\n\n        coverage['covered_areas'] = covered_areas\n        coverage['missing_areas'] = missing_areas\n        coverage['coverage_score'] = len(covered_areas) / len(expected_areas)\n\n        return coverage\n\n    # Simplified implementations for other methods\n    def _find_code_files_by_language(self, language: str) -&gt; List[str]:\n        \"\"\"Find code files for a specific language.\"\"\"\n        extensions = {\n            'python': ['.py'],\n            'javascript': ['.js', '.jsx'],\n            'typescript': ['.ts', '.tsx'],\n            'java': ['.java'],\n            'go': ['.go']\n        }\n\n        target_extensions = extensions.get(language, [])\n        code_files = []\n\n        for file_info in self.repo.walk_repository():\n            if file_info.is_directory:\n                continue\n\n            file_ext = Path(file_info.path).suffix.lower()\n            if file_ext in target_extensions:\n                code_files.append(file_info.path)\n\n        return code_files\n\n    def _detect_design_patterns(self, file_path: str, content: str, language: str) -&gt; List[Dict[str, Any]]:\n        \"\"\"Detect design patterns in code.\"\"\"\n        patterns = []\n\n        # Simplified pattern detection\n        if 'singleton' in content.lower():\n            patterns.append({'pattern': 'Singleton', 'file': file_path, 'confidence': 0.7})\n        if 'factory' in content.lower():\n            patterns.append({'pattern': 'Factory', 'file': file_path, 'confidence': 0.6})\n        if 'observer' in content.lower():\n            patterns.append({'pattern': 'Observer', 'file': file_path, 'confidence': 0.6})\n\n        return patterns\n\n    def _detect_anti_patterns(self, file_path: str, content: str, language: str) -&gt; List[Dict[str, Any]]:\n        \"\"\"Detect anti-patterns in code.\"\"\"\n        patterns = []\n\n        # Simplified anti-pattern detection\n        if len(content.split('\\n')) &gt; 1000:\n            patterns.append({'pattern': 'God Object', 'file': file_path, 'confidence': 0.8})\n\n        return patterns\n\n    def _detect_security_patterns(self, file_path: str, content: str, language: str) -&gt; List[Dict[str, Any]]:\n        \"\"\"Detect security patterns in code.\"\"\"\n        patterns = []\n\n        # Simplified security pattern detection\n        if 'password' in content.lower() and 'hash' in content.lower():\n            patterns.append({'pattern': 'Password Hashing', 'file': file_path, 'confidence': 0.8})\n\n        return patterns\n\n    def _detect_performance_patterns(self, file_path: str, content: str, language: str) -&gt; List[Dict[str, Any]]:\n        \"\"\"Detect performance patterns in code.\"\"\"\n        patterns = []\n\n        # Simplified performance pattern detection\n        if 'cache' in content.lower():\n            patterns.append({'pattern': 'Caching', 'file': file_path, 'confidence': 0.7})\n\n        return patterns\n\n    def _generate_pattern_insights(self, patterns: Dict[str, List]) -&gt; Dict[str, Any]:\n        \"\"\"Generate insights from pattern analysis.\"\"\"\n        insights = {\n            'pattern_counts': {},\n            'most_common_patterns': [],\n            'pattern_distribution': {}\n        }\n\n        for pattern_type, pattern_list in patterns.items():\n            insights['pattern_counts'][pattern_type] = len(pattern_list)\n\n        return insights\n\n    def _summarize_patterns(self, patterns: Dict[str, List]) -&gt; str:\n        \"\"\"Summarize pattern analysis results.\"\"\"\n        total_patterns = sum(len(pattern_list) for pattern_list in patterns.values())\n        return f\"Found {total_patterns} patterns across {len(patterns)} categories\"\n\n    # Additional helper methods would be implemented here for:\n    # - Dependency analysis\n    # - Test coverage analysis\n    # - Performance profiling\n    # - Security analysis\n    # These are simplified for brevity\n\n    def _analyze_internal_dependencies(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"Analyze internal dependencies.\"\"\"\n        return [{'source': 'module_a', 'target': 'module_b', 'type': 'import'}]\n\n    def _analyze_external_dependencies(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"Analyze external dependencies.\"\"\"\n        return [{'name': 'requests', 'version': '2.25.1', 'type': 'package'}]\n\n    def _build_dependency_graph_structure(self, internal_deps: List, external_deps: List) -&gt; Dict[str, Any]:\n        \"\"\"Build dependency graph structure.\"\"\"\n        return {'nodes': [], 'edges': []}\n\n    def _detect_dependency_cycles(self, graph: Dict[str, Any]) -&gt; List[List[str]]:\n        \"\"\"Detect dependency cycles.\"\"\"\n        return []\n\n    def _calculate_dependency_metrics(self, graph: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Calculate dependency metrics.\"\"\"\n        return {'total_dependencies': 0, 'cycle_count': 0}\n\n    def _find_test_files(self) -&gt; List[str]:\n        \"\"\"Find test files.\"\"\"\n        return []\n\n    def _detect_test_framework(self) -&gt; str:\n        \"\"\"Detect test framework.\"\"\"\n        return 'pytest'\n\n    def _analyze_test_coverage_metrics(self, framework: str) -&gt; Dict[str, Any]:\n        \"\"\"Analyze test coverage metrics.\"\"\"\n        return {'line_coverage': 0.85, 'branch_coverage': 0.78}\n\n    def _analyze_testing_patterns(self, test_files: List[str]) -&gt; List[Dict[str, Any]]:\n        \"\"\"Analyze testing patterns.\"\"\"\n        return []\n\n    def _generate_testing_recommendations(self, coverage_data: Dict[str, Any]) -&gt; List[str]:\n        \"\"\"Generate testing recommendations.\"\"\"\n        return ['Add more unit tests', 'Improve test coverage']\n\n    def _identify_performance_hotspots(self, entry_points: List[str]) -&gt; List[Dict[str, Any]]:\n        \"\"\"Identify performance hotspots.\"\"\"\n        return []\n\n    def _calculate_complexity_metrics(self) -&gt; Dict[str, Any]:\n        \"\"\"Calculate complexity metrics.\"\"\"\n        return {'cyclomatic_complexity': 10, 'cognitive_complexity': 15}\n\n    def _analyze_performance_patterns(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"Analyze performance patterns.\"\"\"\n        return []\n\n    def _generate_optimization_suggestions(self, performance_data: Dict[str, Any]) -&gt; List[str]:\n        \"\"\"Generate optimization suggestions.\"\"\"\n        return ['Optimize database queries', 'Add caching layer']\n\n    def _scan_vulnerabilities(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"Scan for vulnerabilities.\"\"\"\n        return []\n\n    def _analyze_security_patterns(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"Analyze security patterns.\"\"\"\n        return []\n\n    def _analyze_authentication(self) -&gt; Dict[str, Any]:\n        \"\"\"Analyze authentication mechanisms.\"\"\"\n        return {'methods': ['JWT', 'OAuth'], 'secure': True}\n\n    def _analyze_authorization(self) -&gt; Dict[str, Any]:\n        \"\"\"Analyze authorization patterns.\"\"\"\n        return {'methods': ['RBAC'], 'secure': True}\n\n    def _generate_security_recommendations(self, security_data: Dict[str, Any]) -&gt; List[str]:\n        \"\"\"Generate security recommendations.\"\"\"\n        return ['Implement input validation', 'Add rate limiting']\n</code></pre>"},{"location":"api/tools/#cf.tools.advanced_tools.AdvancedExplorationTools.analyze_architecture_diagrams","title":"<code>analyze_architecture_diagrams(path='')</code>","text":"<p>Analyze architecture diagrams in the repository.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Optional path to focus analysis on</p> <code>''</code> <p>Returns:</p> Type Description <code>AnalysisResult</code> <p>Analysis result containing diagram information</p> Source code in <code>cf/tools/advanced_tools.py</code> <pre><code>def analyze_architecture_diagrams(self, path: str = \"\") -&gt; AnalysisResult:\n    \"\"\"\n    Analyze architecture diagrams in the repository.\n\n    Args:\n        path: Optional path to focus analysis on\n\n    Returns:\n        Analysis result containing diagram information\n    \"\"\"\n    import time\n    start_time = time.time()\n\n    try:\n        diagrams = []\n\n        # Find diagram files\n        diagram_files = self._find_diagram_files(path)\n\n        # Parse each diagram\n        for file_path in diagram_files:\n            try:\n                content = self.repo.read_file(file_path)\n                diagram_type = self._detect_diagram_type(file_path, content)\n\n                if diagram_type in self.diagram_parsers:\n                    diagram_info = self.diagram_parsers[diagram_type](file_path, content)\n                    if diagram_info:\n                        diagrams.append(diagram_info)\n\n            except Exception as e:\n                print(f\"\u26a0\ufe0f  Error parsing diagram {file_path}: {e}\")\n\n        # Also look for embedded diagrams in documentation\n        embedded_diagrams = self._find_embedded_diagrams()\n        diagrams.extend(embedded_diagrams)\n\n        execution_time = time.time() - start_time\n\n        return AnalysisResult(\n            tool_name=\"architecture_diagram_analyzer\",\n            success=True,\n            data={\n                'diagrams': [d.__dict__ for d in diagrams],\n                'total_diagrams': len(diagrams),\n                'diagram_types': list(set(d.diagram_type for d in diagrams)),\n                'architecture_insights': self._extract_architecture_insights(diagrams)\n            },\n            execution_time=execution_time,\n            metadata={'files_analyzed': len(diagram_files)}\n        )\n\n    except Exception as e:\n        return AnalysisResult(\n            tool_name=\"architecture_diagram_analyzer\",\n            success=False,\n            data={},\n            execution_time=time.time() - start_time,\n            error_message=str(e)\n        )\n</code></pre>"},{"location":"api/tools/#cf.tools.advanced_tools.AdvancedExplorationTools.analyze_security","title":"<code>analyze_security(security_frameworks=None)</code>","text":"<p>Analyze security patterns and vulnerabilities.</p> <p>Parameters:</p> Name Type Description Default <code>security_frameworks</code> <code>List[str]</code> <p>List of security frameworks to consider</p> <code>None</code> <p>Returns:</p> Type Description <code>AnalysisResult</code> <p>Analysis result containing security analysis</p> Source code in <code>cf/tools/advanced_tools.py</code> <pre><code>def analyze_security(self, security_frameworks: List[str] = None) -&gt; AnalysisResult:\n    \"\"\"\n    Analyze security patterns and vulnerabilities.\n\n    Args:\n        security_frameworks: List of security frameworks to consider\n\n    Returns:\n        Analysis result containing security analysis\n    \"\"\"\n    import time\n    start_time = time.time()\n\n    try:\n        security_data = {\n            'vulnerabilities': [],\n            'security_patterns': [],\n            'authentication_analysis': {},\n            'authorization_analysis': {},\n            'recommendations': []\n        }\n\n        # Scan for common vulnerabilities\n        vulnerabilities = self._scan_vulnerabilities()\n        security_data['vulnerabilities'] = vulnerabilities\n\n        # Analyze security patterns\n        security_patterns = self._analyze_security_patterns()\n        security_data['security_patterns'] = security_patterns\n\n        # Analyze authentication mechanisms\n        auth_analysis = self._analyze_authentication()\n        security_data['authentication_analysis'] = auth_analysis\n\n        # Analyze authorization patterns\n        authz_analysis = self._analyze_authorization()\n        security_data['authorization_analysis'] = authz_analysis\n\n        # Generate security recommendations\n        recommendations = self._generate_security_recommendations(security_data)\n        security_data['recommendations'] = recommendations\n\n        execution_time = time.time() - start_time\n\n        return AnalysisResult(\n            tool_name=\"security_analyzer\",\n            success=True,\n            data=security_data,\n            execution_time=execution_time,\n            metadata={'security_frameworks': security_frameworks}\n        )\n\n    except Exception as e:\n        return AnalysisResult(\n            tool_name=\"security_analyzer\",\n            success=False,\n            data={},\n            execution_time=time.time() - start_time,\n            error_message=str(e)\n        )\n</code></pre>"},{"location":"api/tools/#cf.tools.advanced_tools.AdvancedExplorationTools.analyze_test_coverage","title":"<code>analyze_test_coverage(test_framework='auto')</code>","text":"<p>Analyze test coverage and testing patterns.</p> <p>Parameters:</p> Name Type Description Default <code>test_framework</code> <code>str</code> <p>Test framework to analyze ('auto', 'pytest', 'jest', etc.)</p> <code>'auto'</code> <p>Returns:</p> Type Description <code>AnalysisResult</code> <p>Analysis result containing test coverage information</p> Source code in <code>cf/tools/advanced_tools.py</code> <pre><code>def analyze_test_coverage(self, test_framework: str = \"auto\") -&gt; AnalysisResult:\n    \"\"\"\n    Analyze test coverage and testing patterns.\n\n    Args:\n        test_framework: Test framework to analyze ('auto', 'pytest', 'jest', etc.)\n\n    Returns:\n        Analysis result containing test coverage information\n    \"\"\"\n    import time\n    start_time = time.time()\n\n    try:\n        coverage_data = {\n            'test_files': [],\n            'coverage_metrics': {},\n            'testing_patterns': [],\n            'recommendations': []\n        }\n\n        # Find test files\n        test_files = self._find_test_files()\n        coverage_data['test_files'] = test_files\n\n        # Analyze test coverage\n        if test_framework == \"auto\":\n            test_framework = self._detect_test_framework()\n\n        if test_framework:\n            coverage_metrics = self._analyze_test_coverage_metrics(test_framework)\n            coverage_data['coverage_metrics'] = coverage_metrics\n\n        # Analyze testing patterns\n        testing_patterns = self._analyze_testing_patterns(test_files)\n        coverage_data['testing_patterns'] = testing_patterns\n\n        # Generate recommendations\n        recommendations = self._generate_testing_recommendations(coverage_data)\n        coverage_data['recommendations'] = recommendations\n\n        execution_time = time.time() - start_time\n\n        return AnalysisResult(\n            tool_name=\"test_coverage_analyzer\",\n            success=True,\n            data=coverage_data,\n            execution_time=execution_time,\n            metadata={'test_framework': test_framework, 'test_files_count': len(test_files)}\n        )\n\n    except Exception as e:\n        return AnalysisResult(\n            tool_name=\"test_coverage_analyzer\",\n            success=False,\n            data={},\n            execution_time=time.time() - start_time,\n            error_message=str(e)\n        )\n</code></pre>"},{"location":"api/tools/#cf.tools.advanced_tools.AdvancedExplorationTools.build_dependency_graph","title":"<code>build_dependency_graph(include_external=True)</code>","text":"<p>Build comprehensive dependency graph.</p> <p>Parameters:</p> Name Type Description Default <code>include_external</code> <code>bool</code> <p>Whether to include external dependencies</p> <code>True</code> <p>Returns:</p> Type Description <code>AnalysisResult</code> <p>Analysis result containing dependency graph</p> Source code in <code>cf/tools/advanced_tools.py</code> <pre><code>def build_dependency_graph(self, include_external: bool = True) -&gt; AnalysisResult:\n    \"\"\"\n    Build comprehensive dependency graph.\n\n    Args:\n        include_external: Whether to include external dependencies\n\n    Returns:\n        Analysis result containing dependency graph\n    \"\"\"\n    import time\n    start_time = time.time()\n\n    try:\n        dependencies = {\n            'internal': [],\n            'external': [],\n            'graph': {},\n            'cycles': [],\n            'metrics': {}\n        }\n\n        # Analyze internal dependencies\n        internal_deps = self._analyze_internal_dependencies()\n        dependencies['internal'] = internal_deps\n\n        # Analyze external dependencies if requested\n        if include_external:\n            external_deps = self._analyze_external_dependencies()\n            dependencies['external'] = external_deps\n\n        # Build dependency graph\n        graph = self._build_dependency_graph_structure(internal_deps, external_deps if include_external else [])\n        dependencies['graph'] = graph\n\n        # Detect dependency cycles\n        cycles = self._detect_dependency_cycles(graph)\n        dependencies['cycles'] = cycles\n\n        # Calculate dependency metrics\n        metrics = self._calculate_dependency_metrics(graph)\n        dependencies['metrics'] = metrics\n\n        execution_time = time.time() - start_time\n\n        return AnalysisResult(\n            tool_name=\"dependency_graph_builder\",\n            success=True,\n            data=dependencies,\n            execution_time=execution_time,\n            metadata={'include_external': include_external}\n        )\n\n    except Exception as e:\n        return AnalysisResult(\n            tool_name=\"dependency_graph_builder\",\n            success=False,\n            data={},\n            execution_time=time.time() - start_time,\n            error_message=str(e)\n        )\n</code></pre>"},{"location":"api/tools/#cf.tools.advanced_tools.AdvancedExplorationTools.extract_code_patterns","title":"<code>extract_code_patterns(language='python')</code>","text":"<p>Extract advanced code patterns from the codebase.</p> <p>Parameters:</p> Name Type Description Default <code>language</code> <code>str</code> <p>Programming language to analyze</p> <code>'python'</code> <p>Returns:</p> Type Description <code>AnalysisResult</code> <p>Analysis result containing code patterns</p> Source code in <code>cf/tools/advanced_tools.py</code> <pre><code>def extract_code_patterns(self, language: str = \"python\") -&gt; AnalysisResult:\n    \"\"\"\n    Extract advanced code patterns from the codebase.\n\n    Args:\n        language: Programming language to analyze\n\n    Returns:\n        Analysis result containing code patterns\n    \"\"\"\n    import time\n    start_time = time.time()\n\n    try:\n        patterns = {\n            'design_patterns': [],\n            'anti_patterns': [],\n            'security_patterns': [],\n            'performance_patterns': []\n        }\n\n        # Find code files for the specified language\n        code_files = self._find_code_files_by_language(language)\n\n        # Analyze each file for patterns\n        for file_path in code_files:\n            try:\n                content = self.repo.read_file(file_path)\n\n                # Run pattern detection\n                for pattern_type, detector in self.pattern_matchers.items():\n                    detected_patterns = detector(file_path, content, language)\n                    patterns[pattern_type].extend(detected_patterns)\n\n            except Exception as e:\n                print(f\"\u26a0\ufe0f  Error analyzing patterns in {file_path}: {e}\")\n\n        # Generate pattern insights\n        insights = self._generate_pattern_insights(patterns)\n\n        execution_time = time.time() - start_time\n\n        return AnalysisResult(\n            tool_name=\"code_pattern_extractor\",\n            success=True,\n            data={\n                'patterns': patterns,\n                'insights': insights,\n                'pattern_summary': self._summarize_patterns(patterns)\n            },\n            execution_time=execution_time,\n            metadata={'files_analyzed': len(code_files), 'language': language}\n        )\n\n    except Exception as e:\n        return AnalysisResult(\n            tool_name=\"code_pattern_extractor\",\n            success=False,\n            data={},\n            execution_time=time.time() - start_time,\n            error_message=str(e)\n        )\n</code></pre>"},{"location":"api/tools/#cf.tools.advanced_tools.AdvancedExplorationTools.parse_documentation","title":"<code>parse_documentation(formats=None)</code>","text":"<p>Parse and analyze documentation across multiple formats.</p> <p>Parameters:</p> Name Type Description Default <code>formats</code> <code>List[str]</code> <p>List of documentation formats to analyze</p> <code>None</code> <p>Returns:</p> Type Description <code>AnalysisResult</code> <p>Analysis result containing documentation structure</p> Source code in <code>cf/tools/advanced_tools.py</code> <pre><code>def parse_documentation(self, formats: List[str] = None) -&gt; AnalysisResult:\n    \"\"\"\n    Parse and analyze documentation across multiple formats.\n\n    Args:\n        formats: List of documentation formats to analyze\n\n    Returns:\n        Analysis result containing documentation structure\n    \"\"\"\n    import time\n    start_time = time.time()\n\n    if formats is None:\n        formats = ['markdown', 'rst', 'asciidoc']\n\n    try:\n        documentation = []\n\n        # Find documentation files\n        doc_files = self._find_documentation_files(formats)\n\n        # Analyze each documentation file\n        for file_path in doc_files:\n            try:\n                content = self.repo.read_file(file_path)\n                doc_format = self._detect_doc_format(file_path)\n\n                if doc_format in self.doc_analyzers:\n                    doc_structure = self.doc_analyzers[doc_format](file_path, content)\n                    if doc_structure:\n                        documentation.append(doc_structure)\n\n            except Exception as e:\n                print(f\"\u26a0\ufe0f  Error parsing documentation {file_path}: {e}\")\n\n        # Generate documentation insights\n        insights = self._generate_documentation_insights(documentation)\n\n        execution_time = time.time() - start_time\n\n        return AnalysisResult(\n            tool_name=\"documentation_parser\",\n            success=True,\n            data={\n                'documentation': [d.__dict__ for d in documentation],\n                'total_docs': len(documentation),\n                'doc_types': list(set(d.doc_type for d in documentation)),\n                'insights': insights,\n                'coverage_analysis': self._analyze_documentation_coverage(documentation)\n            },\n            execution_time=execution_time,\n            metadata={'files_analyzed': len(doc_files)}\n        )\n\n    except Exception as e:\n        return AnalysisResult(\n            tool_name=\"documentation_parser\",\n            success=False,\n            data={},\n            execution_time=time.time() - start_time,\n            error_message=str(e)\n        )\n</code></pre>"},{"location":"api/tools/#cf.tools.advanced_tools.AdvancedExplorationTools.profile_performance","title":"<code>profile_performance(entry_points=None)</code>","text":"<p>Profile performance characteristics of the codebase.</p> <p>Parameters:</p> Name Type Description Default <code>entry_points</code> <code>List[str]</code> <p>List of entry points to analyze</p> <code>None</code> <p>Returns:</p> Type Description <code>AnalysisResult</code> <p>Analysis result containing performance profile</p> Source code in <code>cf/tools/advanced_tools.py</code> <pre><code>def profile_performance(self, entry_points: List[str] = None) -&gt; AnalysisResult:\n    \"\"\"\n    Profile performance characteristics of the codebase.\n\n    Args:\n        entry_points: List of entry points to analyze\n\n    Returns:\n        Analysis result containing performance profile\n    \"\"\"\n    import time\n    start_time = time.time()\n\n    try:\n        performance_data = {\n            'hotspots': [],\n            'complexity_metrics': {},\n            'performance_patterns': [],\n            'optimization_suggestions': []\n        }\n\n        # Find performance hotspots\n        hotspots = self._identify_performance_hotspots(entry_points)\n        performance_data['hotspots'] = hotspots\n\n        # Calculate complexity metrics\n        complexity_metrics = self._calculate_complexity_metrics()\n        performance_data['complexity_metrics'] = complexity_metrics\n\n        # Analyze performance patterns\n        performance_patterns = self._analyze_performance_patterns()\n        performance_data['performance_patterns'] = performance_patterns\n\n        # Generate optimization suggestions\n        optimization_suggestions = self._generate_optimization_suggestions(performance_data)\n        performance_data['optimization_suggestions'] = optimization_suggestions\n\n        execution_time = time.time() - start_time\n\n        return AnalysisResult(\n            tool_name=\"performance_profiler\",\n            success=True,\n            data=performance_data,\n            execution_time=execution_time,\n            metadata={'entry_points': entry_points}\n        )\n\n    except Exception as e:\n        return AnalysisResult(\n            tool_name=\"performance_profiler\",\n            success=False,\n            data={},\n            execution_time=time.time() - start_time,\n            error_message=str(e)\n        )\n</code></pre>"},{"location":"api/tools/#cf.tools.advanced_tools.AnalysisResult","title":"<code>AnalysisResult</code>  <code>dataclass</code>","text":"<p>Represents the result of a tool analysis.</p> Source code in <code>cf/tools/advanced_tools.py</code> <pre><code>@dataclass\nclass AnalysisResult:\n    \"\"\"Represents the result of a tool analysis.\"\"\"\n    tool_name: str\n    success: bool\n    data: Any\n    metadata: Dict[str, Any] = field(default_factory=dict)\n    execution_time: float = 0.0\n    error_message: Optional[str] = None\n</code></pre>"},{"location":"api/tools/#cf.tools.advanced_tools.DiagramInfo","title":"<code>DiagramInfo</code>  <code>dataclass</code>","text":"<p>Information about a diagram found in the codebase.</p> Source code in <code>cf/tools/advanced_tools.py</code> <pre><code>@dataclass\nclass DiagramInfo:\n    \"\"\"Information about a diagram found in the codebase.\"\"\"\n    file_path: str\n    diagram_type: str  # 'mermaid', 'plantuml', 'graphviz', 'draw.io'\n    title: str\n    content: str\n    components: List[str] = field(default_factory=list)\n    relationships: List[str] = field(default_factory=list)\n</code></pre>"},{"location":"api/tools/#cf.tools.advanced_tools.DocumentationStructure","title":"<code>DocumentationStructure</code>  <code>dataclass</code>","text":"<p>Structure of documentation found in the codebase.</p> Source code in <code>cf/tools/advanced_tools.py</code> <pre><code>@dataclass\nclass DocumentationStructure:\n    \"\"\"Structure of documentation found in the codebase.\"\"\"\n    file_path: str\n    doc_type: str  # 'readme', 'api', 'architecture', 'tutorial'\n    sections: List[str]\n    code_examples: List[str]\n    links: List[str]\n    metadata: Dict[str, Any] = field(default_factory=dict)\n</code></pre>"},{"location":"api/tools/#core-tools","title":"Core Tools","text":""},{"location":"api/tools/#directory-and-file-operations","title":"Directory and File Operations","text":"<ul> <li>SCAN_DIRECTORY: Recursive directory structure exploration</li> <li>LIST_FILES: Pattern-based file discovery with filtering</li> <li>READ_FILE: Intelligent file content reading with limits</li> </ul>"},{"location":"api/tools/#search-and-analysis","title":"Search and Analysis","text":"<ul> <li>SEARCH_FILES: Multi-file pattern searching with context</li> <li>ANALYZE_CODE: Code structure and complexity analysis</li> </ul>"},{"location":"api/tools/#ai-powered-tools","title":"AI-Powered Tools","text":"<ul> <li>LLM_REASONING: AI-powered decision making and analysis</li> <li>LLM_SUMMARY: Intelligent content summarization</li> </ul>"},{"location":"api/tools/#caching-operations","title":"Caching Operations","text":"<ul> <li>CACHE_OPERATIONS: Persistent memory management with TTL</li> </ul>"},{"location":"api/tools/#usage-examples","title":"Usage Examples","text":""},{"location":"api/tools/#basic-tool-usage","title":"Basic Tool Usage","text":"<pre><code>from cf.tools.advanced_tools import AdvancedTools\nfrom cf.aci.repo import LocalCodeRepo\n\n# Initialize tools\nrepo = LocalCodeRepo(\"/path/to/repository\")\ntools = AdvancedTools(repo)\n\n# Scan directory\nresult = tools.scan_directory(\".\", max_depth=2)\nprint(f\"Found {len(result['contents'])} items\")\n\n# Search files\nsearch_result = tools.search_files(\"authentication\", file_types=['.py'], max_results=10)\nprint(f\"Found {len(search_result['results'])} matches\")\n\n# Read file\nfile_content = tools.read_file(\"main.py\", max_lines=100)\nprint(f\"Read {len(file_content['content'])} characters\")\n</code></pre>"},{"location":"api/tools/#advanced-tool-integration","title":"Advanced Tool Integration","text":"<p>Tools are automatically integrated with ReAct agents through the ActionType system:</p> <pre><code>from cf.core.react_agent import ReActAction, ActionType\n\n# Tools are used via actions\naction = ReActAction(\n    action_type=ActionType.SCAN_DIRECTORY,\n    description=\"Scan repository structure\",\n    parameters={'directory': '.', 'max_depth': 3}\n)\n\n# Agents automatically route to appropriate tools\n</code></pre> <p>For complete tool documentation, see the source code.</p>"},{"location":"dev/CODE_OF_CONDUCT/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"dev/CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"dev/CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the   overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or   advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email   address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"dev/CODE_OF_CONDUCT/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"dev/CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"dev/CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at . All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"dev/CODE_OF_CONDUCT/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"dev/CODE_OF_CONDUCT/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"dev/CODE_OF_CONDUCT/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"dev/CODE_OF_CONDUCT/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"dev/CODE_OF_CONDUCT/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"dev/CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"dev/architecture/","title":"CodeFusion ReAct Architecture","text":"<p>CodeFusion is built on a comprehensive ReAct (Reasoning + Acting) framework that enables intelligent, agent-based code exploration through systematic reasoning, tool usage, and observation.</p>"},{"location":"dev/architecture/#design-philosophy","title":"Design Philosophy","text":""},{"location":"dev/architecture/#core-principles","title":"Core Principles","text":"<ol> <li>ReAct Pattern: Systematic Reason \u2192 Act \u2192 Observe loops for intelligent exploration</li> <li>Multi-Agent Architecture: Specialized agents for different aspects of code analysis</li> <li>Tool-Rich Ecosystem: Comprehensive tool set for repository exploration</li> <li>LLM Integration: Advanced reasoning and summarization through multiple LLM providers</li> <li>Persistent Memory: Caching and tracing across sessions for continuity</li> </ol>"},{"location":"dev/architecture/#key-features","title":"Key Features","text":"<ul> <li>\u2705 ReAct Loop Framework: Proper reasoning-action-observation cycles</li> <li>\u2705 Multi-Agent System: Specialized agents for documentation, codebase, architecture, and supervision</li> <li>\u2705 Advanced Caching: Persistent cross-session caching with TTL and LRU eviction</li> <li>\u2705 LLM Integration: OpenAI, Anthropic, and LLaMA support via LiteLLM</li> <li>\u2705 Comprehensive Tracing: Performance monitoring and debugging capabilities</li> <li>\u2705 Error Recovery: Robust error handling with circuit breakers and recovery strategies</li> <li>\u2705 Tool Validation: Parameter and result validation with retry mechanisms</li> </ul>"},{"location":"dev/architecture/#react-architecture-overview","title":"ReAct Architecture Overview","text":"<pre><code>graph TB\n    %% User Interface Layer\n    subgraph UI [\"\ud83d\udda5\ufe0f User Interface\"]\n        CLI[CLI Interface&lt;br/&gt;simple_run.py]\n        ANALYZE[analyze command]\n        EXPLORE[explore command]\n        CONTINUE[continue command]\n    end\n\n    %% ReAct Agent Layer\n    subgraph REACT [\"\ud83e\udd16 ReAct Agent Framework\"]\n        SUPERVISOR[ReAct Supervisor Agent&lt;br/&gt;Orchestration &amp; Coordination]\n        DOC_AGENT[ReAct Documentation Agent&lt;br/&gt;README, Docs Analysis]\n        CODE_AGENT[ReAct Codebase Agent&lt;br/&gt;Source Code Analysis]\n        ARCH_AGENT[ReAct Architecture Agent&lt;br/&gt;System Design Analysis]\n    end\n\n    %% Core ReAct Infrastructure\n    subgraph CORE [\"\u2699\ufe0f ReAct Core Infrastructure\"]\n        REACT_BASE[ReAct Base Agent&lt;br/&gt;react_agent.py]\n        REACT_CONFIG[ReAct Configuration&lt;br/&gt;react_config.py]\n        REACT_TRACE[ReAct Tracing&lt;br/&gt;react_tracing.py]\n        REACT_CACHE[ReAct Cache&lt;br/&gt;Persistent Storage]\n    end\n\n    %% Tool Ecosystem\n    subgraph TOOLS [\"\ud83d\udd27 Tool Ecosystem\"]\n        SCAN[Directory Scanning]\n        LIST[File Listing]\n        READ[File Reading]\n        SEARCH[Pattern Searching]\n        ANALYZE_CODE[Code Analysis]\n        LLM_REASON[LLM Reasoning]\n        LLM_SUMMARY[LLM Summarization]\n        CACHE_OPS[Cache Operations]\n    end\n\n    %% LLM Integration\n    subgraph LLM [\"\ud83e\udde0 LLM Integration\"]\n        REAL_LLM[Real LLM Interface&lt;br/&gt;LiteLLM Provider]\n        OPENAI[OpenAI&lt;br/&gt;GPT-3.5/4]\n        ANTHROPIC[Anthropic&lt;br/&gt;Claude 3]\n        LLAMA[LLaMA&lt;br/&gt;Together AI/Replicate/Ollama]\n        SIMPLE_LLM[Fallback LLM&lt;br/&gt;Simple Implementation]\n    end\n\n    %% Repository Interface\n    subgraph REPO [\"\ud83d\udcc1 Repository Interface\"]\n        CODE_REPO[CodeRepo Interface]\n        LOCAL_REPO[Local Repository]\n        REMOTE_REPO[Remote Repository]\n    end\n\n    %% Data Persistence\n    subgraph PERSIST [\"\ud83d\udcbe Data Persistence\"]\n        CACHE_FILES[Cache Files&lt;br/&gt;JSON Storage]\n        TRACE_FILES[Trace Files&lt;br/&gt;Session Logs]\n        CONFIG_FILES[Configuration&lt;br/&gt;Environment Variables]\n    end\n\n    %% User Interactions\n    CLI --&gt; SUPERVISOR\n    ANALYZE --&gt; SUPERVISOR\n    EXPLORE --&gt; DOC_AGENT\n    CONTINUE --&gt; CODE_AGENT\n\n    %% Agent Coordination\n    SUPERVISOR --&gt; DOC_AGENT\n    SUPERVISOR --&gt; CODE_AGENT\n    SUPERVISOR --&gt; ARCH_AGENT\n\n    %% Core Infrastructure\n    DOC_AGENT --&gt; REACT_BASE\n    CODE_AGENT --&gt; REACT_BASE\n    ARCH_AGENT --&gt; REACT_BASE\n    SUPERVISOR --&gt; REACT_BASE\n\n    REACT_BASE --&gt; REACT_CONFIG\n    REACT_BASE --&gt; REACT_TRACE\n    REACT_BASE --&gt; REACT_CACHE\n\n    %% Tool Usage\n    REACT_BASE --&gt; TOOLS\n    TOOLS --&gt; REPO\n\n    %% LLM Integration\n    TOOLS --&gt; REAL_LLM\n    REAL_LLM --&gt; OPENAI\n    REAL_LLM --&gt; ANTHROPIC\n    REAL_LLM --&gt; LLAMA\n    REAL_LLM -.-&gt; SIMPLE_LLM\n\n    %% Repository Access\n    CODE_REPO --&gt; LOCAL_REPO\n    CODE_REPO --&gt; REMOTE_REPO\n\n    %% Persistence\n    REACT_CACHE --&gt; CACHE_FILES\n    REACT_TRACE --&gt; TRACE_FILES\n    REACT_CONFIG --&gt; CONFIG_FILES\n\n    %% Styling\n    classDef ui fill:#3b4d66,stroke:#2d3748,stroke-width:2px,color:#f7fafc\n    classDef react fill:#553c6b,stroke:#44337a,stroke-width:3px,color:#f7fafc\n    classDef core fill:#2d5a3d,stroke:#1a4d2e,stroke-width:2px,color:#f7fafc\n    classDef tools fill:#744e3a,stroke:#5a3a2a,stroke-width:2px,color:#f7fafc\n    classDef llm fill:#8b5a3c,stroke:#6b4423,stroke-width:2px,color:#f7fafc\n    classDef repo fill:#2c5282,stroke:#1a365d,stroke-width:2px,color:#f7fafc\n    classDef persist fill:#4a5568,stroke:#2d3748,stroke-width:2px,color:#f7fafc\n\n    class UI,CLI,ANALYZE,EXPLORE,CONTINUE ui\n    class REACT,SUPERVISOR,DOC_AGENT,CODE_AGENT,ARCH_AGENT react\n    class CORE,REACT_BASE,REACT_CONFIG,REACT_TRACE,REACT_CACHE core\n    class TOOLS,SCAN,LIST,READ,SEARCH,ANALYZE_CODE,LLM_REASON,LLM_SUMMARY,CACHE_OPS tools\n    class LLM,REAL_LLM,OPENAI,ANTHROPIC,LLAMA,SIMPLE_LLM llm\n    class REPO,CODE_REPO,LOCAL_REPO,REMOTE_REPO repo\n    class PERSIST,CACHE_FILES,TRACE_FILES,CONFIG_FILES persist</code></pre>"},{"location":"dev/architecture/#react-framework-components","title":"ReAct Framework Components","text":""},{"location":"dev/architecture/#1-react-base-agent-cfcorereact_agentpy","title":"1. ReAct Base Agent (<code>cf/core/react_agent.py</code>)","text":"<p>Core ReAct implementation providing the foundation for all specialized agents.</p> <p>Key Features: - ReAct Loop: Complete Reason \u2192 Act \u2192 Observe cycle implementation - Tool Ecosystem: 8 different action types with comprehensive tooling - Error Handling: Circuit breakers, retry logic, and recovery strategies - Caching: Persistent caching with TTL and LRU eviction - Validation: Parameter and result validation for all tools - Tracing: Comprehensive execution tracing and performance monitoring</p> <p>Abstract Methods (implemented by specialized agents): <pre><code>def reason(self) -&gt; str: \n    \"\"\"Reasoning phase: Think about what to do next\"\"\"\n\ndef plan_action(self, reasoning: str) -&gt; ReActAction:\n    \"\"\"Plan the next action based on reasoning\"\"\"\n\ndef _generate_summary(self) -&gt; str:\n    \"\"\"Generate a summary of the agent's work\"\"\"\n</code></pre></p> <p>Available Tools: - <code>SCAN_DIRECTORY</code> - Recursive directory exploration - <code>LIST_FILES</code> - File listing with pattern matching - <code>READ_FILE</code> - File content reading with limits - <code>SEARCH_FILES</code> - Pattern searching across files - <code>ANALYZE_CODE</code> - Code structure analysis - <code>LLM_REASONING</code> - AI-powered reasoning - <code>LLM_SUMMARY</code> - AI-powered summarization - <code>CACHE_LOOKUP/STORE</code> - Cache operations</p>"},{"location":"dev/architecture/#2-specialized-react-agents","title":"2. Specialized ReAct Agents","text":""},{"location":"dev/architecture/#documentation-agent-cfagentsreact_documentation_agentpy","title":"Documentation Agent (<code>cf/agents/react_documentation_agent.py</code>)","text":"<ul> <li>Purpose: Analyze README files, documentation, and guides</li> <li>Specialization: Markdown parsing, documentation structure analysis</li> <li>Tools: Focus on document discovery and content analysis</li> </ul>"},{"location":"dev/architecture/#codebase-agent-cfagentsreact_codebase_agentpy","title":"Codebase Agent (<code>cf/agents/react_codebase_agent.py</code>)","text":"<ul> <li>Purpose: Analyze source code, classes, functions, and patterns</li> <li>Specialization: Code entity extraction, complexity analysis, dependency mapping</li> <li>Tools: Language-specific parsing and code pattern detection</li> </ul>"},{"location":"dev/architecture/#architecture-agent-cfagentsreact_architecture_agentpy","title":"Architecture Agent (<code>cf/agents/react_architecture_agent.py</code>)","text":"<ul> <li>Purpose: Understand system design, components, and architectural patterns</li> <li>Specialization: Component identification, pattern detection, design analysis</li> <li>Tools: System-level analysis and architectural insight generation</li> </ul>"},{"location":"dev/architecture/#supervisor-agent-cfagentsreact_supervisor_agentpy","title":"Supervisor Agent (<code>cf/agents/react_supervisor_agent.py</code>)","text":"<ul> <li>Purpose: Orchestrate multiple agents and synthesize insights</li> <li>Specialization: Multi-agent coordination and cross-agent insight synthesis</li> <li>Tools: Agent management and result aggregation</li> </ul>"},{"location":"dev/architecture/#3-llm-integration-cfllm","title":"3. LLM Integration (<code>cf/llm/</code>)","text":"<p>Real LLM Interface (<code>cf/llm/real_llm.py</code>): - LiteLLM Integration: Unified interface for multiple providers - Supported Providers:   - OpenAI: GPT-3.5-turbo, GPT-4   - Anthropic: Claude 3 Sonnet, Claude 3 Opus   - LLaMA: Via Together AI, Replicate, Ollama - Response Parsing: Robust JSON and text parsing with fallbacks - Error Handling: Graceful degradation to Simple LLM</p> <p>Configuration Options: <pre><code># OpenAI\nCF_LLM_MODEL=gpt-4\nCF_LLM_API_KEY=your-openai-key\n\n# Anthropic\nCF_LLM_MODEL=claude-3-sonnet-20240229\nCF_LLM_API_KEY=your-anthropic-key\n\n# LLaMA via Together AI\nCF_LLM_MODEL=together_ai/meta-llama/Llama-2-7b-chat-hf\nCF_LLM_API_KEY=your-together-ai-key\n</code></pre></p>"},{"location":"dev/architecture/#4-configuration-system-cfcorereact_configpy","title":"4. Configuration System (<code>cf/core/react_config.py</code>)","text":"<p>Comprehensive Configuration with environment variable support:</p> <pre><code>@dataclass\nclass ReActConfig:\n    # Loop parameters\n    max_iterations: int = 20\n    iteration_timeout: float = 30.0\n    total_timeout: float = 600.0\n\n    # Error handling\n    max_errors: int = 10\n    max_consecutive_errors: int = 3\n    error_recovery_enabled: bool = True\n\n    # Caching\n    cache_enabled: bool = True\n    cache_max_size: int = 1000\n    cache_ttl: int = 3600\n\n    # Tracing and logging\n    tracing_enabled: bool = True\n    trace_directory: Optional[str] = None\n</code></pre> <p>Performance Profiles: - Fast: Quick exploration (10 iterations, 15s timeout) - Balanced: Default recommended (20 iterations, 30s timeout) - Thorough: Comprehensive analysis (50 iterations, 60s timeout)</p>"},{"location":"dev/architecture/#5-tracing-system-cfcorereact_tracingpy","title":"5. Tracing System (<code>cf/core/react_tracing.py</code>)","text":"<p>Comprehensive Execution Monitoring:</p> <pre><code>@dataclass\nclass ReActTrace:\n    trace_id: str\n    agent_name: str\n    iteration: int\n    phase: str  # 'reason', 'act', 'observe'\n    timestamp: float\n    duration: float\n    content: Dict[str, Any]\n    success: bool\n    error: Optional[str]\n</code></pre> <p>Features: - Session Management: Start/end session tracking - Phase Tracing: Individual reason/act/observe phase monitoring - Performance Metrics: Duration, success rates, error tracking - Persistent Storage: JSON export for post-analysis - Global Metrics: Aggregated statistics across all sessions</p>"},{"location":"dev/architecture/#6-advanced-caching-cfcorereact_agentpy-reactcache","title":"6. Advanced Caching (<code>cf/core/react_agent.py</code> - ReActCache)","text":"<p>Persistent Cross-Session Caching:</p> <pre><code>class ReActCache:\n    def __init__(self, max_size: int = 1000, cache_dir: Optional[str] = None, ttl: int = 3600):\n        # In-memory cache with disk persistence\n        # TTL-based expiration\n        # LRU eviction policy\n</code></pre> <p>Features: - Persistent Storage: JSON files for cross-session continuity - TTL Expiration: Automatic cleanup of stale entries - LRU Eviction: Memory-efficient cache size management - Error Resilience: Graceful handling of corrupt cache files</p>"},{"location":"dev/architecture/#react-loop-flow","title":"ReAct Loop Flow","text":"<pre><code>sequenceDiagram\n    participant User\n    participant CLI\n    participant Supervisor\n    participant Agent\n    participant Tools\n    participant LLM\n    participant Cache\n    participant Tracer\n\n    User-&gt;&gt;CLI: cf analyze /repo --focus=all\n    CLI-&gt;&gt;Supervisor: explore_repository(focus=\"all\")\n\n    Supervisor-&gt;&gt;Tracer: start_session(\"supervisor\", goal)\n\n    loop ReAct Loop (max_iterations)\n        Note over Supervisor: \ud83e\udde0 REASON Phase\n        Supervisor-&gt;&gt;Supervisor: reason() - analyze current state\n        Supervisor-&gt;&gt;Tracer: trace_phase(\"reason\", reasoning)\n\n        Note over Supervisor: \ud83c\udfaf ACT Phase  \n        Supervisor-&gt;&gt;Supervisor: plan_action(reasoning)\n        Supervisor-&gt;&gt;Agent: activate_agent(agent_type)\n\n        Agent-&gt;&gt;Tracer: start_session(\"agent\", sub_goal)\n\n        loop Agent ReAct Loop\n            Agent-&gt;&gt;Agent: reason() - determine next tool\n            Agent-&gt;&gt;Tools: execute_tool(action_params)\n            Tools-&gt;&gt;Cache: check_cache(cache_key)\n            alt Cache Miss\n                Tools-&gt;&gt;LLM: llm_reasoning/summarize(content)\n                LLM--&gt;&gt;Tools: ai_response\n                Tools-&gt;&gt;Cache: store_result(cache_key, result)\n            end\n            Cache--&gt;&gt;Tools: cached_result\n            Tools--&gt;&gt;Agent: tool_result\n            Agent-&gt;&gt;Agent: observe(tool_result)\n            Agent-&gt;&gt;Tracer: trace_phase(\"act\", action_result)\n        end\n\n        Agent-&gt;&gt;Tracer: end_session(agent_results)\n        Agent--&gt;&gt;Supervisor: agent_insights\n\n        Note over Supervisor: \ud83d\udc41\ufe0f OBSERVE Phase\n        Supervisor-&gt;&gt;Supervisor: observe(agent_insights)\n        Supervisor-&gt;&gt;Tracer: trace_phase(\"observe\", observations)\n\n        Supervisor-&gt;&gt;Supervisor: check_goal_achieved()\n    end\n\n    Supervisor-&gt;&gt;Supervisor: synthesize_cross_agent_insights()\n    Supervisor-&gt;&gt;Tracer: end_session(final_results)\n    Supervisor--&gt;&gt;CLI: comprehensive_analysis\n    CLI--&gt;&gt;User: formatted_results + metrics</code></pre>"},{"location":"dev/architecture/#tool-validation-error-recovery","title":"Tool Validation &amp; Error Recovery","text":""},{"location":"dev/architecture/#parameter-validation","title":"Parameter Validation","text":"<pre><code>def _validate_action_parameters(self, action: ReActAction) -&gt; Optional[str]:\n    \"\"\"Validate action parameters before execution\"\"\"\n    if action.action_type == ActionType.READ_FILE:\n        if 'file_path' not in action.parameters:\n            return \"file_path parameter required for READ_FILE\"\n    # ... additional validations\n</code></pre>"},{"location":"dev/architecture/#result-validation","title":"Result Validation","text":"<pre><code>def _validate_tool_result(self, action: ReActAction, result: Any) -&gt; Dict[str, Any]:\n    \"\"\"Validate tool execution result\"\"\"\n    if isinstance(result, dict) and 'error' in result:\n        return {'valid': False, 'error': f\"Tool returned error: {result['error']}\"}\n    # ... additional validations\n</code></pre>"},{"location":"dev/architecture/#error-recovery-strategies","title":"Error Recovery Strategies","text":"<pre><code>def _attempt_tool_recovery(self, action: ReActAction, error: str) -&gt; Optional[str]:\n    \"\"\"Attempt to recover from tool execution error\"\"\"\n    error_lower = error.lower()\n\n    if 'file not found' in error_lower:\n        return 'file_not_found'  # Switch to directory scan\n    elif 'permission denied' in error_lower:\n        return 'permission_denied'  # Try different approach\n    elif 'timeout' in error_lower:\n        return 'timeout'  # Use cached results\n</code></pre>"},{"location":"dev/architecture/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"dev/architecture/#time-complexity","title":"Time Complexity","text":"<ul> <li>ReAct Loop: O(n \u00d7 m) where n = iterations, m = tools per iteration</li> <li>Caching: O(1) lookup and storage with O(log k) eviction</li> <li>Tool Execution: O(f) where f = file/directory size being processed</li> </ul>"},{"location":"dev/architecture/#space-complexity","title":"Space Complexity","text":"<ul> <li>Memory: O(c + t + s) where c = cache size, t = trace data, s = session state</li> <li>Storage: Persistent cache and trace files scale with usage</li> </ul>"},{"location":"dev/architecture/#scalability-features","title":"Scalability Features","text":"<ul> <li>Configurable Limits: Max iterations, timeouts, cache sizes</li> <li>Circuit Breakers: Prevent infinite loops and cascading failures</li> <li>Resource Management: TTL expiration, LRU eviction, timeout handling</li> <li>Parallel Potential: Framework supports future parallel tool execution</li> </ul>"},{"location":"dev/architecture/#configuration-examples","title":"Configuration Examples","text":""},{"location":"dev/architecture/#environment-variables","title":"Environment Variables","text":"<pre><code># Basic Configuration\nCF_REACT_MAX_ITERATIONS=20\nCF_REACT_ITERATION_TIMEOUT=30.0\nCF_REACT_TOTAL_TIMEOUT=600.0\n\n# Caching\nCF_REACT_CACHE_ENABLED=true\nCF_REACT_CACHE_MAX_SIZE=1000\nCF_REACT_CACHE_TTL=3600\n\n# Tracing\nCF_REACT_TRACING_ENABLED=true\nCF_REACT_TRACE_DIR=./traces\n\n# LLM Integration\nCF_LLM_MODEL=gpt-4\nCF_LLM_API_KEY=your-api-key\nCF_LLM_MAX_TOKENS=1000\nCF_LLM_TEMPERATURE=0.7\n</code></pre>"},{"location":"dev/architecture/#performance-profiles","title":"Performance Profiles","text":"<pre><code># Fast Profile - Quick Analysis\nconfig = ReActConfig()\nconfig.apply_performance_profile(\"fast\")\n# max_iterations=10, timeouts=15s, cache=500\n\n# Balanced Profile - Default\nconfig.apply_performance_profile(\"balanced\") \n# max_iterations=20, timeouts=30s, cache=1000\n\n# Thorough Profile - Comprehensive Analysis\nconfig.apply_performance_profile(\"thorough\")\n# max_iterations=50, timeouts=60s, cache=2000\n</code></pre>"},{"location":"dev/architecture/#usage-examples","title":"Usage Examples","text":""},{"location":"dev/architecture/#basic-repository-analysis","title":"Basic Repository Analysis","text":"<pre><code># Multi-agent comprehensive analysis\ncf analyze /path/to/repo --focus=all\n\n# Documentation-focused analysis  \ncf analyze /path/to/repo --focus=docs\n\n# Architecture-focused analysis\ncf analyze /path/to/repo --focus=arch\n</code></pre>"},{"location":"dev/architecture/#configuration-driven-analysis","title":"Configuration-Driven Analysis","text":"<pre><code># Fast analysis for quick insights\nCF_REACT_MAX_ITERATIONS=10 cf analyze /repo\n\n# Thorough analysis with tracing\nCF_REACT_TRACING_ENABLED=true CF_REACT_TRACE_DIR=./traces cf analyze /repo\n\n# LLaMA-powered analysis\nCF_LLM_MODEL=together_ai/meta-llama/Llama-2-7b-chat-hf cf analyze /repo\n</code></pre>"},{"location":"dev/architecture/#future-architecture-enhancements","title":"Future Architecture Enhancements","text":""},{"location":"dev/architecture/#planned-features","title":"Planned Features","text":"<ol> <li>Parallel Tool Execution: Execute multiple tools concurrently</li> <li>Dynamic Agent Loading: Plugin-based agent architecture</li> <li>Interactive Mode: Real-time user feedback integration</li> <li>Advanced Caching: Semantic similarity-based cache keys</li> <li>Distributed Tracing: Multi-node execution monitoring</li> </ol>"},{"location":"dev/architecture/#extensibility-points","title":"Extensibility Points","text":"<ol> <li>Custom Agents: Implement ReActAgent for domain-specific analysis</li> <li>Custom Tools: Add ActionType and tool implementations</li> <li>Custom LLM Providers: Extend LiteLLM integration</li> <li>Custom Trace Formats: Alternative trace storage and analysis</li> </ol> <p>This architecture provides a robust, scalable foundation for intelligent code exploration through the proven ReAct pattern, comprehensive tooling, and multi-agent coordination.</p>"},{"location":"dev/contributing/","title":"Contributing to CodeFusion","text":"<p>Thank you for your interest in contributing to CodeFusion! This project focuses on simplicity and human-like exploration patterns.</p>"},{"location":"dev/contributing/#philosophy","title":"Philosophy","text":"<p>CodeFusion is built on the principle that code exploration should be as natural as human investigation. When contributing, please keep these principles in mind:</p> <ul> <li>Keep it simple: Avoid complex dependencies and solutions</li> <li>Human-like patterns: Follow natural investigation workflows</li> <li>Immediate usability: No complex setup or preprocessing</li> <li>Incremental understanding: Build knowledge step by step</li> </ul>"},{"location":"dev/contributing/#getting-started","title":"Getting Started","text":""},{"location":"dev/contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10 or higher</li> <li>Git</li> <li>Basic understanding of command-line tools</li> </ul>"},{"location":"dev/contributing/#development-setup","title":"Development Setup","text":"<pre><code># Clone the repository\ngit clone &lt;repository-url&gt;\ncd codefusion\n\n# Create virtual environment\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install for development\npip install -e \".[dev]\"\n\n# Install pre-commit hooks\npre-commit install\n\n# Run tests to verify setup\npytest\n</code></pre>"},{"location":"dev/contributing/#code-organization","title":"Code Organization","text":""},{"location":"dev/contributing/#project-structure","title":"Project Structure","text":"<pre><code>cf/\n\u251c\u2500\u2500 core/\n\u2502   \u2514\u2500\u2500 simple_explorer.py      # Main exploration interface\n\u251c\u2500\u2500 agents/\n\u2502   \u2514\u2500\u2500 human_explorer.py       # Human-like investigation agent\n\u251c\u2500\u2500 run/\n\u2502   \u2514\u2500\u2500 simple_run.py           # CLI interface\n\u251c\u2500\u2500 aci/\n\u2502   \u2514\u2500\u2500 repo.py                 # Repository access\n\u2514\u2500\u2500 config.py                   # Simple configuration\n</code></pre>"},{"location":"dev/contributing/#key-components","title":"Key Components","text":"<ol> <li>CLI (<code>cf/run/simple_run.py</code>): Command-line interface</li> <li>Simple Explorer (<code>cf/core/simple_explorer.py</code>): Main orchestration</li> <li>Human Explorer (<code>cf/agents/human_explorer.py</code>): Investigation logic</li> <li>Repository Interface (<code>cf/aci/repo.py</code>): File system access</li> <li>Configuration (<code>cf/config.py</code>): Simple settings management</li> </ol>"},{"location":"dev/contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"dev/contributing/#making-changes","title":"Making Changes","text":"<ol> <li>Create a branch: <code>git checkout -b feature/your-feature</code></li> <li>Make changes: Follow the coding standards below</li> <li>Test changes: Run tests and verify functionality</li> <li>Commit changes: Use clear, descriptive commit messages</li> <li>Push branch: <code>git push origin feature/your-feature</code></li> <li>Create PR: Submit a pull request for review</li> </ol>"},{"location":"dev/contributing/#testing","title":"Testing","text":"<pre><code># Run all tests\npytest\n\n# Run with coverage\npytest --cov=cf\n\n# Run specific test file\npytest tests/test_simple_explorer.py\n\n# Run tests with verbose output\npytest -v\n</code></pre>"},{"location":"dev/contributing/#code-quality","title":"Code Quality","text":"<pre><code># Format code\nblack .\n\n# Sort imports\nisort .\n\n# Check linting\nflake8 cf/\n\n# Type checking\nmypy cf/\n\n# Run all quality checks\nblack . &amp;&amp; isort . &amp;&amp; flake8 cf/ &amp;&amp; mypy cf/\n</code></pre>"},{"location":"dev/contributing/#coding-standards","title":"Coding Standards","text":""},{"location":"dev/contributing/#python-style","title":"Python Style","text":"<ul> <li>Follow PEP 8 style guide</li> <li>Use Black for code formatting</li> <li>Sort imports with isort</li> <li>Add type hints for function parameters and return values</li> <li>Keep functions focused and single-purpose</li> </ul>"},{"location":"dev/contributing/#example-code-style","title":"Example Code Style","text":"<pre><code>def explore_repository(repo_path: str, question: str) -&gt; str:\n    \"\"\"\n    Explore a repository to answer a question.\n\n    Args:\n        repo_path: Path to the repository\n        question: Question to investigate\n\n    Returns:\n        Human-readable investigation results\n    \"\"\"\n    explorer = SimpleExplorer(repo_path)\n    return explorer.explore(question)\n</code></pre>"},{"location":"dev/contributing/#documentation","title":"Documentation","text":"<ul> <li>Use Google-style docstrings</li> <li>Include type hints</li> <li>Provide clear examples</li> <li>Document complex logic with comments</li> </ul>"},{"location":"dev/contributing/#adding-features","title":"Adding Features","text":""},{"location":"dev/contributing/#new-exploration-tools","title":"New Exploration Tools","text":"<p>To add a new exploration tool:</p> <ol> <li>Add method to <code>ExplorationTools</code> class in <code>cf/agents/human_explorer.py</code></li> <li>Update <code>_take_action</code> method to use the new tool</li> <li>Add observation handling in <code>_observe_results</code></li> <li>Write tests for the new functionality</li> </ol> <p>Example: <pre><code>def find_imports(self, file_path: str) -&gt; List[str]:\n    \"\"\"Find import statements in a file.\"\"\"\n    try:\n        content = self.repo.read_file(file_path)\n        # Simple regex to find imports\n        import re\n        imports = re.findall(r'^(?:from|import)\\s+(\\S+)', content, re.MULTILINE)\n        return imports\n    except Exception as e:\n        return [f\"Error finding imports: {e}\"]\n</code></pre></p>"},{"location":"dev/contributing/#new-cli-commands","title":"New CLI Commands","text":"<p>To add a new CLI command:</p> <ol> <li>Add parser in <code>create_parser</code> method in <code>cf/run/simple_run.py</code></li> <li>Create command handler method (e.g., <code>cmd_new_command</code>)</li> <li>Add to the argument parser setup</li> <li>Test the new command</li> </ol>"},{"location":"dev/contributing/#configuration-options","title":"Configuration Options","text":"<p>To add new configuration options:</p> <ol> <li>Add field to <code>CfConfig</code> class in <code>cf/config.py</code></li> <li>Update <code>to_dict</code> and validation methods</li> <li>Update default configuration file</li> <li>Document the new option</li> </ol>"},{"location":"dev/contributing/#testing-guidelines","title":"Testing Guidelines","text":""},{"location":"dev/contributing/#unit-tests","title":"Unit Tests","text":"<ul> <li>Test individual components in isolation</li> <li>Mock external dependencies</li> <li>Use descriptive test names</li> <li>Test both success and failure cases</li> </ul> <p>Example: <pre><code>def test_simple_explorer_caching():\n    \"\"\"Test that exploration results are cached correctly.\"\"\"\n    explorer = SimpleExplorer(\"/test/repo\")\n\n    # Mock the investigation\n    with patch.object(explorer.explorer, 'investigate') as mock_investigate:\n        mock_investigate.return_value = Mock(...)\n\n        # First call should hit investigation\n        result1 = explorer.explore(\"test question\")\n        assert mock_investigate.called\n\n        # Second call should use cache\n        result2 = explorer.explore(\"test question\")\n        assert result1 == result2\n</code></pre></p>"},{"location":"dev/contributing/#integration-tests","title":"Integration Tests","text":"<ul> <li>Test end-to-end workflows</li> <li>Use temporary directories for file operations</li> <li>Test CLI commands with real repositories</li> <li>Verify error handling</li> </ul>"},{"location":"dev/contributing/#performance-tests","title":"Performance Tests","text":"<ul> <li>Test with large repositories</li> <li>Monitor memory usage</li> <li>Measure response times</li> <li>Test caching effectiveness</li> </ul>"},{"location":"dev/contributing/#submitting-changes","title":"Submitting Changes","text":""},{"location":"dev/contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Fork the repository</li> <li>Create a feature branch</li> <li>Make your changes</li> <li>Test thoroughly</li> <li>Update documentation</li> <li>Submit pull request</li> </ol>"},{"location":"dev/contributing/#pr-guidelines","title":"PR Guidelines","text":"<ul> <li>Clear, descriptive title</li> <li>Detailed description of changes</li> <li>Reference any related issues</li> <li>Include tests for new features</li> <li>Update documentation as needed</li> </ul>"},{"location":"dev/contributing/#bug-reports","title":"Bug Reports","text":""},{"location":"dev/contributing/#before-reporting","title":"Before Reporting","text":"<ol> <li>Check existing issues</li> <li>Try latest version</li> <li>Verify it's not a configuration issue</li> <li>Test with minimal example</li> </ol>"},{"location":"dev/contributing/#bug-report-template","title":"Bug Report Template","text":"<pre><code>## Bug Description\nClear description of the bug\n\n## Steps to Reproduce\n1. Step one\n2. Step two\n3. Step three\n\n## Expected Behavior\nWhat should happen\n\n## Actual Behavior\nWhat actually happens\n\n## Environment\n- OS: [e.g., macOS 12.0]\n- Python: [e.g., 3.10.0]\n- CodeFusion: [e.g., 0.0.1]\n\n## Additional Context\nAny other relevant information\n</code></pre>"},{"location":"dev/contributing/#feature-requests","title":"Feature Requests","text":""},{"location":"dev/contributing/#guidelines","title":"Guidelines","text":"<ul> <li>Keep features simple and focused</li> <li>Align with human-like exploration philosophy</li> <li>Avoid complex dependencies</li> <li>Consider maintenance burden</li> </ul>"},{"location":"dev/contributing/#community","title":"Community","text":""},{"location":"dev/contributing/#communication","title":"Communication","text":"<ul> <li>Be respectful and professional</li> <li>Focus on the code, not the person</li> <li>Provide constructive feedback</li> <li>Help others learn and improve</li> </ul>"},{"location":"dev/contributing/#getting-help","title":"Getting Help","text":"<ul> <li>Check existing documentation</li> <li>Search previous issues</li> <li>Ask questions in discussions</li> <li>Be specific about problems</li> </ul>"},{"location":"dev/contributing/#thank-you","title":"Thank You","text":"<p>Thank you for contributing to CodeFusion! Your contributions help make code exploration more natural and accessible for developers everywhere.</p> <p>Remember: Keep it simple, keep it human-like, and keep it useful.</p>"},{"location":"installation/quickstart/","title":"Quick Start","text":"<p>Get up and running with CodeFusion in minutes.</p>"},{"location":"installation/quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10 or higher</li> <li>Git</li> </ul>"},{"location":"installation/quickstart/#installation","title":"Installation","text":"<pre><code># Clone the repository\ngit clone &lt;repository-url&gt;\ncd codefusion\n\n# Create virtual environment\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install CodeFusion\npip install -e .\n\n# Verify installation\ncf --help\n</code></pre>"},{"location":"installation/quickstart/#first-exploration","title":"First Exploration","text":"<pre><code># Explore a repository\ncf explore /path/to/your/repo \"How does authentication work?\"\n\n# Continue exploration\ncf continue /path/to/your/repo \"How are sessions managed?\" --previous \"How does authentication work?\"\n\n# View exploration summary\ncf summary /path/to/your/repo\n</code></pre>"},{"location":"installation/quickstart/#example-questions","title":"Example Questions","text":"<p>Try these example questions:</p> <ul> <li>\"How does authentication work?\"</li> <li>\"What are the main API endpoints?\"</li> <li>\"How is data stored and retrieved?\"</li> <li>\"What testing frameworks are used?\"</li> <li>\"How is the application configured?\"</li> </ul>"},{"location":"installation/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Read the CLI Usage Guide</li> <li>Learn about Configuration</li> <li>Check the Installation Guide for detailed setup</li> </ul>"},{"location":"installation/quickstart/#need-help","title":"Need Help?","text":"<ul> <li>Use <code>cf --help</code> for command help</li> <li>Use <code>cf --verbose</code> for detailed output</li> <li>Check the documentation for more information</li> </ul>"},{"location":"installation/setup/","title":"Installation and Setup Guide","text":"<p>This guide covers setting up CodeFusion for human-like code exploration.</p>"},{"location":"installation/setup/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10+: Required for all functionality</li> <li>Git: For cloning repositories and version control</li> <li>Virtual Environment: Highly recommended to avoid dependency conflicts</li> </ul>"},{"location":"installation/setup/#virtual-environment-setup","title":"Virtual Environment Setup","text":""},{"location":"installation/setup/#create-virtual-environment","title":"Create Virtual Environment","text":"<pre><code># Navigate to project directory\ncd codefusion\n\n# Create virtual environment\npython -m venv venv\n\n# Activate virtual environment\n# On macOS/Linux:\nsource venv/bin/activate\n\n# On Windows:\nvenv\\Scripts\\activate\n</code></pre>"},{"location":"installation/setup/#verify-activation","title":"Verify Activation","text":"<p>Your terminal prompt should show <code>(venv)</code> when the virtual environment is active:</p> <pre><code>(venv) $ python --version\nPython 3.10.x\n</code></pre>"},{"location":"installation/setup/#installation-options","title":"Installation Options","text":""},{"location":"installation/setup/#basic-installation","title":"Basic Installation","text":"<p>Install CodeFusion with human-like exploration capabilities:</p> <pre><code>pip install -e .\n</code></pre> <p>This includes: - Core human-like exploration system - Simple CLI interface - Text-based caching - Repository access layer - Basic configuration management</p>"},{"location":"installation/setup/#development-installation","title":"Development Installation","text":"<p>For development and contributing:</p> <pre><code>pip install -e \".[dev]\"\n</code></pre> <p>This adds: - Testing framework (pytest) - Code formatting (black) - Import sorting (isort) - Linting (flake8) - Type checking (mypy) - Pre-commit hooks</p>"},{"location":"installation/setup/#documentation-installation","title":"Documentation Installation","text":"<p>For building and serving documentation:</p> <pre><code>pip install -e \".[docs]\"\n</code></pre> <p>This adds: - MkDocs for documentation - Material theme - Mermaid diagrams - Python docstring support</p>"},{"location":"installation/setup/#complete-installation","title":"Complete Installation","text":"<p>Install everything:</p> <pre><code>pip install -e \".[all]\"\n</code></pre>"},{"location":"installation/setup/#verify-installation","title":"Verify Installation","text":""},{"location":"installation/setup/#basic-verification","title":"Basic Verification","text":"<pre><code># Check if cf command is available\ncf --help\n\n# Verify Python imports work\npython -c \"import cf; print(f'CodeFusion v{cf.__version__}')\"\n</code></pre>"},{"location":"installation/setup/#test-with-sample-repository","title":"Test with Sample Repository","text":"<pre><code># Test basic exploration\ncf explore . \"How does the simple explorer work?\"\n\n# Test with a larger repository\ncf explore /path/to/some/repo \"What is the overall architecture?\"\n</code></pre>"},{"location":"installation/setup/#initial-configuration","title":"Initial Configuration","text":""},{"location":"installation/setup/#default-configuration","title":"Default Configuration","text":"<p>CodeFusion works out of the box with sensible defaults. The default configuration is located at:</p> <pre><code>config/default/config.yaml\n</code></pre>"},{"location":"installation/setup/#custom-configuration","title":"Custom Configuration","text":"<p>Create your own configuration file:</p> <pre><code># Copy default configuration\ncp config/default/config.yaml my-config.yaml\n\n# Edit configuration\nnano my-config.yaml\n\n# Use custom configuration\ncf --config my-config.yaml explore /path/to/repo \"How does authentication work?\"\n</code></pre>"},{"location":"installation/setup/#development-setup","title":"Development Setup","text":""},{"location":"installation/setup/#additional-development-tools","title":"Additional Development Tools","text":"<pre><code># Install pre-commit hooks\npre-commit install\n\n# Run tests\npytest\n\n# Format code\nblack .\n\n# Sort imports\nisort .\n\n# Check types\nmypy cf/\n\n# Lint code\nflake8 cf/\n</code></pre>"},{"location":"installation/setup/#ide-configuration","title":"IDE Configuration","text":""},{"location":"installation/setup/#vs-code","title":"VS Code","text":"<p>Install recommended extensions:</p> <pre><code>{\n    \"recommendations\": [\n        \"ms-python.python\",\n        \"ms-python.black-formatter\",\n        \"ms-python.isort\",\n        \"ms-python.flake8\",\n        \"ms-python.mypy-type-checker\"\n    ]\n}\n</code></pre>"},{"location":"installation/setup/#pycharm","title":"PyCharm","text":"<p>Configure interpreters: 1. Go to File \u2192 Settings \u2192 Project \u2192 Python Interpreter 2. Select the virtual environment: <code>./venv/bin/python</code> 3. Enable type checking and linting</p>"},{"location":"installation/setup/#common-installation-issues","title":"Common Installation Issues","text":""},{"location":"installation/setup/#python-version-issues","title":"Python Version Issues","text":"<pre><code># Check Python version\npython --version\n\n# If you have multiple Python versions, use specific version\npython3.10 -m venv venv\n</code></pre>"},{"location":"installation/setup/#permission-issues","title":"Permission Issues","text":"<pre><code># On macOS/Linux, if you get permission errors:\nsudo chown -R $(whoami) ~/.local/lib/python3.10/site-packages/\n\n# Or use user installation\npip install --user -e .\n</code></pre>"},{"location":"installation/setup/#virtual-environment-issues","title":"Virtual Environment Issues","text":"<pre><code># Deactivate and recreate virtual environment\ndeactivate\nrm -rf venv\npython -m venv venv\nsource venv/bin/activate\npip install --upgrade pip\npip install -e .\n</code></pre>"},{"location":"installation/setup/#dependencies-issues","title":"Dependencies Issues","text":"<pre><code># Clear pip cache\npip cache purge\n\n# Upgrade pip and setuptools\npip install --upgrade pip setuptools wheel\n\n# Reinstall dependencies\npip install --force-reinstall -e .\n</code></pre>"},{"location":"installation/setup/#directory-structure","title":"Directory Structure","text":"<p>After installation, your directory structure should look like:</p> <pre><code>codefusion/\n\u251c\u2500\u2500 cf/                          # Main package\n\u2502   \u251c\u2500\u2500 core/\n\u2502   \u2502   \u2514\u2500\u2500 simple_explorer.py   # Main exploration interface\n\u2502   \u251c\u2500\u2500 agents/\n\u2502   \u2502   \u2514\u2500\u2500 human_explorer.py    # Human-like investigation\n\u2502   \u251c\u2500\u2500 run/\n\u2502   \u2502   \u2514\u2500\u2500 simple_run.py        # CLI interface\n\u2502   \u251c\u2500\u2500 aci/\n\u2502   \u2502   \u2514\u2500\u2500 repo.py              # Repository access\n\u2502   \u2514\u2500\u2500 config.py                # Configuration management\n\u251c\u2500\u2500 config/\n\u2502   \u2514\u2500\u2500 default/\n\u2502       \u2514\u2500\u2500 config.yaml          # Default configuration\n\u251c\u2500\u2500 examples/\n\u2502   \u2514\u2500\u2500 human_exploration_demo.py # Demo script\n\u251c\u2500\u2500 tests/                       # Test suite\n\u251c\u2500\u2500 docs/                        # Documentation\n\u251c\u2500\u2500 pyproject.toml               # Package configuration\n\u2514\u2500\u2500 README.md                    # Main documentation\n</code></pre>"},{"location":"installation/setup/#environment-variables","title":"Environment Variables","text":"<p>CodeFusion uses minimal environment variables:</p> <pre><code># Optional: Set default configuration path\nexport CF_CONFIG_PATH=\"/path/to/config.yaml\"\n\n# Optional: Enable debug mode\nexport CF_DEBUG=1\n\n# Optional: Set output directory\nexport CF_OUTPUT_DIR=\"/path/to/output\"\n</code></pre>"},{"location":"installation/setup/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/setup/#command-not-found","title":"Command Not Found","text":"<pre><code># Check if cf is in PATH\nwhich cf\n\n# If not found, try:\npip install -e . --force-reinstall\n\n# Or use python module execution\npython -m cf --help\n</code></pre>"},{"location":"installation/setup/#import-errors","title":"Import Errors","text":"<pre><code># Check if package is installed\npip list | grep codefusion\n\n# If not listed, reinstall\npip install -e .\n\n# Check for import issues\npython -c \"import cf; print('OK')\"\n</code></pre>"},{"location":"installation/setup/#configuration-errors","title":"Configuration Errors","text":"<pre><code># Validate configuration\ncf --config config.yaml summary /path/to/repo\n\n# Check YAML syntax\npython -c \"import yaml; yaml.safe_load(open('config.yaml'))\"\n</code></pre>"},{"location":"installation/setup/#performance-optimization","title":"Performance Optimization","text":""},{"location":"installation/setup/#for-large-repositories","title":"For Large Repositories","text":"<pre><code># Create optimized configuration\ncat &gt; large-repo-config.yaml &lt;&lt; 'EOF'\nmax_file_size: 2097152  # 2MB\nmax_exploration_depth: 3\nexcluded_dirs:\n  - \".git\"\n  - \"__pycache__\"\n  - \"node_modules\"\n  - \".venv\"\n  - \"dist\"\n  - \"build\"\n  - \"target\"\n  - \"vendor\"\nEOF\n\n# Use optimized configuration\ncf --config large-repo-config.yaml explore /path/to/large/repo \"How does X work?\"\n</code></pre>"},{"location":"installation/setup/#memory-usage","title":"Memory Usage","text":"<pre><code># Monitor memory usage\n/usr/bin/time -v cf explore /path/to/repo \"How does X work?\"\n\n# For memory-constrained environments\nexport CF_MAX_FILE_SIZE=524288  # 512KB\n</code></pre>"},{"location":"installation/setup/#next-steps","title":"Next Steps","text":"<ol> <li>Try the demo: Run <code>python examples/human_exploration_demo.py</code></li> <li>Explore a repository: Use <code>cf explore /path/to/repo \"How does X work?\"</code></li> <li>Read the documentation: Check out the CLI Usage guide</li> <li>Configure for your needs: See Configuration</li> <li>Contributing: Check the development setup above</li> </ol>"},{"location":"installation/setup/#getting-help","title":"Getting Help","text":"<p>If you encounter issues:</p> <ol> <li>Check the documentation: Look through the docs/ directory</li> <li>Run diagnostics: Use <code>cf --verbose</code> for detailed output</li> <li>Check dependencies: Ensure all required packages are installed</li> <li>Test configuration: Validate your configuration files</li> <li>Create an issue: Report bugs or request features in the repository</li> </ol>"},{"location":"installation/setup/#uninstallation","title":"Uninstallation","text":"<p>To remove CodeFusion:</p> <pre><code># Uninstall package\npip uninstall codefusion\n\n# Remove virtual environment\ndeactivate\nrm -rf venv\n\n# Clean up cache (optional)\nrm -rf ~/.cache/pip/\n</code></pre>"},{"location":"usage/cli/","title":"CLI Commands","text":"<p>CodeFusion provides a comprehensive command-line interface for ReAct framework-based code analysis.</p>"},{"location":"usage/cli/#overview","title":"Overview","text":"<p>The main CLI entry point uses Python module execution:</p> <pre><code>python -m cf.run.simple_run --help\n</code></pre>"},{"location":"usage/cli/#global-options","title":"Global Options","text":"<p>These options are available for all commands:</p> <pre><code>python -m cf.run.simple_run [OPTIONS] COMMAND [ARGS]...\n\nGlobal Options:\n  --config, -c PATH    Configuration file path\n  --verbose, -v        Enable verbose output\n  --help               Show help message\n</code></pre>"},{"location":"usage/cli/#commands","title":"Commands","text":""},{"location":"usage/cli/#analyze-multi-agent-analysis","title":"<code>analyze</code> - Multi-Agent Analysis","text":"<p>Perform comprehensive multi-agent analysis using the ReAct framework.</p> <pre><code>python -m cf.run.simple_run analyze [OPTIONS] REPO_PATH\n</code></pre> <p>Arguments: - <code>REPO_PATH</code>: Path to the repository to analyze</p> <p>Options: - <code>--focus {all,docs,code,arch}</code>: Analysis focus (default: all)</p> <p>Examples: <pre><code># Comprehensive multi-agent analysis\npython -m cf.run.simple_run analyze /path/to/repository --focus=all\n\n# Documentation-focused analysis\npython -m cf.run.simple_run analyze /path/to/repository --focus=docs\n\n# Codebase-focused analysis\npython -m cf.run.simple_run analyze /path/to/repository --focus=code\n\n# Architecture-focused analysis\npython -m cf.run.simple_run analyze /path/to/repository --focus=arch\n</code></pre></p>"},{"location":"usage/cli/#explore-question-based-exploration","title":"<code>explore</code> - Question-Based Exploration","text":"<p>Explore a repository to answer a specific question using ReAct agents.</p> <pre><code>python -m cf.run.simple_run explore [OPTIONS] REPO_PATH QUESTION\n</code></pre> <p>Arguments: - <code>REPO_PATH</code>: Path to the repository to explore - <code>QUESTION</code>: Question to investigate about the codebase</p> <p>Examples: <pre><code># Basic exploration\npython -m cf.run.simple_run explore /path/to/repository \"How does authentication work?\"\n\n# Explore API structure\npython -m cf.run.simple_run explore /path/to/repository \"What are the main API endpoints?\"\n\n# Security analysis\npython -m cf.run.simple_run explore /path/to/repository \"What security patterns are used?\"\n</code></pre></p>"},{"location":"usage/cli/#ask-ask-a-question-alias-for-explore","title":"<code>ask</code> - Ask a Question (alias for explore)","text":"<p>Ask a natural language question about a codebase.</p> <pre><code>python -m cf.run.simple_run ask [OPTIONS] REPO_PATH QUESTION\n</code></pre> <p>Arguments: - <code>REPO_PATH</code>: Path to the repository - <code>QUESTION</code>: Question to ask about the code</p> <p>Examples: <pre><code># Ask about testing\npython -m cf.run.simple_run ask /path/to/repo \"What testing frameworks are used?\"\n\n# Ask about deployment\npython -m cf.run.simple_run ask /path/to/repo \"How is this application deployed?\"\n</code></pre></p>"},{"location":"usage/cli/#continue-continue-previous-analysis","title":"<code>continue</code> - Continue Previous Analysis","text":"<p>Continue exploring by building on previous investigations.</p> <pre><code>python -m cf.run.simple_run continue [OPTIONS] REPO_PATH QUESTION --previous PREVIOUS_QUESTION\n</code></pre> <p>Arguments: - <code>REPO_PATH</code>: Path to the repository - <code>QUESTION</code>: New question to explore - <code>--previous</code>: Previous question that was explored</p> <p>Examples: <pre><code># Continue from authentication to sessions\npython -m cf.run.simple_run continue /path/to/repo \"How are user sessions managed?\" --previous \"How does authentication work?\"\n\n# Continue from API to validation\npython -m cf.run.simple_run continue /path/to/repo \"How is input validation handled?\" --previous \"What are the main API endpoints?\"\n</code></pre></p>"},{"location":"usage/cli/#summary-show-analysis-summary","title":"<code>summary</code> - Show Analysis Summary","text":"<p>Display a summary of analysis performed on a repository.</p> <pre><code>python -m cf.run.simple_run summary [OPTIONS] REPO_PATH\n</code></pre> <p>Arguments: - <code>REPO_PATH</code>: Path to the repository</p> <p>Examples: <pre><code># Show analysis summary\npython -m cf.run.simple_run summary /path/to/repository\n\n# Verbose summary\npython -m cf.run.simple_run --verbose summary /path/to/repository\n</code></pre></p>"},{"location":"usage/cli/#react-framework-process","title":"ReAct Framework Process","text":""},{"location":"usage/cli/#how-it-works","title":"How it Works","text":"<p>CodeFusion follows the ReAct (Reasoning + Acting) pattern:</p> <ol> <li>\ud83e\udde0 REASON: AI analyzes current state and determines next action</li> <li>\ud83c\udfaf ACT: Execute specialized tools based on reasoning</li> <li>\ud83d\udc41\ufe0f OBSERVE: Process results and update understanding</li> <li>\ud83d\udd04 ITERATE: Continue until goals are achieved</li> </ol>"},{"location":"usage/cli/#multi-agent-coordination","title":"Multi-Agent Coordination","text":"<p>The supervisor agent orchestrates specialized agents:</p> <ul> <li>\ud83d\udcda Documentation Agent: Analyzes README files, guides, and documentation</li> <li>\ud83d\udcbb Codebase Agent: Examines source code, functions, and patterns</li> <li>\ud83c\udfd7\ufe0f Architecture Agent: Studies system design and architectural patterns</li> </ul>"},{"location":"usage/cli/#example-analysis-flow","title":"Example Analysis Flow","text":"<pre><code>$ python -m cf.run.simple_run analyze /path/to/repo --focus=all\n\n\ud83e\udd16 CodeFusion - Multi-Agent Analysis\n==================================================\n\u2705 Ready to explore: my-project\n\n\ud83d\udd0d Analyzing with focus: all\n------------------------------\n\n\ud83d\udccb Analysis Summary:\nSupervisor Coordination Summary:\n\u2022 Coordinated 3 agents\n\u2022 Generated 2 cross-agent insights\n\u2022 Documentation agent: Successfully completed analysis\n\u2022 Codebase agent: Successfully completed analysis\n\u2022 Architecture agent: Successfully completed analysis\n\u2022 Cross-agent insights: documentation_code_consistency, architecture_code_alignment\n\u2022 Total cache hits: 8\n\n\u23f1\ufe0f  Execution Time: 4.23s (6 iterations)\n</code></pre>"},{"location":"usage/cli/#configuration-integration","title":"Configuration Integration","text":""},{"location":"usage/cli/#environment-variables","title":"Environment Variables","text":"<p>Configure the ReAct framework using environment variables:</p> <pre><code># ReAct Loop Configuration\nexport CF_REACT_MAX_ITERATIONS=25\nexport CF_REACT_ITERATION_TIMEOUT=45.0\nexport CF_REACT_TOTAL_TIMEOUT=900.0\n\n# LLM Integration\nexport CF_LLM_MODEL=gpt-4\nexport CF_LLM_API_KEY=your-api-key\n\n# Caching Configuration\nexport CF_REACT_CACHE_ENABLED=true\nexport CF_REACT_CACHE_MAX_SIZE=1000\n\n# Run analysis\npython -m cf.run.simple_run analyze /path/to/repo --focus=all\n</code></pre>"},{"location":"usage/cli/#configuration-files","title":"Configuration Files","text":"<p>Use YAML configuration files:</p> <pre><code># config.yaml\nreact:\n  max_iterations: 25\n  iteration_timeout: 45.0\n  total_timeout: 900.0\n  cache_enabled: true\n  cache_max_size: 1000\n\nllm:\n  model: \"gpt-4\"\n  api_key: \"your-api-key\"\n  max_tokens: 1500\n  temperature: 0.3\n</code></pre> <pre><code># Use configuration file\npython -m cf.run.simple_run --config config.yaml analyze /path/to/repo\n</code></pre>"},{"location":"usage/cli/#llm-integration","title":"LLM Integration","text":""},{"location":"usage/cli/#supported-providers","title":"Supported Providers","text":"<p>CodeFusion supports multiple LLM providers via LiteLLM:</p> <pre><code># OpenAI\nexport CF_LLM_MODEL=gpt-4\nexport CF_LLM_API_KEY=your-openai-key\n\n# Anthropic Claude\nexport CF_LLM_MODEL=claude-3-sonnet-20240229\nexport CF_LLM_API_KEY=your-anthropic-key\n\n# LLaMA via Together AI\nexport CF_LLM_MODEL=together_ai/meta-llama/Llama-2-7b-chat-hf\nexport CF_LLM_API_KEY=your-together-ai-key\n\n# LLaMA via Ollama\nexport CF_LLM_MODEL=ollama/llama2\n</code></pre>"},{"location":"usage/cli/#installing-llm-support","title":"Installing LLM Support","text":"<pre><code># Install LiteLLM for full LLM support\npip install litellm\n\n# Framework works without LLM but with reduced capabilities\npython -m cf.run.simple_run analyze /path/to/repo --focus=all\n</code></pre>"},{"location":"usage/cli/#advanced-usage","title":"Advanced Usage","text":""},{"location":"usage/cli/#performance-tuning","title":"Performance Tuning","text":"<pre><code># Fast analysis (fewer iterations)\nCF_REACT_MAX_ITERATIONS=10 python -m cf.run.simple_run analyze /repo\n\n# Thorough analysis (more iterations)\nCF_REACT_MAX_ITERATIONS=50 python -m cf.run.simple_run analyze /repo\n\n# Custom cache size for large repositories\nCF_REACT_CACHE_MAX_SIZE=2000 python -m cf.run.simple_run analyze /repo\n</code></pre>"},{"location":"usage/cli/#debugging-and-monitoring","title":"Debugging and Monitoring","text":"<pre><code># Enable detailed tracing\nCF_REACT_TRACING_ENABLED=true CF_REACT_TRACE_DIR=./traces python -m cf.run.simple_run analyze /repo\n\n# View trace files\nls -la ./traces/\ncat ./traces/trace_*_supervisor.json\n\n# Enable verbose debugging\nCF_REACT_LOG_LEVEL=DEBUG python -m cf.run.simple_run --verbose analyze /repo\n</code></pre>"},{"location":"usage/cli/#focus-options","title":"Focus Options","text":"<p>Target specific analysis areas:</p> <pre><code># Documentation quality and coverage\npython -m cf.run.simple_run analyze /repo --focus=docs\n\n# Code patterns and security\npython -m cf.run.simple_run analyze /repo --focus=code\n\n# System architecture and design\npython -m cf.run.simple_run analyze /repo --focus=arch\n\n# Complete multi-agent analysis\npython -m cf.run.simple_run analyze /repo --focus=all\n</code></pre>"},{"location":"usage/cli/#demo-script","title":"Demo Script","text":"<p>Use the demo script for interactive exploration:</p> <pre><code># Run demo on any repository\npython demo_cf_framework.py /path/to/repo\n\n# Educational mode with explanations\npython demo_cf_framework.py /path/to/repo --focus=all\n\n# Quick focused demo\npython demo_cf_framework.py /path/to/repo --focus=docs --no-concepts\n\n# Self-analysis (analyze CodeFusion itself)\npython demo_cf_framework.py --self-analysis\n\n# Show framework comparison\npython demo_cf_framework.py --show-comparison\n\n# Show usage examples\npython demo_cf_framework.py --show-usage\n</code></pre>"},{"location":"usage/cli/#integration-examples","title":"Integration Examples","text":""},{"location":"usage/cli/#shell-aliases","title":"Shell Aliases","text":"<p>Create convenient aliases:</p> <pre><code># Add to ~/.bashrc or ~/.zshrc\nalias cf-analyze='python -m cf.run.simple_run analyze'\nalias cf-explore='python -m cf.run.simple_run explore'\nalias cf-demo='python demo_cf_framework.py'\n\n# Usage\ncf-analyze /path/to/repo --focus=all\ncf-explore /path/to/repo \"How does auth work?\"\ncf-demo /path/to/repo\n</code></pre>"},{"location":"usage/cli/#batch-analysis","title":"Batch Analysis","text":"<pre><code>#!/bin/bash\n# analyze-multiple-repos.sh\n\nREPOS=(\n    \"/path/to/repo1\"\n    \"/path/to/repo2\"\n    \"/path/to/repo3\"\n)\n\nfor repo in \"${REPOS[@]}\"; do\n    echo \"Analyzing: $repo\"\n    python -m cf.run.simple_run analyze \"$repo\" --focus=all\n    echo \"---\"\ndone\n</code></pre>"},{"location":"usage/cli/#cicd-integration","title":"CI/CD Integration","text":"<pre><code># .github/workflows/code-analysis.yml\nname: CodeFusion Analysis\non: [push, pull_request]\n\njobs:\n  analyze:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Setup Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: '3.9'\n\n      - name: Install CodeFusion\n        run: |\n          pip install -e .\n          pip install litellm\n\n      - name: Run Analysis\n        env:\n          CF_LLM_MODEL: gpt-3.5-turbo\n          CF_LLM_API_KEY: ${{ secrets.OPENAI_API_KEY }}\n        run: |\n          python -m cf.run.simple_run analyze . --focus=all\n</code></pre>"},{"location":"usage/cli/#troubleshooting","title":"Troubleshooting","text":""},{"location":"usage/cli/#common-issues","title":"Common Issues","text":"<p>Import errors: <pre><code># Check installation\npython -c \"import cf; print('CodeFusion installed')\"\n\n# Reinstall if needed\npip install -e .\n</code></pre></p> <p>LLM connection issues: <pre><code># Test without LLM\npython -m cf.run.simple_run analyze /repo --focus=code\n\n# Install LLM support\npip install litellm\n\n# Verify API key\necho $CF_LLM_API_KEY\n</code></pre></p> <p>Performance issues: <pre><code># Reduce iterations for faster analysis\nCF_REACT_MAX_ITERATIONS=10 python -m cf.run.simple_run analyze /repo\n\n# Disable caching for testing\nCF_REACT_CACHE_ENABLED=false python -m cf.run.simple_run analyze /repo\n</code></pre></p>"},{"location":"usage/cli/#debug-output","title":"Debug Output","text":"<p>Enable detailed logging:</p> <pre><code># Python logging\nCF_REACT_LOG_LEVEL=DEBUG python -m cf.run.simple_run --verbose analyze /repo\n\n# Save debug output\npython -m cf.run.simple_run --verbose analyze /repo 2&gt;&amp;1 | tee debug.log\n</code></pre>"},{"location":"usage/cli/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Configuration</li> <li>See Usage Examples </li> <li>Check the ReAct Framework Guide</li> <li>Explore the API Reference</li> </ul>"},{"location":"usage/configuration/","title":"Configuration","text":"<p>CodeFusion provides simple configuration options to customize exploration behavior for different repositories and use cases.</p>"},{"location":"usage/configuration/#configuration-methods","title":"Configuration Methods","text":""},{"location":"usage/configuration/#1-configuration-files","title":"1. Configuration Files","text":"<p>The primary way to configure CodeFusion is through YAML configuration files:</p> <pre><code>cf --config /path/to/config.yaml explore /path/to/repo \"How does authentication work?\"\n</code></pre>"},{"location":"usage/configuration/#2-command-line-options","title":"2. Command Line Options","text":"<p>Some settings can be overridden via command line:</p> <pre><code>cf --verbose explore /path/to/repo \"How does X work?\"\n</code></pre>"},{"location":"usage/configuration/#configuration-hierarchy","title":"Configuration Hierarchy","text":"<p>Settings are applied in order of precedence (highest to lowest):</p> <ol> <li>Command line options (highest priority)</li> <li>Configuration file (specified with <code>--config</code>)</li> <li>Default values (lowest priority)</li> </ol>"},{"location":"usage/configuration/#basic-configuration","title":"Basic Configuration","text":""},{"location":"usage/configuration/#default-configuration","title":"Default Configuration","text":"<pre><code># config/default/config.yaml\nrepo_path: null\noutput_dir: \"./output\"\n\n# File filtering\nmax_file_size: 1048576  # 1MB\nexcluded_dirs:\n  - \".git\"\n  - \"__pycache__\"\n  - \"node_modules\"\n  - \".venv\"\n  - \"venv\"\nexcluded_extensions:\n  - \".pyc\"\n  - \".pyo\"\n  - \".pyd\"\n  - \".so\"\n  - \".dll\"\n  - \".exe\"\n\n# Exploration settings\nmax_exploration_depth: 5\n</code></pre>"},{"location":"usage/configuration/#configuration-options","title":"Configuration Options","text":""},{"location":"usage/configuration/#core-settings","title":"Core Settings","text":""},{"location":"usage/configuration/#repo_path","title":"<code>repo_path</code>","text":"<ul> <li>Type: String (optional)</li> <li>Default: <code>null</code></li> <li>Description: Default repository path to explore</li> </ul> <pre><code>repo_path: \"/path/to/default/repo\"\n</code></pre>"},{"location":"usage/configuration/#output_dir","title":"<code>output_dir</code>","text":"<ul> <li>Type: String</li> <li>Default: <code>\"./output\"</code></li> <li>Description: Directory for output files and cache</li> </ul> <pre><code>output_dir: \"./my-output\"\n</code></pre>"},{"location":"usage/configuration/#file-filtering","title":"File Filtering","text":""},{"location":"usage/configuration/#max_file_size","title":"<code>max_file_size</code>","text":"<ul> <li>Type: Integer</li> <li>Default: <code>1048576</code> (1MB)</li> <li>Description: Maximum file size in bytes to process</li> </ul> <pre><code>max_file_size: 2097152  # 2MB\n</code></pre>"},{"location":"usage/configuration/#excluded_dirs","title":"<code>excluded_dirs</code>","text":"<ul> <li>Type: List of strings</li> <li>Default: <code>[\".git\", \"__pycache__\", \"node_modules\", \".venv\", \"venv\"]</code></li> <li>Description: Directories to exclude from exploration</li> </ul> <pre><code>excluded_dirs:\n  - \".git\"\n  - \"__pycache__\"\n  - \"node_modules\"\n  - \".venv\"\n  - \"venv\"\n  - \"dist\"\n  - \"build\"\n</code></pre>"},{"location":"usage/configuration/#excluded_extensions","title":"<code>excluded_extensions</code>","text":"<ul> <li>Type: List of strings</li> <li>Default: <code>[\".pyc\", \".pyo\", \".pyd\", \".so\", \".dll\", \".exe\"]</code></li> <li>Description: File extensions to exclude from exploration</li> </ul> <pre><code>excluded_extensions:\n  - \".pyc\"\n  - \".pyo\"\n  - \".pyd\"\n  - \".so\"\n  - \".dll\"\n  - \".exe\"\n  - \".log\"\n  - \".tmp\"\n</code></pre>"},{"location":"usage/configuration/#exploration-settings","title":"Exploration Settings","text":""},{"location":"usage/configuration/#max_exploration_depth","title":"<code>max_exploration_depth</code>","text":"<ul> <li>Type: Integer</li> <li>Default: <code>5</code></li> <li>Description: Maximum depth for recursive exploration</li> </ul> <pre><code>max_exploration_depth: 10\n</code></pre>"},{"location":"usage/configuration/#configuration-examples","title":"Configuration Examples","text":""},{"location":"usage/configuration/#basic-repository-configuration","title":"Basic Repository Configuration","text":"<pre><code># basic-config.yaml\nrepo_path: \"/path/to/my/project\"\noutput_dir: \"./codefusion-output\"\nmax_file_size: 1048576  # 1MB\nmax_exploration_depth: 5\n</code></pre>"},{"location":"usage/configuration/#large-repository-configuration","title":"Large Repository Configuration","text":"<pre><code># large-repo-config.yaml\nrepo_path: \"/path/to/large/project\"\noutput_dir: \"./large-repo-output\"\nmax_file_size: 2097152  # 2MB\nmax_exploration_depth: 3\n\n# Exclude additional directories for performance\nexcluded_dirs:\n  - \".git\"\n  - \"__pycache__\"\n  - \"node_modules\"\n  - \".venv\"\n  - \"venv\"\n  - \"dist\"\n  - \"build\"\n  - \"target\"\n  - \"out\"\n  - \"bin\"\n  - \"obj\"\n  - \"vendor\"\n  - \"external\"\n  - \"third_party\"\n\n# Exclude more file types\nexcluded_extensions:\n  - \".pyc\"\n  - \".pyo\"\n  - \".pyd\"\n  - \".so\"\n  - \".dll\"\n  - \".exe\"\n  - \".log\"\n  - \".tmp\"\n  - \".cache\"\n  - \".min.js\"\n  - \".min.css\"\n  - \".map\"\n</code></pre>"},{"location":"usage/configuration/#performance-optimized-configuration","title":"Performance-Optimized Configuration","text":"<pre><code># performance-config.yaml\nrepo_path: \"/path/to/project\"\noutput_dir: \"./fast-output\"\nmax_file_size: 524288  # 512KB (smaller files only)\nmax_exploration_depth: 3\n\n# Minimal exclusions for speed\nexcluded_dirs:\n  - \".git\"\n  - \"__pycache__\"\n  - \"node_modules\"\n  - \".venv\"\n\nexcluded_extensions:\n  - \".pyc\"\n  - \".pyo\"\n  - \".pyd\"\n</code></pre>"},{"location":"usage/configuration/#using-configuration-files","title":"Using Configuration Files","text":""},{"location":"usage/configuration/#create-configuration","title":"Create Configuration","text":"<pre><code># Create a new configuration file\ncp config/default/config.yaml my-config.yaml\n\n# Edit configuration\nnano my-config.yaml\n\n# Use configuration\ncf --config my-config.yaml explore /path/to/repo \"How does authentication work?\"\n</code></pre>"},{"location":"usage/configuration/#configuration-validation","title":"Configuration Validation","text":"<pre><code># Test configuration\ncf --config my-config.yaml summary /path/to/repo\n\n# Validate YAML syntax\npython -c \"import yaml; yaml.safe_load(open('my-config.yaml'))\"\n</code></pre>"},{"location":"usage/configuration/#repository-specific-configuration","title":"Repository-Specific Configuration","text":""},{"location":"usage/configuration/#project-specific-settings","title":"Project-Specific Settings","text":"<pre><code># web-app-config.yaml\nrepo_path: \"/path/to/web/app\"\noutput_dir: \"./web-app-analysis\"\nmax_file_size: 1048576\n\n# Web-specific exclusions\nexcluded_dirs:\n  - \".git\"\n  - \"__pycache__\"\n  - \"node_modules\"\n  - \".venv\"\n  - \"dist\"\n  - \"build\"\n  - \"public\"\n  - \"static\"\n\nexcluded_extensions:\n  - \".pyc\"\n  - \".pyo\"\n  - \".pyd\"\n  - \".min.js\"\n  - \".min.css\"\n  - \".map\"\n  - \".ico\"\n  - \".png\"\n  - \".jpg\"\n  - \".jpeg\"\n  - \".gif\"\n  - \".svg\"\n</code></pre>"},{"location":"usage/configuration/#language-specific-settings","title":"Language-Specific Settings","text":"<pre><code># python-project-config.yaml\nrepo_path: \"/path/to/python/project\"\noutput_dir: \"./python-analysis\"\nmax_file_size: 1048576\n\n# Python-specific exclusions\nexcluded_dirs:\n  - \".git\"\n  - \"__pycache__\"\n  - \".venv\"\n  - \"venv\"\n  - \"env\"\n  - \".pytest_cache\"\n  - \".mypy_cache\"\n  - \"dist\"\n  - \"build\"\n  - \"*.egg-info\"\n\nexcluded_extensions:\n  - \".pyc\"\n  - \".pyo\"\n  - \".pyd\"\n  - \".so\"\n  - \".dll\"\n  - \".exe\"\n</code></pre>"},{"location":"usage/configuration/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"usage/configuration/#configuration-templates","title":"Configuration Templates","text":"<p>Create template configurations for different scenarios:</p> <pre><code># Create templates directory\nmkdir -p config/templates\n\n# Create template configurations\ncat &gt; config/templates/web-app.yaml &lt;&lt; 'EOF'\n# Web application configuration\nmax_file_size: 1048576\nexcluded_dirs:\n  - \".git\"\n  - \"__pycache__\"\n  - \"node_modules\"\n  - \".venv\"\n  - \"dist\"\n  - \"build\"\n  - \"public\"\n  - \"static\"\nmax_exploration_depth: 5\nEOF\n\ncat &gt; config/templates/large-repo.yaml &lt;&lt; 'EOF'\n# Large repository configuration\nmax_file_size: 2097152\nexcluded_dirs:\n  - \".git\"\n  - \"__pycache__\"\n  - \"node_modules\"\n  - \".venv\"\n  - \"venv\"\n  - \"dist\"\n  - \"build\"\n  - \"target\"\n  - \"out\"\n  - \"bin\"\n  - \"obj\"\n  - \"vendor\"\nmax_exploration_depth: 3\nEOF\n\n# Use templates\ncf --config config/templates/web-app.yaml explore /path/to/web/app \"How does authentication work?\"\n</code></pre>"},{"location":"usage/configuration/#dynamic-configuration","title":"Dynamic Configuration","text":"<pre><code>#!/bin/bash\n# generate-config.sh - Generate configuration based on repository type\n\nREPO_PATH=\"$1\"\nCONFIG_FILE=\"generated-config.yaml\"\n\n# Detect repository type\nif [ -f \"$REPO_PATH/package.json\" ]; then\n    echo \"Detected Node.js project\"\n    cp config/templates/web-app.yaml \"$CONFIG_FILE\"\nelif [ -f \"$REPO_PATH/requirements.txt\" ] || [ -f \"$REPO_PATH/setup.py\" ]; then\n    echo \"Detected Python project\"\n    cp config/templates/python-project.yaml \"$CONFIG_FILE\"\nelse\n    echo \"Using default configuration\"\n    cp config/default/config.yaml \"$CONFIG_FILE\"\nfi\n\n# Set repository path\nsed -i \"s|repo_path: null|repo_path: \\\"$REPO_PATH\\\"|\" \"$CONFIG_FILE\"\n\necho \"Generated configuration: $CONFIG_FILE\"\n</code></pre>"},{"location":"usage/configuration/#troubleshooting-configuration","title":"Troubleshooting Configuration","text":""},{"location":"usage/configuration/#common-issues","title":"Common Issues","text":"<p>Invalid YAML syntax: <pre><code># Check YAML syntax\npython -c \"import yaml; yaml.safe_load(open('config.yaml'))\"\n</code></pre></p> <p>Configuration not found: <pre><code># Check file exists\nls -la config.yaml\n\n# Use absolute path\ncf --config /full/path/to/config.yaml explore /path/to/repo \"How does X work?\"\n</code></pre></p> <p>Permission issues: <pre><code># Check file permissions\nls -la config.yaml\n\n# Fix permissions\nchmod 644 config.yaml\n</code></pre></p>"},{"location":"usage/configuration/#debug-configuration","title":"Debug Configuration","text":"<pre><code># Test configuration with verbose output\ncf --verbose --config config.yaml summary /path/to/repo\n\n# Validate configuration file\npython -c \"\nimport yaml\nfrom cf.config import CfConfig\nconfig = CfConfig.from_file('config.yaml')\nconfig.validate()\nprint('Configuration is valid')\n\"\n</code></pre>"},{"location":"usage/configuration/#best-practices","title":"Best Practices","text":""},{"location":"usage/configuration/#configuration-management","title":"Configuration Management","text":"<ol> <li>Use version control for configuration files</li> <li>Create project-specific configurations for different repositories</li> <li>Use templates for common scenarios</li> <li>Document custom configurations with comments</li> <li>Validate configurations before use</li> </ol>"},{"location":"usage/configuration/#performance-optimization","title":"Performance Optimization","text":"<ol> <li>Exclude unnecessary directories to improve speed</li> <li>Set appropriate file size limits for your use case</li> <li>Use smaller exploration depths for large repositories</li> <li>Test configurations with sample repositories first</li> </ol>"},{"location":"usage/configuration/#security-considerations","title":"Security Considerations","text":"<ol> <li>Never commit sensitive information in configuration files</li> <li>Use appropriate file permissions (644 for config files)</li> <li>Be careful with excluded directories - don't exclude important code</li> </ol>"},{"location":"usage/configuration/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about CLI Usage</li> <li>See Usage Examples</li> <li>Check the Installation Guide</li> </ul>"},{"location":"usage/examples/","title":"Usage Examples","text":"<p>This page shows practical examples of using CodeFusion for code exploration.</p>"},{"location":"usage/examples/#basic-exploration","title":"Basic Exploration","text":""},{"location":"usage/examples/#explore-authentication","title":"Explore Authentication","text":"<pre><code># Start with a broad question\ncf explore /path/to/webapp \"How does authentication work?\"\n\n# Continue with specific questions\ncf continue /path/to/webapp \"How are passwords validated?\" --previous \"How does authentication work?\"\n\n# Explore session management\ncf continue /path/to/webapp \"How are user sessions managed?\" --previous \"How are passwords validated?\"\n</code></pre>"},{"location":"usage/examples/#explore-api-structure","title":"Explore API Structure","text":"<pre><code># Understand API endpoints\ncf explore /path/to/api \"What are the main API endpoints?\"\n\n# Dive into validation\ncf continue /path/to/api \"How is input validation handled?\" --previous \"What are the main API endpoints?\"\n\n# Check error handling\ncf continue /path/to/api \"How are API errors handled?\" --previous \"How is input validation handled?\"\n</code></pre>"},{"location":"usage/examples/#common-investigation-patterns","title":"Common Investigation Patterns","text":""},{"location":"usage/examples/#understanding-new-codebase","title":"Understanding New Codebase","text":"<pre><code># Start with architecture overview\ncf explore /path/to/project \"What is the overall architecture?\"\n\n# Explore main entry points\ncf continue /path/to/project \"How does the application start up?\" --previous \"What is the overall architecture?\"\n\n# Check configuration\ncf continue /path/to/project \"How is the application configured?\" --previous \"How does the application start up?\"\n</code></pre>"},{"location":"usage/examples/#debugging-issues","title":"Debugging Issues","text":"<pre><code># Explore error handling\ncf explore /path/to/project \"How are errors handled and logged?\"\n\n# Check testing approach\ncf continue /path/to/project \"What testing strategies are used?\" --previous \"How are errors handled and logged?\"\n\n# Understand deployment\ncf continue /path/to/project \"How is the application deployed?\" --previous \"What testing strategies are used?\"\n</code></pre>"},{"location":"usage/examples/#advanced-usage","title":"Advanced Usage","text":""},{"location":"usage/examples/#configuration-for-large-repositories","title":"Configuration for Large Repositories","text":"<pre><code># Create optimized config for large repos\ncat &gt; large-repo-config.yaml &lt;&lt; 'EOF'\nmax_file_size: 2097152  # 2MB\nmax_exploration_depth: 3\nexcluded_dirs:\n  - \".git\"\n  - \"__pycache__\"\n  - \"node_modules\"\n  - \".venv\"\n  - \"dist\"\n  - \"build\"\n  - \"vendor\"\n  - \"target\"\nEOF\n\n# Use optimized config\ncf --config large-repo-config.yaml explore /path/to/large/repo \"How does the core system work?\"\n</code></pre>"},{"location":"usage/examples/#batch-exploration","title":"Batch Exploration","text":"<pre><code>#!/bin/bash\n# Explore multiple related questions\nREPO=\"/path/to/project\"\nQUESTIONS=(\n    \"How does authentication work?\"\n    \"What are the main API endpoints?\"\n    \"How is data validation handled?\"\n    \"What testing frameworks are used?\"\n    \"How is the application deployed?\"\n)\n\nfor question in \"${QUESTIONS[@]}\"; do\n    echo \"Exploring: $question\"\n    cf explore \"$REPO\" \"$question\"\n    echo \"---\"\ndone\n</code></pre>"},{"location":"usage/examples/#building-understanding-incrementally","title":"Building Understanding Incrementally","text":"<pre><code># Start broad\ncf explore /path/to/ecommerce \"What is the overall architecture?\"\n\n# Narrow down to specific domains\ncf continue /path/to/ecommerce \"How does the shopping cart work?\" --previous \"What is the overall architecture?\"\n\n# Get specific implementation details\ncf continue /path/to/ecommerce \"How are cart items persisted?\" --previous \"How does the shopping cart work?\"\n\n# Explore related functionality\ncf continue /path/to/ecommerce \"How does checkout process work?\" --previous \"How are cart items persisted?\"\n</code></pre>"},{"location":"usage/examples/#language-specific-examples","title":"Language-Specific Examples","text":""},{"location":"usage/examples/#python-projects","title":"Python Projects","text":"<pre><code># Explore Python project structure\ncf explore /path/to/python/project \"How is the package structure organized?\"\n\n# Check dependency management\ncf continue /path/to/python/project \"How are dependencies managed?\" --previous \"How is the package structure organized?\"\n\n# Understand testing\ncf continue /path/to/python/project \"How are tests organized and run?\" --previous \"How are dependencies managed?\"\n</code></pre>"},{"location":"usage/examples/#javascriptnodejs-projects","title":"JavaScript/Node.js Projects","text":"<pre><code># Explore Node.js application\ncf explore /path/to/node/app \"How is the Express.js application structured?\"\n\n# Check middleware\ncf continue /path/to/node/app \"What middleware is used?\" --previous \"How is the Express.js application structured?\"\n\n# Explore frontend build\ncf continue /path/to/node/app \"How is the frontend built and served?\" --previous \"What middleware is used?\"\n</code></pre>"},{"location":"usage/examples/#web-applications","title":"Web Applications","text":"<pre><code># Explore web app architecture\ncf explore /path/to/webapp \"How is the MVC pattern implemented?\"\n\n# Check database interactions\ncf continue /path/to/webapp \"How does the application interact with the database?\" --previous \"How is the MVC pattern implemented?\"\n\n# Explore frontend integration\ncf continue /path/to/webapp \"How is the frontend integrated with the backend?\" --previous \"How does the application interact with the database?\"\n</code></pre>"},{"location":"usage/examples/#performance-tips","title":"Performance Tips","text":""},{"location":"usage/examples/#effective-questions","title":"Effective Questions","text":"<p>Good questions: - \"How does authentication work?\" - \"What are the main API endpoints?\" - \"How is data stored and retrieved?\" - \"What testing strategies are used?\"</p> <p>Less effective questions: - \"Tell me about this code\" (too vague) - \"What is line 42 in file.py?\" (too specific) - \"Is this code good?\" (subjective)</p>"},{"location":"usage/examples/#exploration-strategies","title":"Exploration Strategies","text":"<p>Start broad, then narrow: <pre><code># 1. Get overview\ncf explore /path/to/repo \"What is the overall architecture?\"\n\n# 2. Focus on area of interest\ncf continue /path/to/repo \"How does the authentication system work?\" --previous \"What is the overall architecture?\"\n\n# 3. Get implementation details\ncf continue /path/to/repo \"How are JWT tokens validated?\" --previous \"How does the authentication system work?\"\n</code></pre></p> <p>Use the cache effectively: <pre><code># Related questions benefit from cache\ncf explore /path/to/repo \"How does authentication work?\"\ncf continue /path/to/repo \"How are user sessions managed?\" --previous \"How does authentication work?\"\ncf continue /path/to/repo \"How are passwords validated?\" --previous \"How are user sessions managed?\"\n</code></pre></p>"},{"location":"usage/examples/#integration-examples","title":"Integration Examples","text":""},{"location":"usage/examples/#vs-code-integration","title":"VS Code Integration","text":"<p>Create a VS Code task:</p> <pre><code>// .vscode/tasks.json\n{\n    \"version\": \"2.0.0\",\n    \"tasks\": [\n        {\n            \"label\": \"CodeFusion Explore\",\n            \"type\": \"shell\",\n            \"command\": \"cf\",\n            \"args\": [\"explore\", \"${workspaceFolder}\", \"${input:question}\"],\n            \"group\": \"build\",\n            \"presentation\": {\n                \"echo\": true,\n                \"reveal\": \"always\",\n                \"focus\": false,\n                \"panel\": \"shared\"\n            }\n        }\n    ],\n    \"inputs\": [\n        {\n            \"id\": \"question\",\n            \"description\": \"Question to explore\",\n            \"default\": \"How does authentication work?\",\n            \"type\": \"promptString\"\n        }\n    ]\n}\n</code></pre>"},{"location":"usage/examples/#shell-aliases","title":"Shell Aliases","text":"<p>Add to your <code>.bashrc</code> or <code>.zshrc</code>:</p> <pre><code># CodeFusion aliases\nalias cfx='cf explore'\nalias cfa='cf ask'\nalias cfc='cf continue'\nalias cfs='cf summary'\n\n# Usage\ncfx /path/to/repo \"How does login work?\"\ncfa /path/to/repo \"What are the API endpoints?\"\ncfc /path/to/repo \"How is validation handled?\" --previous \"What are the API endpoints?\"\n</code></pre>"},{"location":"usage/examples/#troubleshooting-examples","title":"Troubleshooting Examples","text":""},{"location":"usage/examples/#common-issues","title":"Common Issues","text":"<p>Slow exploration: <pre><code># Create performance config\ncat &gt; fast-config.yaml &lt;&lt; 'EOF'\nmax_file_size: 524288  # 512KB\nmax_exploration_depth: 3\nexcluded_dirs:\n  - \".git\"\n  - \"__pycache__\"\n  - \"node_modules\"\n  - \".venv\"\n  - \"dist\"\n  - \"build\"\nEOF\n\ncf --config fast-config.yaml explore /path/to/repo \"How does X work?\"\n</code></pre></p> <p>Permission issues: <pre><code># Check permissions\nls -la /path/to/repo\n\n# Fix if needed\nchmod -R 755 /path/to/repo\n</code></pre></p> <p>Configuration errors: <pre><code># Test configuration\ncf --config my-config.yaml summary /path/to/repo\n\n# Validate YAML\npython -c \"import yaml; yaml.safe_load(open('my-config.yaml'))\"\n</code></pre></p>"},{"location":"usage/examples/#multi-agent-framework-examples","title":"Multi-Agent Framework Examples","text":""},{"location":"usage/examples/#comprehensive-repository-analysis","title":"Comprehensive Repository Analysis","text":"<pre><code># Run comprehensive multi-agent analysis\ncf analyze /path/to/repo\n\n# Focus on specific areas\ncf analyze /path/to/repo --focus docs\ncf analyze /path/to/repo --focus code\ncf analyze /path/to/repo --focus arch\n</code></pre>"},{"location":"usage/examples/#advanced-multi-agent-workflows","title":"Advanced Multi-Agent Workflows","text":"<pre><code># Full comprehensive analysis\ncf analyze /path/to/large/project --focus all\n\n# Documentation-focused analysis\ncf analyze /path/to/project --focus docs\n\n# Code structure analysis\ncf analyze /path/to/project --focus code\n\n# Architecture mapping\ncf analyze /path/to/project --focus arch\n</code></pre>"},{"location":"usage/examples/#configuration-for-multi-agent-system","title":"Configuration for Multi-Agent System","text":"<pre><code># multi-agent-config.yaml\nagents:\n  supervisor:\n    enabled: true\n    max_agents: 6\n    timeout: 600  # 10 minutes\n\n  documentation:\n    enabled: true\n    file_types: [\".md\", \".rst\", \".txt\", \".adoc\", \".wiki\"]\n    max_files: 100\n\n  codebase:\n    enabled: true\n    languages: [\"python\", \"javascript\", \"typescript\", \"java\", \"go\", \"rust\", \"c\", \"cpp\", \"kotlin\", \"swift\"]\n    max_files: 500\n\n  architecture:\n    enabled: true\n    diagram_types: [\"mermaid\", \"plantuml\", \"graphviz\", \"drawio\"]\n    max_components: 200\n\n  summary:\n    enabled: true\n    max_sections: 15\n    cheat_sheet_format: \"markdown\"\n\nerror_recovery:\n  enabled: true\n  max_retries: 5\n  circuit_breaker_threshold: 8\n  loop_detection_window: 15\n</code></pre>"},{"location":"usage/examples/#usage-with-custom-configuration","title":"Usage with Custom Configuration","text":"<pre><code># Use custom multi-agent config\ncf --config multi-agent-config.yaml analyze /path/to/enterprise/repo\n\n# Generate comprehensive documentation\ncf --config multi-agent-config.yaml analyze /path/to/repo --focus docs &gt; project-analysis.md\n\n# Architecture mapping for complex systems\ncf --config multi-agent-config.yaml analyze /path/to/microservices --focus arch\n</code></pre>"},{"location":"usage/examples/#integration-with-cicd","title":"Integration with CI/CD","text":"<pre><code># .github/workflows/codefusion-analysis.yml\nname: CodeFusion Analysis\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  analyze:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Setup Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: '3.11'\n      - name: Install CodeFusion\n        run: pip install codefusion\n      - name: Run Multi-Agent Analysis\n        run: |\n          cf analyze . --focus all &gt; analysis-report.md\n          cf analyze . --focus code &gt; code-structure.md\n      - name: Upload Analysis\n        uses: actions/upload-artifact@v3\n        with:\n          name: codefusion-analysis\n          path: |\n            analysis-report.md\n            code-structure.md\n</code></pre>"},{"location":"usage/examples/#error-recovery-examples","title":"Error Recovery Examples","text":"<pre><code># Enable verbose error reporting\ncf --verbose analyze /path/to/complex/repo\n\n# Custom error recovery settings\ncat &gt; error-config.yaml &lt;&lt; 'EOF'\nerror_recovery:\n  enabled: true\n  max_retries: 3\n  circuit_breaker_threshold: 5\n  loop_detection_window: 10\nagents:\n  supervisor:\n    timeout: 300\nEOF\n\ncf --config error-config.yaml analyze /path/to/repo\n</code></pre>"},{"location":"usage/examples/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about CLI Commands</li> <li>Understand Configuration</li> <li>Check the Installation Guide</li> <li>Explore Multi-Agent Architecture</li> </ul>"}]}